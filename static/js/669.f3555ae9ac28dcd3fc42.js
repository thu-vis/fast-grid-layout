(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[669],{4709:function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(9252)(true);\n// imports\n\n\n// module\nexports.push([module.id, "/* \\n  Since 4.10.0, you don\'t need to import css flie any more,\\n  this flie is only used for backward compatible. Maybe deleted  \\n  in the future.\\n*/\\n", "", {"version":3,"sources":["/data/zhaowei/fast-grid-layout/frontend/node_modules/vuescroll/dist/vuescroll.css"],"names":[],"mappings":"AAAA;;;;EAIE","file":"vuescroll.css","sourcesContent":["/* \\n  Since 4.10.0, you don\'t need to import css flie any more,\\n  this flie is only used for backward compatible. Maybe deleted  \\n  in the future.\\n*/\\n"],"sourceRoot":""}]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcwOS5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyxJQUFrQztBQUNyRTs7O0FBR0E7QUFDQSw2TEFBNkwsMklBQTJJLDhOQUE4Tjs7QUFFdGlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvdnVlc2Nyb2xsL2Rpc3QvdnVlc2Nyb2xsLmNzcz8xNmFlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIFxcbiAgU2luY2UgNC4xMC4wLCB5b3UgZG9uJ3QgbmVlZCB0byBpbXBvcnQgY3NzIGZsaWUgYW55IG1vcmUsXFxuICB0aGlzIGZsaWUgaXMgb25seSB1c2VkIGZvciBiYWNrd2FyZCBjb21wYXRpYmxlLiBNYXliZSBkZWxldGVkICBcXG4gIGluIHRoZSBmdXR1cmUuXFxuKi9cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2RhdGEvemhhb3dlaS9mYXN0LWdyaWQtbGF5b3V0L2Zyb250ZW5kL25vZGVfbW9kdWxlcy92dWVzY3JvbGwvZGlzdC92dWVzY3JvbGwuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOzs7O0VBSUVcIixcImZpbGVcIjpcInZ1ZXNjcm9sbC5jc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyogXFxuICBTaW5jZSA0LjEwLjAsIHlvdSBkb24ndCBuZWVkIHRvIGltcG9ydCBjc3MgZmxpZSBhbnkgbW9yZSxcXG4gIHRoaXMgZmxpZSBpcyBvbmx5IHVzZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGlibGUuIE1heWJlIGRlbGV0ZWQgIFxcbiAgaW4gdGhlIGZ1dHVyZS5cXG4qL1xcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4709\n')},5661:function(module,__unused_webpack_exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(4709);\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(7913)(\"a570bc54\", content, true, {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY2MS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUF1SjtBQUM3SztBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsSUFBZ0QsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvdnVlc2Nyb2xsL2Rpc3QvdnVlc2Nyb2xsLmNzcz9hNTMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTZbMF0ucnVsZXNbMF0udXNlWzFdIS4uLy4uL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC02WzBdLnJ1bGVzWzBdLnVzZVsyXSEuL3Z1ZXNjcm9sbC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiYTU3MGJjNTRcIiwgY29udGVudCwgdHJ1ZSwge30pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5661\n")},5680:function(module,__unused_webpack_exports,__webpack_require__){eval("/*\n    * Vuescroll v4.17.3\n    * (c) 2018-2021 Yi(Yves) Wang\n    * Released under the MIT License\n    * Github: https://github.com/YvesCoding/vuescroll\n    * Website: http://vuescrolljs.yvescoding.org/\n    */\n   \n(function (global, factory) {\n\t true ? module.exports = factory(__webpack_require__(538)) :\n\t0;\n}(this, (function (Vue) { 'use strict';\n\nVue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction isIE() {\n  /* istanbul ignore if */\n  if (isServer()) return false;\n\n  var agent = navigator.userAgent.toLowerCase();\n  return agent.indexOf('msie') !== -1 || agent.indexOf('trident') !== -1 || agent.indexOf(' edge/') !== -1;\n}\n\nvar isIos = function isIos() {\n  /* istanbul ignore if */\n  if (isServer()) return false;\n\n  var u = navigator.userAgent;\n  return !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);\n};\n\n/* istanbul ignore next */\nvar isServer = function isServer() {\n  return Vue.prototype.$isServer;\n};\n\nvar touchManager = function () {\n  function touchManager() {\n    classCallCheck(this, touchManager);\n  }\n\n  createClass(touchManager, [{\n    key: 'getEventObject',\n    value: function getEventObject(originEvent) {\n      return this.touchObject ? this.isTouch ? originEvent.touches : [originEvent] : null;\n    }\n  }, {\n    key: 'getTouchObject',\n    value: function getTouchObject() /* istanbul ignore next */{\n      if (isServer()) return null;\n\n      this.isTouch = false;\n      var agent = navigator.userAgent,\n          platform = navigator.platform,\n          touchObject = {};\n      touchObject.touch = !!('ontouchstart' in window && !window.opera || 'msmaxtouchpoints' in window.navigator || 'maxtouchpoints' in window.navigator || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0);\n      touchObject.nonDeskTouch = touchObject.touch && !/win32/i.test(platform) || touchObject.touch && /win32/i.test(platform) && /mobile/i.test(agent);\n\n      touchObject.eventType = 'onmousedown' in window && !touchObject.nonDeskTouch ? 'mouse' : 'ontouchstart' in window ? 'touch' : 'msmaxtouchpoints' in window.navigator || navigator.msMaxTouchPoints > 0 ? 'mstouchpoints' : 'maxtouchpoints' in window.navigator || navigator.maxTouchPoints > 0 ? 'touchpoints' : 'mouse';\n      switch (touchObject.eventType) {\n        case 'mouse':\n          touchObject.touchstart = 'mousedown';\n          touchObject.touchend = 'mouseup';\n          touchObject.touchmove = 'mousemove';\n\n          touchObject.touchenter = 'mouseenter';\n          touchObject.touchmove = 'mousemove';\n          touchObject.touchleave = 'mouseleave';\n          break;\n        case 'touch':\n          touchObject.touchstart = 'touchstart';\n          touchObject.touchend = 'touchend';\n          touchObject.touchmove = 'touchmove';\n          touchObject.touchcancel = 'touchcancel';\n\n          touchObject.touchenter = 'touchstart';\n          touchObject.touchmove = 'touchmove';\n          touchObject.touchleave = 'touchend';\n          this.isTouch = true;\n          break;\n        case 'mstouchpoints':\n          touchObject.touchstart = 'MSPointerDown';\n          touchObject.touchend = 'MSPointerUp';\n          touchObject.touchmove = 'MSPointerMove';\n          touchObject.touchcancel = 'MSPointerCancel';\n\n          touchObject.touchenter = 'MSPointerDown';\n          touchObject.touchmove = 'MSPointerMove';\n          touchObject.touchleave = 'MSPointerUp';\n          break;\n        case 'touchpoints':\n          touchObject.touchstart = 'pointerdown';\n          touchObject.touchend = 'pointerup';\n          touchObject.touchmove = 'pointermove';\n          touchObject.touchcancel = 'pointercancel';\n\n          touchObject.touchenter = 'pointerdown';\n          touchObject.touchmove = 'pointermove';\n          touchObject.touchleave = 'pointerup';\n          break;\n      }\n\n      return this.touchObject = touchObject;\n    }\n  }]);\n  return touchManager;\n}();\n\nfunction deepCopy(from, to, shallow) {\n  if (shallow && isUndef(to)) {\n    return from;\n  }\n\n  if (isArray(from)) {\n    to = [];\n    from.forEach(function (item, index) {\n      to[index] = deepCopy(item, to[index]);\n    });\n  } else if (from) {\n    if (!isPlainObj(from)) {\n      return from;\n    }\n    to = {};\n    for (var key in from) {\n      to[key] = _typeof(from[key]) === 'object' ? deepCopy(from[key], to[key]) : from[key];\n    }\n  }\n  return to;\n}\n\nfunction mergeObject(from, to, force, shallow) {\n  if (shallow && isUndef(to)) {\n    return from;\n  }\n\n  to = to || {};\n\n  if (isArray(from)) {\n    if (!isArray(to) && force) {\n      to = [];\n    }\n    if (isArray(to)) {\n      from.forEach(function (item, index) {\n        to[index] = mergeObject(item, to[index], force, shallow);\n      });\n    }\n  } else if (from) {\n    if (!isPlainObj(from)) {\n      if (force) {\n        to = from;\n      }\n    } else {\n      for (var key in from) {\n        if (_typeof(from[key]) === 'object') {\n          if (isUndef(to[key])) {\n            to[key] = deepCopy(from[key], to[key], shallow);\n          } else {\n            mergeObject(from[key], to[key], force, shallow);\n          }\n        } else {\n          if (isUndef(to[key]) || force) to[key] = from[key];\n        }\n      }\n    }\n  }\n\n  return to;\n}\n\nfunction defineReactive(target, key, source, souceKey) {\n  /* istanbul ignore if */\n  if (!source[key] && typeof source !== 'function') {\n    return;\n  }\n  souceKey = souceKey || key;\n  Object.defineProperty(target, key, {\n    get: function get$$1() {\n      return source[souceKey];\n    },\n\n    configurable: true\n  });\n}\n\nvar scrollBarWidth = void 0;\nfunction getGutter() {\n  /* istanbul ignore next */\n  if (isServer()) return 0;\n  if (scrollBarWidth !== undefined) return scrollBarWidth;\n  var outer = document.createElement('div');\n  outer.style.visibility = 'hidden';\n  outer.style.width = '100px';\n  outer.style.position = 'absolute';\n  outer.style.top = '-9999px';\n  document.body.appendChild(outer);\n\n  var widthNoScroll = outer.offsetWidth;\n  outer.style.overflow = 'scroll';\n\n  var inner = document.createElement('div');\n  inner.style.width = '100%';\n  outer.appendChild(inner);\n\n  var widthWithScroll = inner.offsetWidth;\n  outer.parentNode.removeChild(outer);\n  scrollBarWidth = widthNoScroll - widthWithScroll;\n\n  return scrollBarWidth;\n}\n\nfunction eventCenter(dom, eventName, hander) {\n  var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var type = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'on';\n\n  type == 'on' ? dom.addEventListener(eventName, hander, capture) : dom.removeEventListener(eventName, hander, capture);\n}\n\n\nvar warn = function warn(msg) {\n  console.warn('[vuescroll] ' + msg);\n};\n\nfunction isChildInParent(child, parent) {\n  var flag = false;\n  if (!child || !parent) {\n    return flag;\n  }\n  while (child.parentNode !== parent && child.parentNode.nodeType !== 9 && !child.parentNode._isVuescroll) {\n    child = child.parentNode;\n  }\n  if (child.parentNode == parent) {\n    flag = true;\n  }\n  return flag;\n}\n\nfunction getPrefix(global) {\n  var docStyle = document.documentElement.style;\n  var engine;\n  /* istanbul ignore if */\n  if (global.opera && Object.prototype.toString.call(opera) === '[object Opera]') {\n    engine = 'presto';\n  } /* istanbul ignore next */else if ('MozAppearance' in docStyle) {\n      engine = 'gecko';\n    } else if ('WebkitAppearance' in docStyle) {\n      engine = 'webkit';\n    } /* istanbul ignore next */else if (typeof navigator.cpuClass === 'string') {\n        engine = 'trident';\n      }\n  var vendorPrefix = {\n    trident: 'ms',\n    gecko: 'moz',\n    webkit: 'webkit',\n    presto: 'O'\n  }[engine];\n  return vendorPrefix;\n}\n\nfunction getComplitableStyle(property, value) {\n  /* istanbul ignore if */\n  if (isServer()) return false;\n\n  var compatibleValue = '-' + getPrefix(window) + '-' + value;\n  var testElm = document.createElement('div');\n  testElm.style[property] = compatibleValue;\n  if (testElm.style[property] == compatibleValue) {\n    return compatibleValue;\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\n/**\n * Insert children into user-passed slot at vnode level\n */\nfunction insertChildrenIntoSlot(h) {\n  var parentVnode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var childVNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var swapChildren = arguments[4];\n\n  /* istanbul ignore if */\n  if (parentVnode && parentVnode.length > 1) {\n    return swapChildren ? [].concat(toConsumableArray(childVNode), toConsumableArray(parentVnode)) : [].concat(toConsumableArray(parentVnode), toConsumableArray(childVNode));\n  }\n\n  parentVnode = parentVnode[0];\n\n  var _getVnodeInfo = getVnodeInfo(parentVnode),\n      ch = _getVnodeInfo.ch,\n      tag = _getVnodeInfo.tag,\n      isComponent = _getVnodeInfo.isComponent;\n\n  if (isComponent) {\n    parentVnode.data = mergeObject({ attrs: parentVnode.componentOptions.propsData }, parentVnode.data, false, // force: false\n    true // shallow: true\n    );\n  }\n  ch = swapChildren ? [].concat(toConsumableArray(childVNode), toConsumableArray(ch)) : [].concat(toConsumableArray(ch), toConsumableArray(childVNode));\n  delete parentVnode.data.slot;\n\n  return h(tag, mergeObject(data, parentVnode.data, false, true), ch);\n}\n\n/**\n *  Get the info of a vnode,\n * vnode must be parentVnode\n */\nfunction getVnodeInfo(vnode) {\n  if (!vnode || vnode.length > 1) return {};\n\n  vnode = vnode[0] ? vnode[0] : vnode;\n  var isComponent = !!vnode.componentOptions;\n  var ch = void 0;\n  var tag = void 0;\n\n  if (isComponent) {\n    ch = vnode.componentOptions.children || [];\n    tag = vnode.componentOptions.tag;\n  } else {\n    ch = vnode.children || [];\n    tag = vnode.tag;\n  }\n\n  return {\n    isComponent: isComponent,\n    ch: ch,\n    tag: tag\n  };\n}\n\n/**\n * Get the vuescroll instance instead of\n * user pass component like slot.\n */\nfunction getRealParent(ctx) {\n  var parent = ctx.$parent;\n  if (!parent._isVuescrollRoot && parent) {\n    parent = parent.$parent;\n  }\n  return parent;\n}\n\nvar isArray = function isArray(_) {\n  return Array.isArray(_);\n};\nvar isPlainObj = function isPlainObj(_) {\n  return Object.prototype.toString.call(_) == '[object Object]';\n};\nvar isUndef = function isUndef(_) {\n  return typeof _ === 'undefined';\n};\n\nfunction getNumericValue(distance, size) {\n  var number = void 0;\n  if (!(number = /(-?\\d+(?:\\.\\d+?)?)%$/.exec(distance))) {\n    number = distance - 0;\n  } else {\n    number = number[1] - 0;\n    number = size * number / 100;\n  }\n  return number;\n}\n\nfunction createStyle(styleId, cssText) {\n  /* istanbul ignore if */\n  if (isServer() || document.getElementById(styleId)) {\n    return;\n  }\n\n  var head = document.head || doc.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n\n  style.id = styleId;\n  style.type = 'text/css';\n\n  /* istanbul ignore if */\n  if (style.styleSheet) {\n    style.styleSheet.cssText = cssText;\n  } else {\n    style.appendChild(document.createTextNode(cssText));\n  }\n\n  head.appendChild(style);\n}\n\n// Hide the ios native scrollbar.\nfunction createHideBarStyle() {\n  /* istanbul ignore next */\n  {\n    var cssText = '.__hidebar::-webkit-scrollbar {\\n      width: 0;\\n      height: 0;\\n    }';\n\n    createStyle('vuescroll-hide-ios-bar', cssText);\n  }\n}\n\n// create slide mode style\n\nvar api = {\n  mounted: function mounted() {\n    vsInstances[this._uid] = this;\n  },\n  beforeDestroy: function beforeDestroy() {\n    delete vsInstances[this._uid];\n  },\n\n  methods: {\n    // public api\n    scrollTo: function scrollTo(_ref, speed, easing) {\n      var x = _ref.x,\n          y = _ref.y;\n\n      // istanbul ignore if\n      if (speed === true || typeof speed == 'undefined') {\n        speed = this.mergedOptions.scrollPanel.speed;\n      }\n      this.internalScrollTo(x, y, speed, easing);\n    },\n    scrollBy: function scrollBy(_ref2, speed, easing) {\n      var _ref2$dx = _ref2.dx,\n          dx = _ref2$dx === undefined ? 0 : _ref2$dx,\n          _ref2$dy = _ref2.dy,\n          dy = _ref2$dy === undefined ? 0 : _ref2$dy;\n\n      var _getPosition = this.getPosition(),\n          _getPosition$scrollLe = _getPosition.scrollLeft,\n          scrollLeft = _getPosition$scrollLe === undefined ? 0 : _getPosition$scrollLe,\n          _getPosition$scrollTo = _getPosition.scrollTop,\n          scrollTop = _getPosition$scrollTo === undefined ? 0 : _getPosition$scrollTo;\n\n      if (dx) {\n        scrollLeft += getNumericValue(dx, this.scrollPanelElm.scrollWidth - this.$el.clientWidth);\n      }\n      if (dy) {\n        scrollTop += getNumericValue(dy, this.scrollPanelElm.scrollHeight - this.$el.clientHeight);\n      }\n      this.internalScrollTo(scrollLeft, scrollTop, speed, easing);\n    },\n    scrollIntoView: function scrollIntoView(elm) {\n      var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var parentElm = this.$el;\n\n      if (typeof elm === 'string') {\n        elm = parentElm.querySelector(elm);\n      }\n\n      if (!isChildInParent(elm, parentElm)) {\n        warn('The element or selector you passed is not the element of Vuescroll, please pass the element that is in Vuescroll to scrollIntoView API. ');\n        return;\n      }\n\n      // parent elm left, top\n\n      var _$el$getBoundingClien = this.$el.getBoundingClientRect(),\n          left = _$el$getBoundingClien.left,\n          top = _$el$getBoundingClien.top;\n      // child elm left, top\n\n\n      var _elm$getBoundingClien = elm.getBoundingClientRect(),\n          childLeft = _elm$getBoundingClien.left,\n          childTop = _elm$getBoundingClien.top;\n\n      var diffX = left - childLeft;\n      var diffY = top - childTop;\n\n      this.scrollBy({\n        dx: -diffX,\n        dy: -diffY\n      }, animate);\n    },\n    refresh: function refresh() {\n      this.refreshInternalStatus();\n      // refresh again to keep status is correct\n      this.$nextTick(this.refreshInternalStatus);\n    }\n  }\n};\n\n/** Public Api */\n\n/**\n * Refresh all\n */\nvar vsInstances = {};\nfunction refreshAll() {\n  for (var vs in vsInstances) {\n    vsInstances[vs].refresh();\n  }\n}\n\nvar baseConfig = {\n  // vuescroll\n  vuescroll: {\n    // vuescroll's size(height/width) should be a percent(100%)\n    // or be a number that is equal to its parentNode's width or\n    // height ?\n    sizeStrategy: 'percent',\n    /** Whether to detect dom resize or not */\n    detectResize: true,\n    /** Enable locking to the main axis if user moves only slightly on one of them at start */\n    locking: true\n  },\n  scrollPanel: {\n    // when component mounted.. it will automatically scrolls.\n    initialScrollY: false,\n    initialScrollX: false,\n    // feat: #11\n    scrollingX: true,\n    scrollingY: true,\n    speed: 300,\n    easing: undefined,\n    // Sometimes, the nativebar maybe on the left,\n    // See https://github.com/YvesCoding/vuescroll/issues/64\n    verticalNativeBarPos: 'right',\n    maxHeight: undefined,\n    maxWidth: undefined\n  },\n\n  //\n  rail: {\n    background: '#01a99a',\n    opacity: 0,\n    border: 'none',\n    /** Rail's size(Height/Width) , default -> 6px */\n    size: '6px',\n    /** Specify rail's border-radius, or the border-radius of rail and bar will be equal to the rail's size. default -> false **/\n    specifyBorderRadius: false,\n    /** Rail the distance from the two ends of the X axis and Y axis. **/\n    gutterOfEnds: null,\n    /** Rail the distance from the side of container. **/\n    gutterOfSide: '2px',\n    /** Whether to keep rail show or not, default -> false, event content height is not enough */\n    keepShow: false\n  },\n  bar: {\n    /** How long to hide bar after mouseleave, default -> 500 */\n    showDelay: 500,\n    /** Specify bar's border-radius, or the border-radius of rail and bar will be equal to the rail's size. default -> false **/\n    specifyBorderRadius: false,\n    /** Whether to show bar on scrolling, default -> true */\n    onlyShowBarOnScroll: true,\n    /** Whether to keep show or not, default -> false */\n    keepShow: false,\n    /** Bar's background , default -> #00a650 */\n    background: 'rgb(3, 185, 118)',\n    /** Bar's opacity, default -> 1  */\n    opacity: 1,\n    /** bar's size(Height/Width) , default -> 6px */\n\n    size: '6px',\n    minSize: 0,\n    disable: false\n  },\n  scrollButton: {\n    enable: false,\n    background: 'rgb(3, 185, 118)',\n    opacity: 1,\n    step: 180,\n    mousedownStep: 30\n  }\n};\n/**\n * validate the options\n * @export\n * @param {any} ops\n */\nfunction validateOps(ops) {\n  var renderError = false;\n  var scrollPanel = ops.scrollPanel;\n  var _ops$bar = ops.bar,\n      vBar = _ops$bar.vBar,\n      hBar = _ops$bar.hBar;\n  var _ops$rail = ops.rail,\n      vRail = _ops$rail.vRail,\n      hRail = _ops$rail.hRail;\n\n  // validate scrollPanel\n\n  var initialScrollY = scrollPanel['initialScrollY'];\n  var initialScrollX = scrollPanel['initialScrollX'];\n\n  if (initialScrollY && !String(initialScrollY).match(/^\\d+(\\.\\d+)?(%)?$/)) {\n    warn('The prop `initialScrollY` or `initialScrollX` should be a percent number like `10%` or an exact number that greater than or equal to 0 like `100`.');\n  }\n  if (initialScrollX && !String(initialScrollX).match(/^\\d+(\\.\\d+)?(%)?$/)) {\n    warn('The prop `initialScrollY` or `initialScrollX` should be a percent number like `10%` or an exact number that greater than or equal to 0 like `100`.');\n  }\n\n  // validate deprecated vBar/hBar vRail/hRail\n  if (vBar || hBar || vRail || hRail) {\n    warn('The options: vRail, hRail, vBar, hBar have been deprecated since v4.7.0,' + 'please use corresponing rail/bar instead!');\n  }\n\n  if (_extraValidate) {\n    _extraValidate = [].concat(_extraValidate);\n    _extraValidate.forEach(function (hasError) {\n      if (hasError(ops)) {\n        renderError = true;\n      }\n    });\n  }\n  return renderError;\n}\n\nvar _extraValidate = null;\nvar extendOpts = function extendOpts(extraOpts, extraValidate) {\n  extraOpts = [].concat(extraOpts);\n  extraOpts.forEach(function (opts) {\n    mergeObject(opts, baseConfig);\n  });\n\n  _extraValidate = extraValidate;\n};\n\n// all modes\n\n// do nothing\n\n// some small changes.\nvar smallChangeArray = ['mergedOptions.vuescroll.pullRefresh.tips', 'mergedOptions.vuescroll.pushLoad.tips', 'mergedOptions.vuescroll.scroller.disable', 'mergedOptions.rail', 'mergedOptions.bar'];\n// refresh/load dom ref/key...\n\nvar scrollMap = {\n  vertical: {\n    size: 'height',\n    opsSize: 'width',\n    posName: 'top',\n    opposName: 'bottom',\n    sidePosName: 'right',\n    page: 'pageY',\n    scroll: 'scrollTop',\n    scrollSize: 'scrollHeight',\n    offset: 'offsetHeight',\n    client: 'clientY',\n    axis: 'Y',\n    scrollButton: {\n      start: 'top',\n      end: 'bottom'\n    }\n  },\n  horizontal: {\n    size: 'width',\n    opsSize: 'height',\n    posName: 'left',\n    opposName: 'right',\n    sidePosName: 'bottom',\n    page: 'pageX',\n    scroll: 'scrollLeft',\n    scrollSize: 'scrollWidth',\n    offset: 'offsetWidth',\n    client: 'clientX',\n    axis: 'X',\n    scrollButton: {\n      start: 'left',\n      end: 'right'\n    }\n  }\n};\n\nfunction requestAnimationFrame(global) {\n  // Check for request animation Frame support\n  var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;\n  var isNative = !!requestFrame;\n\n  if (requestFrame && !/requestAnimationFrame\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}/i.test(requestFrame.toString())) {\n    isNative = false;\n  }\n\n  if (isNative) {\n    return function (callback, root) {\n      requestFrame(callback, root);\n    };\n  }\n\n  var TARGET_FPS = 60;\n  var requests = {};\n  var rafHandle = 1;\n  var intervalHandle = null;\n  var lastActive = +new Date();\n\n  return function (callback) {\n    var callbackHandle = rafHandle++;\n\n    // Store callback\n    requests[callbackHandle] = callback;\n\n    // Create timeout at first request\n    if (intervalHandle === null) {\n      intervalHandle = setInterval(function () {\n        var time = +new Date();\n        var currentRequests = requests;\n\n        // Reset data structure before executing callbacks\n        requests = {};\n\n        for (var key in currentRequests) {\n          if (currentRequests.hasOwnProperty(key)) {\n            currentRequests[key](time);\n            lastActive = time;\n          }\n        }\n\n        // Disable the timeout when nothing happens for a certain\n        // period of time\n        if (time - lastActive > 2500) {\n          clearInterval(intervalHandle);\n          intervalHandle = null;\n        }\n      }, 1000 / TARGET_FPS);\n    }\n\n    return callbackHandle;\n  };\n}\n\nvar colorCache = {};\nvar rgbReg = /rgb\\(/;\nvar extractRgbColor = /rgb\\((.*)\\)/;\n\n// Transform a common color int oa `rgbA` color\nfunction getRgbAColor(color, opacity) {\n  var id = color + '&' + opacity;\n  if (colorCache[id]) {\n    return colorCache[id];\n  }\n\n  var div = document.createElement('div');\n  div.style.background = color;\n  document.body.appendChild(div);\n  var computedColor = window.getComputedStyle(div).backgroundColor;\n  document.body.removeChild(div);\n\n  /* istanbul ignore if */\n  if (!rgbReg.test(computedColor)) {\n    return color;\n  }\n\n  return colorCache[id] = 'rgba(' + extractRgbColor.exec(computedColor)[1] + ', ' + opacity + ')';\n}\n\nvar bar = {\n  name: 'bar',\n  props: {\n    ops: Object,\n    state: Object,\n    hideBar: Boolean,\n    otherBarHide: Boolean,\n    type: String\n  },\n  computed: {\n    bar: function bar() {\n      return scrollMap[this.type];\n    },\n    barSize: function barSize() {\n      return Math.max(this.state.size, this.ops.bar.minSize);\n    },\n    barRatio: function barRatio() {\n      return (1 - this.barSize) / (1 - this.state.size);\n    }\n  },\n  render: function render(h) {\n    var _style, _style2, _barStyle;\n\n    var vm = this;\n    /** Get rgbA format background color */\n    var railBackgroundColor = getRgbAColor(vm.ops.rail.background, vm.ops.rail.opacity);\n\n    if (!this.touchManager) {\n      this.touchManager = new touchManager();\n    }\n\n    /** Rail Data */\n    var railSize = vm.ops.rail.size;\n    var endPos = vm.otherBarHide ? 0 : railSize;\n    var touchObj = vm.touchManager.getTouchObject();\n    var rail = {\n      class: '__rail-is-' + vm.type,\n      style: (_style = {\n        position: 'absolute',\n        'z-index': '1',\n\n        borderRadius: vm.ops.rail.specifyBorderRadius || railSize,\n        background: railBackgroundColor,\n        border: vm.ops.rail.border\n      }, defineProperty(_style, vm.bar.opsSize, railSize), defineProperty(_style, vm.bar.posName, vm.ops.rail['gutterOfEnds'] || 0), defineProperty(_style, vm.bar.opposName, vm.ops.rail['gutterOfEnds'] || endPos), defineProperty(_style, vm.bar.sidePosName, vm.ops.rail['gutterOfSide']), _style)\n    };\n\n    if (touchObj) {\n      var _rail$on;\n\n      rail.on = (_rail$on = {}, defineProperty(_rail$on, touchObj.touchenter, function () {\n        vm.setRailHover();\n      }), defineProperty(_rail$on, touchObj.touchleave, function () {\n        vm.setRailLeave();\n      }), _rail$on);\n    }\n\n    // left space for scroll button\n    var buttonSize = vm.ops.scrollButton.enable ? railSize : 0;\n    var barWrapper = {\n      class: '__bar-wrap-is-' + vm.type,\n      style: (_style2 = {\n        position: 'absolute',\n        borderRadius: vm.ops.rail.specifyBorderRadius || railSize\n      }, defineProperty(_style2, vm.bar.posName, buttonSize), defineProperty(_style2, vm.bar.opposName, buttonSize), _style2),\n      on: {}\n    };\n\n    var scrollDistance = vm.state.posValue * vm.state.size;\n    var pos = scrollDistance * vm.barRatio / vm.barSize;\n    var opacity = vm.state.opacity;\n    var parent = getRealParent(this);\n\n    // set class hook\n    parent.setClassHook(this.type == 'vertical' ? 'vBarVisible' : 'hBarVisible', !!opacity);\n\n    /** Scrollbar style */\n    var barStyle = (_barStyle = {\n      cursor: 'pointer',\n      position: 'absolute',\n      margin: 'auto',\n      transition: 'opacity 0.5s',\n      'user-select': 'none',\n      'border-radius': 'inherit'\n\n    }, defineProperty(_barStyle, vm.bar.size, vm.barSize * 100 + '%'), defineProperty(_barStyle, 'background', vm.ops.bar.background), defineProperty(_barStyle, vm.bar.opsSize, vm.ops.bar.size), defineProperty(_barStyle, 'opacity', opacity), defineProperty(_barStyle, 'transform', 'translate' + scrollMap[vm.type].axis + '(' + pos + '%)'), _barStyle);\n    var bar = {\n      style: barStyle,\n      class: '__bar-is-' + vm.type,\n      ref: 'thumb',\n      on: {}\n    };\n\n    if (vm.type == 'vertical') {\n      barWrapper.style.width = '100%';\n      // Let bar to be on the center.\n      bar.style.left = 0;\n      bar.style.right = 0;\n    } else {\n      barWrapper.style.height = '100%';\n      bar.style.top = 0;\n      bar.style.bottom = 0;\n    }\n\n    /* istanbul ignore next */\n    {\n      var _touchObj = this.touchManager.getTouchObject();\n      bar.on[_touchObj.touchstart] = this.createBarEvent();\n      barWrapper.on[_touchObj.touchstart] = this.createTrackEvent();\n    }\n\n    return h(\n      'div',\n      rail,\n      [this.createScrollbarButton(h, 'start'), this.hideBar ? null : h(\n        'div',\n        barWrapper,\n        [h('div', bar)]\n      ), this.createScrollbarButton(h, 'end')]\n    );\n  },\n  data: function data() {\n    return {\n      isBarDragging: false\n    };\n  },\n\n  methods: {\n    setRailHover: function setRailHover() {\n      var parent = getRealParent(this);\n      var state = parent.vuescroll.state;\n\n      if (!state.isRailHover) {\n        state.isRailHover = true;\n        parent.showBar();\n      }\n    },\n    setRailLeave: function setRailLeave() {\n      var parent = getRealParent(this);\n      var state = parent.vuescroll.state;\n\n      state.isRailHover = false;\n      parent.hideBar();\n    },\n    setBarDrag: function setBarDrag(val) /* istanbul ignore next */{\n      this.$emit('setBarDrag', this.isBarDragging = val);\n\n      var parent = getRealParent(this);\n      // set class hook\n      parent.setClassHook(this.type == 'vertical' ? 'vBarDragging' : 'hBarDragging', !!val);\n    },\n    createBarEvent: function createBarEvent() {\n      var ctx = this;\n\n      var parent = getRealParent(ctx);\n      var touchObj = ctx.touchManager.getTouchObject();\n\n      function mousedown(e) /* istanbul ignore next */{\n        var event = ctx.touchManager.getEventObject(e);\n        if (!event) return;\n\n        e.stopImmediatePropagation();\n        e.preventDefault();\n        event = event[0];\n\n        document.onselectstart = function () {\n          return false;\n        };\n        ctx.axisStartPos = event[ctx.bar.client] - ctx.$refs['thumb'].getBoundingClientRect()[ctx.bar.posName];\n\n        // Tell parent that the mouse has been down.\n        ctx.setBarDrag(true);\n        eventCenter(document, touchObj.touchmove, mousemove);\n        eventCenter(document, touchObj.touchend, mouseup);\n      }\n\n      function mousemove(e) /* istanbul ignore next */{\n        if (!ctx.axisStartPos) {\n          return;\n        }\n\n        var event = ctx.touchManager.getEventObject(e);\n        if (!event) return;\n\n        event = event[0];\n\n        var thubmParent = ctx.$refs.thumb.parentNode;\n\n        var delta = event[ctx.bar.client] - thubmParent.getBoundingClientRect()[ctx.bar.posName];\n        delta = delta / ctx.barRatio;\n\n        var percent = (delta - ctx.axisStartPos) / thubmParent[ctx.bar.offset];\n        parent.scrollTo(defineProperty({}, ctx.bar.axis.toLowerCase(), parent.scrollPanelElm[ctx.bar.scrollSize] * percent), false);\n      }\n\n      function mouseup() /* istanbul ignore next */{\n        ctx.setBarDrag(false);\n        parent.hideBar();\n\n        document.onselectstart = null;\n        ctx.axisStartPos = 0;\n\n        eventCenter(document, touchObj.touchmove, mousemove, false, 'off');\n        eventCenter(document, touchObj.touchend, mouseup, false, 'off');\n      }\n\n      return mousedown;\n    },\n    createTrackEvent: function createTrackEvent() {\n      var ctx = this;\n\n      return function handleClickTrack(e) {\n        var parent = getRealParent(ctx);\n\n        var _ctx$bar = ctx.bar,\n            client = _ctx$bar.client,\n            offset = _ctx$bar.offset,\n            posName = _ctx$bar.posName,\n            axis = _ctx$bar.axis;\n\n        var thumb = ctx.$refs['thumb'];\n\n        e.preventDefault();\n        e.stopImmediatePropagation();\n\n        /* istanbul ignore if */\n        if (!thumb) return;\n\n        var barOffset = thumb[offset];\n        var event = ctx.touchManager.getEventObject(e)[0];\n\n        var percent = (event[client] - e.currentTarget.getBoundingClientRect()[posName] - barOffset / 2) / (e.currentTarget[offset] - barOffset);\n\n        parent.scrollTo(defineProperty({}, axis.toLowerCase(), percent * 100 + '%'));\n      };\n    },\n\n\n    // Scrollbuton relative things...\n    createScrollbarButton: function createScrollbarButton(h, type /* start or end  */) {\n      var _style3;\n\n      var barContext = this;\n\n      if (!barContext.ops.scrollButton.enable) {\n        return null;\n      }\n\n      var size = barContext.ops.rail.size;\n      var _barContext$ops$scrol = barContext.ops.scrollButton,\n          opacity = _barContext$ops$scrol.opacity,\n          background = _barContext$ops$scrol.background;\n\n      var borderColor = getRgbAColor(background, opacity);\n\n      var wrapperProps = {\n        class: ['__bar-button', '__bar-button-is-' + barContext.type + '-' + type],\n        style: (_style3 = {}, defineProperty(_style3, barContext.bar.scrollButton[type], 0), defineProperty(_style3, 'width', size), defineProperty(_style3, 'height', size), defineProperty(_style3, 'position', 'absolute'), defineProperty(_style3, 'cursor', 'pointer'), defineProperty(_style3, 'display', 'table'), _style3),\n        ref: type\n      };\n\n      var innerProps = {\n        class: '__bar-button-inner',\n        style: {\n          border: 'calc(' + size + ' / 2.5) solid transparent',\n          width: '0',\n          height: '0',\n          margin: 'auto',\n          position: 'absolute',\n          top: '0',\n          bottom: '0',\n          right: '0',\n          left: '0'\n        },\n        on: {}\n      };\n\n      if (barContext.type == 'vertical') {\n        if (type == 'start') {\n          innerProps.style['border-bottom-color'] = borderColor;\n          innerProps.style['transform'] = 'translateY(-25%)';\n        } else {\n          innerProps.style['border-top-color'] = borderColor;\n          innerProps.style['transform'] = 'translateY(25%)';\n        }\n      } else {\n        if (type == 'start') {\n          innerProps.style['border-right-color'] = borderColor;\n          innerProps.style['transform'] = 'translateX(-25%)';\n        } else {\n          innerProps.style['border-left-color'] = borderColor;\n          innerProps.style['transform'] = 'translateX(25%)';\n        }\n      }\n\n      /* istanbul ignore next */\n      {\n        var touchObj = this.touchManager.getTouchObject();\n        innerProps.on[touchObj.touchstart] = this.createScrollButtonEvent(type, touchObj);\n      }\n\n      return h(\n        'div',\n        wrapperProps,\n        [h('div', innerProps)]\n      );\n    },\n    createScrollButtonEvent: function createScrollButtonEvent(type, touchObj) {\n      var ctx = this;\n      var parent = getRealParent(ctx);\n\n      var _ctx$ops$scrollButton = ctx.ops.scrollButton,\n          step = _ctx$ops$scrollButton.step,\n          mousedownStep = _ctx$ops$scrollButton.mousedownStep;\n\n\n      var stepWithDirection = type == 'start' ? -step : step;\n      var mousedownStepWithDirection = type == 'start' ? -mousedownStep : mousedownStep;\n      var ref = requestAnimationFrame(window);\n\n      // bar props: type\n      var barType = ctx.type;\n\n      var isMouseDown = false;\n      var isMouseout = true;\n      var timeoutId = void 0;\n\n      function start(e) {\n        /* istanbul ignore if */\n\n        if (3 == e.which) {\n          return;\n        }\n\n        // set class hook\n        parent.setClassHook('cliking' + barType + type + 'Button', true);\n\n        e.stopImmediatePropagation();\n        e.preventDefault();\n\n        isMouseout = false;\n\n        parent.scrollBy(defineProperty({}, 'd' + ctx.bar.axis.toLowerCase(), stepWithDirection));\n\n        eventCenter(document, touchObj.touchend, endPress, false);\n\n        if (touchObj.touchstart == 'mousedown') {\n          var elm = ctx.$refs[type];\n          eventCenter(elm, 'mouseenter', enter, false);\n          eventCenter(elm, 'mouseleave', leave, false);\n        }\n\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(function () /* istanbul ignore next */{\n          isMouseDown = true;\n          ref(pressing, window);\n        }, 500);\n      }\n\n      function pressing() /* istanbul ignore next */{\n        if (isMouseDown && !isMouseout) {\n          parent.scrollBy(defineProperty({}, 'd' + ctx.bar.axis.toLowerCase(), mousedownStepWithDirection), false);\n          ref(pressing, window);\n        }\n      }\n\n      function endPress() {\n        clearTimeout(timeoutId);\n        isMouseDown = false;\n        eventCenter(document, touchObj.touchend, endPress, false, 'off');\n\n        if (touchObj.touchstart == 'mousedown') {\n          var elm = ctx.$refs[type];\n          eventCenter(elm, 'mouseenter', enter, false, 'off');\n          eventCenter(elm, 'mouseleave', leave, false, 'off');\n        }\n\n        parent.setClassHook('cliking' + barType + type + 'Button', false);\n      }\n\n      function enter() /* istanbul ignore next */{\n        isMouseout = false;\n        pressing();\n      }\n\n      function leave() /* istanbul ignore next */{\n        isMouseout = true;\n      }\n\n      return start;\n    }\n  }\n};\n\nfunction getBarData(vm, type) {\n  var axis = scrollMap[type].axis;\n  /** type.charAt(0) = vBar/hBar */\n  var barType = type.charAt(0) + 'Bar';\n\n  var hideBar = !vm.bar[barType].state.size || !vm.mergedOptions.scrollPanel['scrolling' + axis] || vm.refreshLoad && type !== 'vertical' || vm.mergedOptions.bar.disable;\n\n  var keepShowRail = vm.mergedOptions.rail.keepShow;\n\n  if (hideBar && !keepShowRail) {\n    return null;\n  }\n\n  return {\n    hideBar: hideBar,\n    props: {\n      type: type,\n      ops: {\n        bar: vm.mergedOptions.bar,\n        rail: vm.mergedOptions.rail,\n        scrollButton: vm.mergedOptions.scrollButton\n      },\n      state: vm.bar[barType].state,\n      hideBar: hideBar\n    },\n    on: {\n      setBarDrag: vm.setBarDrag\n    },\n    ref: type + 'Bar',\n    key: type\n  };\n}\n\n/**\n * create bars\n *\n * @param {any} size\n * @param {any} type\n */\nfunction createBar(h, vm) {\n  var verticalBarProps = getBarData(vm, 'vertical');\n  var horizontalBarProps = getBarData(vm, 'horizontal');\n\n  // set class hooks\n  vm.setClassHook('hasVBar', !!(verticalBarProps && !verticalBarProps.hideBar));\n  vm.setClassHook('hasHBar', !!(horizontalBarProps && !horizontalBarProps.hideBar));\n\n  return [verticalBarProps ? h('bar', _extends({}, verticalBarProps, {\n    props: _extends({ otherBarHide: !horizontalBarProps }, verticalBarProps.props)\n  })) : null, horizontalBarProps ? h('bar', _extends({}, horizontalBarProps, {\n    props: _extends({ otherBarHide: !verticalBarProps }, horizontalBarProps.props)\n  })) : null];\n}\n\n/**\n * This is like a HOC, It extracts the common parts of the\n * native-mode, slide-mode and mix-mode.\n * Each mode must implement the following methods:\n * 1. refreshInternalStatus : use to refresh the component\n * 2. destroy : Destroy some registryed events before component destroy.\n * 3. updateBarStateAndEmitEvent: use to update bar states and emit events.\n */\n\nvar createComponent = function createComponent(_ref) {\n  var _render = _ref.render,\n      components = _ref.components,\n      mixins = _ref.mixins;\n  return {\n    name: 'vueScroll',\n    props: {\n      ops: { type: Object }\n    },\n    components: components,\n    mixins: [api].concat(toConsumableArray([].concat(mixins))),\n    created: function created() {\n      var _this = this;\n\n      /**\n       * Begin to merge options\n       */\n\n      var _gfc = mergeObject(this.$vuescrollConfig || {}, {});\n      var ops = mergeObject(baseConfig, _gfc);\n\n      this.$options.propsData.ops = this.$options.propsData.ops || {};\n      Object.keys(this.$options.propsData.ops).forEach(function (key) {\n        {\n          defineReactive(_this.mergedOptions, key, _this.$options.propsData.ops);\n        }\n      });\n      // from ops to mergedOptions\n      mergeObject(ops, this.mergedOptions);\n\n      this._isVuescrollRoot = true;\n      this.renderError = validateOps(this.mergedOptions);\n    },\n    render: function render(h) {\n      var vm = this;\n      if (vm.renderError) {\n        return h('div', [[vm.$slots['default']]]);\n      }\n\n      if (!vm.touchManager) vm.touchManager = new touchManager();\n\n      // vuescroll data\n      var data = {\n        style: {\n          height: vm.vuescroll.state.height,\n          width: vm.vuescroll.state.width,\n          padding: 0,\n          position: 'relative',\n          overflow: 'hidden'\n        },\n        class: _extends({ __vuescroll: true }, vm.classHooks)\n      };\n\n      var touchObj = vm.touchManager.getTouchObject();\n      if (touchObj) {\n        var _data$on;\n\n        data.on = (_data$on = {}, defineProperty(_data$on, touchObj.touchenter, function () {\n          vm.vuescroll.state.pointerLeave = false;\n          vm.updateBarStateAndEmitEvent();\n\n          vm.setClassHook('mouseEnter', true);\n        }), defineProperty(_data$on, touchObj.touchleave, function () {\n          vm.vuescroll.state.pointerLeave = true;\n          vm.hideBar();\n\n          vm.setClassHook('mouseEnter', false);\n        }), defineProperty(_data$on, touchObj.touchmove, function () /* istanbul ignore next */{\n          vm.vuescroll.state.pointerLeave = false;\n          vm.updateBarStateAndEmitEvent();\n        }), _data$on);\n      }\n\n      var ch = [_render(h, vm)].concat(toConsumableArray(createBar(h, vm)));\n\n      var _customContainer = this.$slots['scroll-container'];\n      if (_customContainer) {\n        return insertChildrenIntoSlot(h, _customContainer, ch, data);\n      }\n\n      return h(\n        'div',\n        data,\n        [ch]\n      );\n    },\n    mounted: function mounted() {\n      var _this2 = this;\n\n      if (!this.renderError) {\n        this.initVariables();\n        this.initWatchOpsChange();\n        // Call external merged Api\n        this.refreshInternalStatus();\n\n        this.updatedCbs.push(function () {\n          _this2.scrollToAnchor();\n          // need to reflow to deal with the\n          // latest thing.\n          _this2.updateBarStateAndEmitEvent();\n        });\n      }\n    },\n    updated: function updated() {\n      var _this3 = this;\n\n      this.updatedCbs.forEach(function (cb) {\n        cb.call(_this3);\n      });\n      // Clear\n      this.updatedCbs = [];\n    },\n    beforeDestroy: function beforeDestroy() {\n      if (this.destroy) {\n        this.destroy();\n      }\n    },\n\n\n    /** ------------------------------- Computed ----------------------------- */\n    computed: {\n      scrollPanelElm: function scrollPanelElm() {\n        return this.$refs['scrollPanel']._isVue ? this.$refs['scrollPanel'].$el : this.$refs['scrollPanel'];\n      }\n    },\n    data: function data() {\n      return {\n        vuescroll: {\n          state: {\n            isDragging: false,\n            pointerLeave: true,\n            isRailHover: false,\n            /** Default sizeStrategies */\n            height: '100%',\n            width: '100%',\n            // current size strategy\n            currentSizeStrategy: 'percent',\n            currentScrollState: null,\n            currentScrollInfo: null\n          }\n        },\n        bar: {\n          vBar: {\n            state: {\n              posValue: 0,\n              size: 0,\n              opacity: 0\n            }\n          },\n          hBar: {\n            state: {\n              posValue: 0,\n              size: 0,\n              opacity: 0\n            }\n          }\n        },\n        mergedOptions: {\n          vuescroll: {},\n          scrollPanel: {},\n          scrollContent: {},\n          rail: {},\n          bar: {}\n        },\n        updatedCbs: [],\n        renderError: false,\n\n        classHooks: {\n          hasVBar: false,\n          hasHBar: false,\n\n          vBarVisible: false,\n          hBarVisible: false,\n\n          vBarDragging: false,\n          hBarDragging: false,\n\n          clikingVerticalStartButton: false,\n          clikingVerticalEndButton: false,\n          clikingHorizontalStartButton: false,\n          clikingHorizontalEndButton: false,\n\n          mouseEnter: false\n        }\n      };\n    },\n\n    /** ------------------------------- Methods -------------------------------- */\n    methods: {\n      /** ------------------------ Handlers --------------------------- */\n\n      scrollingComplete: function scrollingComplete() {\n        this.updateBarStateAndEmitEvent('handle-scroll-complete');\n      },\n      setBarDrag: function setBarDrag(val) {\n        /* istanbul ignore next */\n        this.vuescroll.state.isDragging = val;\n      },\n      setClassHook: function setClassHook(name, value) {\n        this.classHooks[name] = value;\n      },\n\n\n      /** ------------------------ Some Helpers --------------------------- */\n\n      /*\n       * To have a good ux, instead of hiding bar immediately, we hide bar\n       * after some seconds by using this simple debounce-hidebar method.\n       */\n      showAndDefferedHideBar: function showAndDefferedHideBar(forceHideBar) {\n        var _this4 = this;\n\n        this.showBar();\n\n        if (this.timeoutId) {\n          clearTimeout(this.timeoutId);\n          this.timeoutId = 0;\n        }\n\n        this.timeoutId = setTimeout(function () {\n          _this4.timeoutId = 0;\n          _this4.hideBar(forceHideBar);\n        }, this.mergedOptions.bar.showDelay);\n      },\n      showBar: function showBar() {\n        var opacity = this.mergedOptions.bar.opacity;\n        this.bar.vBar.state.opacity = opacity;\n        this.bar.hBar.state.opacity = opacity;\n      },\n      hideBar: function hideBar(forceHideBar) {\n        var _vuescroll$state = this.vuescroll.state,\n            isDragging = _vuescroll$state.isDragging,\n            isRailHover = _vuescroll$state.isRailHover;\n        /* istanbul ignore next */\n\n        if (isDragging || isRailHover) {\n          return;\n        }\n\n        if (forceHideBar && !this.mergedOptions.bar.keepShow) {\n          this.bar.hBar.state.opacity = 0;\n          this.bar.vBar.state.opacity = 0;\n        }\n\n        // add isDragging condition\n        // to prevent from hiding bar while dragging the bar\n        if (!this.mergedOptions.bar.keepShow && !this.vuescroll.state.isDragging) {\n          this.bar.vBar.state.opacity = 0;\n          this.bar.hBar.state.opacity = 0;\n        }\n      },\n      useNumbericSize: function useNumbericSize() {\n        this.vuescroll.state.currentSizeStrategy = 'number';\n        var _mergedOptions$scroll = this.mergedOptions.scrollPanel,\n            maxHeight = _mergedOptions$scroll.maxHeight,\n            maxWidth = _mergedOptions$scroll.maxWidth;\n        var _$el$parentNode = this.$el.parentNode,\n            parentClientHeight = _$el$parentNode.clientHeight,\n            parentClientWidth = _$el$parentNode.clientWidth;\n        var _scrollPanelElm = this.scrollPanelElm,\n            scrollHeight = _scrollPanelElm.scrollHeight,\n            scrollWidth = _scrollPanelElm.scrollWidth;\n\n        var width = void 0;\n        var height = void 0;\n\n        if (maxHeight || maxWidth) {\n          height = scrollHeight <= maxHeight ? undefined : maxHeight;\n          width = scrollWidth <= maxWidth ? undefined : maxWidth;\n        } else {\n          height = parentClientHeight;\n          width = parentClientWidth;\n        }\n\n        this.vuescroll.state.height = height ? height + 'px' : undefined;\n        this.vuescroll.state.width = width ? width + 'px' : undefined;\n      },\n      usePercentSize: function usePercentSize() {\n        this.vuescroll.state.currentSizeStrategy = 'percent';\n\n        this.vuescroll.state.height = '100%';\n        this.vuescroll.state.width = '100%';\n      },\n\n      // Set its size to be equal to its parentNode\n      setVsSize: function setVsSize() {\n        var sizeStrategy = this.mergedOptions.vuescroll.sizeStrategy;\n        var _mergedOptions$scroll2 = this.mergedOptions.scrollPanel,\n            maxHeight = _mergedOptions$scroll2.maxHeight,\n            maxWidth = _mergedOptions$scroll2.maxWidth;\n        var _scrollPanelElm2 = this.scrollPanelElm,\n            clientHeight = _scrollPanelElm2.clientHeight,\n            clientWidth = _scrollPanelElm2.clientWidth;\n\n        if (sizeStrategy == 'number' || maxHeight && clientHeight > maxHeight || maxWidth && clientWidth > maxWidth) {\n          this.useNumbericSize();\n        } else if (sizeStrategy == 'percent' && clientHeight != maxHeight && clientWidth != maxWidth) {\n          this.usePercentSize();\n        }\n      },\n\n\n      /** ------------------------ Init --------------------------- */\n      initWatchOpsChange: function initWatchOpsChange() {\n        var _this5 = this;\n\n        var watchOpts = {\n          deep: true,\n          sync: true\n        };\n        this.$watch('mergedOptions', function () {\n          setTimeout(function () {\n            if (_this5.isSmallChangeThisTick) {\n              _this5.isSmallChangeThisTick = false;\n              _this5.updateBarStateAndEmitEvent('options-change');\n              return;\n            }\n            _this5.refreshInternalStatus();\n          }, 0);\n        }, watchOpts);\n\n        /**\n         * We also watch `small` changes, and when small changes happen, we send\n         * a signal to vuescroll, to tell it:\n         * 1. we don't need to registry resize\n         * 2. we don't need to registry scroller.\n         */\n        smallChangeArray.forEach(function (opts) {\n          _this5.$watch(opts, function () {\n            _this5.isSmallChangeThisTick = true;\n          }, watchOpts);\n        });\n      },\n\n      // scrollTo hash-anchor while mounted component have mounted.\n      scrollToAnchor: function scrollToAnchor() /* istanbul ignore next */{\n        var validateHashSelector = function validateHashSelector(hash) {\n          return (/^#[a-zA-Z_]\\d*$/.test(hash)\n          );\n        };\n\n        var hash = window.location.hash;\n        if (!hash || (hash = hash.slice(hash.lastIndexOf('#'))) && !validateHashSelector(hash)) {\n          return;\n        }\n\n        var elm = document.querySelector(hash);\n        if (!isChildInParent(elm, this.$el) || this.mergedOptions.scrollPanel.initialScrollY || this.mergedOptions.scrollPanel.initialScrollX) {\n          return;\n        }\n\n        this.scrollIntoView(elm);\n      }\n\n      /** ------------------------ Registry Resize --------------------------- */\n\n    }\n  };\n};\n\n// begin importing\nvar scrollPanel = {\n  name: 'scrollPanel',\n  props: { ops: { type: Object, required: true } },\n  methods: {\n    // trigger scrollPanel options initialScrollX,\n    // initialScrollY\n    updateInitialScroll: function updateInitialScroll() {\n      var x = 0;\n      var y = 0;\n\n      var parent = getRealParent(this);\n\n      if (this.ops.initialScrollX) {\n        x = this.ops.initialScrollX;\n      }\n      if (this.ops.initialScrollY) {\n        y = this.ops.initialScrollY;\n      }\n      if (x || y) {\n        parent.scrollTo({ x: x, y: y });\n      }\n    }\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    setTimeout(function () {\n      if (!_this._isDestroyed) {\n        _this.updateInitialScroll();\n      }\n    }, 0);\n  },\n  render: function render(h) {\n    // eslint-disable-line\n    var data = {\n      class: ['__panel'],\n      style: {\n        position: 'relative',\n        boxSizing: 'border-box'\n      }\n    };\n\n    var parent = getRealParent(this);\n\n    var _customPanel = parent.$slots['scroll-panel'];\n    if (_customPanel) {\n      return insertChildrenIntoSlot(h, _customPanel, this.$slots.default, data);\n    }\n\n    return h(\n      'div',\n      data,\n      [[this.$slots.default]]\n    );\n  }\n};\n\n/**\n * Init following things\n * 1. Component\n * 2. Render\n * 3. Config\n */\nfunction _install(core, render) {\n  var _components;\n\n  var extraConfigs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var extraValidators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n  var components = (_components = {}, defineProperty(_components, scrollPanel.name, scrollPanel), defineProperty(_components, bar.name, bar), _components);\n\n  var opts = {};\n  opts.components = components;\n  opts.render = render;\n  opts.mixins = core;\n\n  var comp = createComponent(opts);\n\n  // Init Config\n  extendOpts(extraConfigs, extraValidators);\n\n  return comp;\n}\n\n/**\n * Get the children of parent those are in viewport\n */\nfunction getCurrentViewportDom(parent, container) {\n  var children = parent.children;\n  var domFragment = [];\n\n  var isCurrentview = function isCurrentview(dom) {\n    var _dom$getBoundingClien = dom.getBoundingClientRect(),\n        left = _dom$getBoundingClien.left,\n        top = _dom$getBoundingClien.top,\n        width = _dom$getBoundingClien.width,\n        height = _dom$getBoundingClien.height;\n\n    var _container$getBoundin = container.getBoundingClientRect(),\n        parentLeft = _container$getBoundin.left,\n        parentTop = _container$getBoundin.top,\n        parentHeight = _container$getBoundin.height,\n        parentWidth = _container$getBoundin.width;\n\n    if (left - parentLeft + width > 0 && left - parentLeft < parentWidth && top - parentTop + height > 0 && top - parentTop < parentHeight) {\n      return true;\n    }\n    return false;\n  };\n\n  for (var i = 0; i < children.length; i++) {\n    var dom = children.item(i);\n    if (isCurrentview(dom) && !dom.isResizeElm) {\n      domFragment.push(dom);\n    }\n  }\n  return domFragment;\n}\n\n/**\n *  Compatible to scroller's animation function\n */\nfunction createEasingFunction(easing, easingPattern) {\n  return function (time) {\n    return easingPattern(easing, time);\n  };\n}\n\n/**\n * Calculate the easing pattern\n * @link https://github.com/cferdinandi/smooth-scroll/blob/master/src/js/smooth-scroll.js\n * modified by wangyi7099\n * @param {String} type Easing pattern\n * @param {Number} time Time animation should take to complete\n * @returns {Number}\n */\nfunction easingPattern(easing, time) {\n  var pattern = null;\n  /* istanbul ignore next */\n  {\n    // Default Easing Patterns\n    if (easing === 'easeInQuad') pattern = time * time; // accelerating from zero velocity\n    if (easing === 'easeOutQuad') pattern = time * (2 - time); // decelerating to zero velocity\n    if (easing === 'easeInOutQuad') pattern = time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; // acceleration until halfway, then deceleration\n    if (easing === 'easeInCubic') pattern = time * time * time; // accelerating from zero velocity\n    if (easing === 'easeOutCubic') pattern = --time * time * time + 1; // decelerating to zero velocity\n    if (easing === 'easeInOutCubic') pattern = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1; // acceleration until halfway, then deceleration\n    if (easing === 'easeInQuart') pattern = time * time * time * time; // accelerating from zero velocity\n    if (easing === 'easeOutQuart') pattern = 1 - --time * time * time * time; // decelerating to zero velocity\n    if (easing === 'easeInOutQuart') pattern = time < 0.5 ? 8 * time * time * time * time : 1 - 8 * --time * time * time * time; // acceleration until halfway, then deceleration\n    if (easing === 'easeInQuint') pattern = time * time * time * time * time; // accelerating from zero velocity\n    if (easing === 'easeOutQuint') pattern = 1 + --time * time * time * time * time; // decelerating to zero velocity\n    if (easing === 'easeInOutQuint') pattern = time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * --time * time * time * time * time; // acceleration until halfway, then deceleration\n  }\n  return pattern || time; // no easing, no acceleration\n}\n\nfunction noop() {\n  return true;\n}\n\n/* istanbul ignore next */\nvar now = Date.now || function () {\n  return new Date().getTime();\n};\n\nvar ScrollControl = function () {\n  function ScrollControl() {\n    classCallCheck(this, ScrollControl);\n\n    this.init();\n\n    this.isRunning = false;\n  }\n\n  createClass(ScrollControl, [{\n    key: 'pause',\n    value: function pause() {\n      /* istanbul ignore if */\n      if (!this.isRunning) return;\n\n      this.isPaused = true;\n    }\n  }, {\n    key: 'stop',\n    value: function stop() {\n      this.isStopped = true;\n    }\n  }, {\n    key: 'continue',\n    value: function _continue() {\n      /* istanbul ignore if */\n      if (!this.isPaused) return;\n\n      this.isPaused = false;\n      this.ts = now() - this.percent * this.spd;\n      this.execScroll();\n    }\n  }, {\n    key: 'startScroll',\n    value: function startScroll(st, ed, spd) {\n      var stepCb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n      var completeCb = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : noop;\n      var vertifyCb = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : noop;\n      var easingMethod = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : noop;\n\n      var df = ed - st;\n      var dir = df > 0 ? -1 : 1;\n      var nt = now();\n\n      if (!this.isRunning) {\n        this.init();\n      }\n\n      if (dir != this.dir || nt - this.ts > 200) {\n        this.ts = nt;\n\n        this.dir = dir;\n        this.st = st;\n        this.ed = ed;\n        this.df = df;\n      } /* istanbul ignore next */else {\n          this.df += df;\n        }\n\n      this.spd = spd;\n\n      this.completeCb = completeCb;\n      this.vertifyCb = vertifyCb;\n      this.stepCb = stepCb;\n      this.easingMethod = easingMethod;\n\n      if (!this.isRunning) this.execScroll();\n    }\n  }, {\n    key: 'execScroll',\n    value: function execScroll() {\n      var _this = this;\n\n      if (!this.df) return;\n\n      var percent = this.percent || 0;\n      this.percent = 0;\n      this.isRunning = true;\n\n      var loop = function loop() {\n        /* istanbul ignore if */\n        if (!_this.isRunning || !_this.vertifyCb(percent) || _this.isStopped) {\n          _this.isRunning = false;\n          return;\n        }\n\n        percent = (now() - _this.ts) / _this.spd;\n\n        if (_this.isPaused) {\n          _this.percent = percent;\n          _this.isRunning = false;\n          return;\n        }\n\n        if (percent < 1) {\n          var value = _this.st + _this.df * _this.easingMethod(percent);\n          _this.stepCb(value);\n          _this.ref(loop);\n        } else {\n          // trigger complete\n          _this.stepCb(_this.st + _this.df);\n          _this.completeCb();\n\n          _this.isRunning = false;\n        }\n      };\n\n      this.ref(loop);\n    }\n  }, {\n    key: 'init',\n    value: function init() {\n      this.st = 0;\n      this.ed = 0;\n      this.df = 0;\n      this.spd = 0;\n      this.ts = 0;\n      this.dir = 0;\n      this.ref = requestAnimationFrame(window);\n\n      this.isPaused = false;\n      this.isStopped = false;\n    }\n  }]);\n  return ScrollControl;\n}();\n\nfunction scrollTo(elm, x, y) {\n  var speed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 300;\n  var easing = arguments[4];\n  var scrollingComplete = arguments[5];\n\n  var scrollLeft = void 0,\n      scrollTop = void 0,\n      scrollHeight = void 0,\n      scrollWidth = void 0,\n      clientWidth = void 0,\n      clientHeight = void 0;\n\n  var _elm = elm,\n      nodeType = _elm.nodeType;\n\n  var scrollX = new ScrollControl();\n  var scrollY = new ScrollControl();\n\n  if (!nodeType) {\n    warn('You must pass a dom for the first param, ' + 'for window scrolling, ' + 'you can pass document as the first param.');\n\n    return;\n  }\n\n  if (nodeType == 9) {\n    // document\n    elm = elm.scrollingElement;\n  }\n\n  var _elm2 = elm;\n  scrollLeft = _elm2.scrollLeft;\n  scrollTop = _elm2.scrollTop;\n  scrollHeight = _elm2.scrollHeight;\n  scrollWidth = _elm2.scrollWidth;\n  clientWidth = _elm2.clientWidth;\n  clientHeight = _elm2.clientHeight;\n\n\n  if (typeof x === 'undefined') {\n    x = scrollLeft;\n  } else {\n    x = getNumericValue(x, scrollWidth - clientWidth);\n  }\n  if (typeof y === 'undefined') {\n    y = scrollTop;\n  } else {\n    y = getNumericValue(y, scrollHeight - clientHeight);\n  }\n\n  var easingMethod = createEasingFunction(easing, easingPattern);\n  scrollX.startScroll(scrollLeft, x, speed, function (dx) {\n    elm.scrollLeft = dx;\n  }, scrollingComplete, undefined, easingMethod);\n  scrollY.startScroll(scrollTop, y, speed, function (dy) {\n    elm.scrollTop = dy;\n  }, scrollingComplete, undefined, easingMethod);\n}\n\nvar api$1 = {\n  mounted: function mounted() {\n    // registry scroll\n    this.scrollX = new ScrollControl();\n    this.scrollY = new ScrollControl();\n  },\n\n  methods: {\n    nativeStop: function nativeStop() {\n      this.scrollX.stop();\n      this.scrollY.stop();\n    },\n    nativePause: function nativePause() {\n      this.scrollX.pause();\n      this.scrollY.pause();\n    },\n    nativeContinue: function nativeContinue() {\n      this.scrollX.continue();\n      this.scrollY.continue();\n    },\n    nativeScrollTo: function nativeScrollTo(x, y, speed, easing) {\n      if (speed === false) {\n        \n      } else if (typeof speed === 'undefined') {\n        speed = this.mergedOptions.scrollPanel.speed;\n      }\n      var elm = this.scrollPanelElm;\n      var scrollTop = elm.scrollTop,\n          scrollLeft = elm.scrollLeft,\n          scrollWidth = elm.scrollWidth,\n          clientWidth = elm.clientWidth,\n          scrollHeight = elm.scrollHeight,\n          clientHeight = elm.clientHeight;\n\n      if (typeof x === 'undefined') {\n        x = scrollLeft;\n      } else {\n        x = getNumericValue(x, scrollWidth - clientWidth);\n      }\n      if (typeof y === 'undefined') {\n        y = scrollTop;\n      } else {\n        y = getNumericValue(y, scrollHeight - clientHeight);\n      }\n\n      if (speed) {\n        easing = easing || this.mergedOptions.scrollPanel.easing;\n        var easingMethod = createEasingFunction(easing, easingPattern);\n\n        if (x != scrollLeft) {\n          this.scrollX.startScroll(scrollLeft, x, speed, function (x) {\n            elm.scrollLeft = x;\n          }, this.scrollingComplete.bind(this), undefined, easingMethod);\n        }\n\n        if (y != scrollTop) {\n          this.scrollY.startScroll(scrollTop, y, speed, function (y) {\n            elm.scrollTop = y;\n          }, this.scrollingComplete.bind(this), undefined, easingMethod);\n        }\n      } else {\n        elm.scrollTop = y;\n        elm.scrollLeft = x;\n      }\n    },\n    getCurrentviewDomNative: function getCurrentviewDomNative() {\n      var parent = this.scrollContentElm;\n      var domFragment = getCurrentViewportDom(parent, this.$el);\n      return domFragment;\n    }\n  }\n};\n\nfunction getPanelData(context) {\n  // scrollPanel data start\n  var data = {\n    ref: 'scrollPanel',\n    style: {\n      height: '100%',\n      overflowY: 'scroll',\n      overflowX: 'scroll'\n    },\n    class: [],\n    nativeOn: {\n      '&scroll': context.handleScroll\n    },\n    props: {\n      ops: context.mergedOptions.scrollPanel\n    }\n  };\n\n  context.scrollYEnable = true;\n  context.scrollXEnable = true;\n\n  data.nativeOn.DOMMouseScroll = data.nativeOn.mousewheel = context.onMouseWheel;\n\n  var _context$mergedOption = context.mergedOptions.scrollPanel,\n      scrollingY = _context$mergedOption.scrollingY,\n      scrollingX = _context$mergedOption.scrollingX;\n\n\n  if (!context.bar.hBar.state.size || !scrollingX) {\n    context.scrollXEnable = false;\n    data.style.overflowX = 'hidden';\n  }\n\n  if (!context.bar.vBar.state.size || !scrollingY) {\n    context.scrollYEnable = false;\n    data.style.overflowY = 'hidden';\n  }\n\n  var gutter = getGutter();\n  /* istanbul ignore if */\n  if (!gutter) {\n    createHideBarStyle();\n    data.class.push('__hidebar');\n    if (isIos()) {\n      data.style['-webkit-overflow-scrolling'] = 'touch';\n    }\n  } else {\n    // hide system bar by use a negative value px\n    // gutter should be 0 when manually disable scrollingX #14\n    if (context.bar.vBar.state.size && context.mergedOptions.scrollPanel.scrollingY) {\n      if (context.mergedOptions.scrollPanel.verticalNativeBarPos == 'right') {\n        data.style.marginRight = '-' + gutter + 'px';\n      } /* istanbul ignore next */else {\n          data.style.marginLeft = '-' + gutter + 'px';\n        }\n    }\n    if (context.bar.hBar.state.size && context.mergedOptions.scrollPanel.scrollingX) {\n      data.style.height = 'calc(100% + ' + gutter + 'px)';\n    }\n  }\n\n  // clear legency styles of slide mode...\n  data.style.transformOrigin = '';\n  data.style.transform = '';\n\n  return data;\n}\n\n/**\n * create a scrollPanel\n *\n * @param {any} size\n * @param {any} context\n * @returns\n */\nfunction createPanel(h, context) {\n  var data = {};\n\n  data = getPanelData(context);\n\n  return h(\n    'scrollPanel',\n    data,\n    [getPanelChildren(h, context)]\n  );\n}\n\nfunction getPanelChildren(h, context) {\n  var viewStyle = {\n    position: 'relative',\n    'box-sizing': 'border-box',\n    'min-width': '100%',\n    'min-height': '100%'\n  };\n  var data = {\n    style: viewStyle,\n    ref: 'scrollContent',\n    class: '__view'\n  };\n  var _customContent = context.$slots['scroll-content'];\n\n  if (context.mergedOptions.scrollPanel.scrollingX) {\n    viewStyle.width = getComplitableStyle('width', 'fit-content');\n  } else {\n    data.style['width'] = '100%';\n  }\n\n  if (context.mergedOptions.scrollPanel.padding) {\n    data.style.paddingRight = context.mergedOptions.rail.size;\n  }\n\n  if (_customContent) {\n    return insertChildrenIntoSlot(h, _customContent, context.$slots.default, data);\n  }\n\n  return h(\n    'div',\n    data,\n    [context.$slots.default]\n  );\n}\n\n// detect content size change\nfunction installResizeDetection(element, callback) {\n  return injectObject(element, callback);\n}\n\nfunction injectObject(element, callback) {\n  if (element.hasResized) {\n    return;\n  }\n\n  var OBJECT_STYLE = 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; padding: 0; margin: 0; opacity: 0; z-index: -1000; pointer-events: none;';\n  // define a wrap due to ie's zIndex bug\n  var objWrap = document.createElement('div');\n  objWrap.style.cssText = OBJECT_STYLE;\n  var object = document.createElement('object');\n  object.style.cssText = OBJECT_STYLE;\n  object.type = 'text/html';\n  object.tabIndex = -1;\n\n  object.onload = function () {\n    eventCenter(object.contentDocument.defaultView, 'resize', callback);\n  };\n  // https://github.com/wnr/element-resize-detector/blob/aafe9f7ea11d1eebdab722c7c5b86634e734b9b8/src/detection-strategy/object.js#L159\n  if (!isIE()) {\n    object.data = 'about:blank';\n  }\n  objWrap.isResizeElm = true;\n  objWrap.appendChild(object);\n  element.appendChild(objWrap);\n  if (isIE()) {\n    object.data = 'about:blank';\n  }\n  return function destroy() {\n    if (object.contentDocument) {\n      eventCenter(object.contentDocument.defaultView, 'resize', callback, 'off');\n    }\n    element.removeChild(objWrap);\n    element.hasResized = false;\n  };\n}\n\n/**\n * These mixes is exclusive for native mode\n */\n\nvar update = {\n  methods: {\n    updateNativeModeBarState: function updateNativeModeBarState() {\n      var container = this.scrollPanelElm;\n      var isPercent = this.vuescroll.state.currentSizeStrategy == 'percent';\n      var _vuescroll$state = this.vuescroll.state,\n          width = _vuescroll$state.width,\n          height = _vuescroll$state.height;\n\n      var clientWidth = isPercent || !width ? container.clientWidth : width.slice(0, -2); // xxxpx ==> xxx\n      var clientHeight = isPercent || !height ? container.clientHeight : height.slice(0, -2);\n\n      var heightPercentage = clientHeight / container.scrollHeight;\n      var widthPercentage = clientWidth / container.scrollWidth;\n\n      this.bar.vBar.state.posValue = container.scrollTop * 100 / clientHeight;\n      this.bar.hBar.state.posValue = container.scrollLeft * 100 / clientWidth;\n\n      this.bar.vBar.state.size = heightPercentage < 1 ? heightPercentage : 0;\n      this.bar.hBar.state.size = widthPercentage < 1 ? widthPercentage : 0;\n    },\n    getNativePosition: function getNativePosition() {\n      return {\n        scrollTop: this.scrollPanelElm.scrollTop,\n        scrollLeft: this.scrollPanelElm.scrollLeft\n      };\n    },\n    css: function css(dom, style) /* istanbul ignore next */{\n      return window.getComputedStyle(dom)[style];\n    },\n    checkScrollable: function checkScrollable(e, deltaX, deltaY) /* istanbul ignore next */{\n      var scrollable = false;\n\n      // check mouse point scrollable.\n      var dom = e.target ? e.target : e;\n      while (dom && dom.nodeType == 1 && dom !== this.scrollPanelElm.parentNode && !/^BODY|HTML/.test(dom.nodeName)) {\n        var ov = this.css(dom, 'overflow') || '';\n        if (/scroll|auto/.test(ov)) {\n          var _getScrollProcess = this.getScrollProcess(dom),\n              v = _getScrollProcess.v,\n              h = _getScrollProcess.h;\n\n          var isScrollX = this.css(dom, 'overflowX') !== 'hidden';\n          var isScrollY = this.css(dom, 'overflowY') !== 'hidden';\n          if (isScrollX && (deltaX < 0 && h > 0 || deltaX > 0 && h < 1) || isScrollY && (deltaY < 0 && v > 0 || deltaY > 0 && v < 1)) {\n            scrollable = dom == this.scrollPanelElm;\n            break;\n          }\n        }\n        dom = dom.parentNode ? dom.parentNode : false;\n      }\n\n      return scrollable;\n    },\n    onMouseWheel: function onMouseWheel(event) /* istanbul ignore next */{\n      var _mergedOptions$vuescr = this.mergedOptions.vuescroll,\n          isReverse = _mergedOptions$vuescr.wheelDirectionReverse,\n          duration = _mergedOptions$vuescr.wheelScrollDuration,\n          checkShiftKey = _mergedOptions$vuescr.checkShiftKey,\n          locking = _mergedOptions$vuescr.locking;\n\n\n      var deltaX = void 0;\n      var deltaY = void 0;\n      if (event.wheelDelta) {\n        if (event.deltaY || event.deltaX) {\n          deltaX = event.deltaX;\n          deltaY = event.deltaY;\n          if (locking) {\n            if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {\n              deltaY = 0;\n            } else {\n              deltaX = 0;\n            }\n          }\n        } else {\n          deltaX = 0;\n          deltaY = -1 * event.wheelDelta / 2;\n        }\n      } else if (event.detail) {\n        deltaY = deltaX = event.detail * 16;\n        // horizontal scroll\n        if (event.axis == 1) {\n          deltaY = 0;\n        } else if (event.axis == 2) {\n          // vertical scroll\n          deltaX = 0;\n        }\n      }\n\n      if (checkShiftKey && event.shiftKey) {\n        // swap value\n        deltaX ^= deltaY;\n        deltaY ^= deltaX;\n        deltaX ^= deltaY;\n      }\n\n      if (isReverse) {\n        deltaX ^= deltaY;\n        deltaY ^= deltaX;\n        deltaX ^= deltaY;\n      }\n\n      if (this.checkScrollable(event, deltaX, deltaY)) {\n        event.stopPropagation();\n        event.preventDefault();\n        this.scrollBy({ dx: deltaX, dy: deltaY }, duration);\n      }\n    }\n  },\n  computed: {\n    scrollContentElm: function scrollContentElm() {\n      return this.$refs['scrollContent']._isVue ? this.$refs['scrollContent'].$el : this.$refs['scrollContent'];\n    }\n  }\n};\n\nvar mixins = [api$1, update];\n\nvar core = {\n  mixins: mixins,\n  methods: {\n    destroy: function destroy() {\n      /* istanbul ignore next */\n      if (this.destroyResize) {\n        this.destroyResize();\n      }\n    },\n    getCurrentviewDom: function getCurrentviewDom() {\n      return this.getCurrentviewDomNative();\n    },\n    internalScrollTo: function internalScrollTo(destX, destY, animate, easing) {\n      this.nativeScrollTo(destX, destY, animate, easing);\n    },\n    internalStop: function internalStop() {\n      this.nativeStop();\n    },\n    internalPause: function internalPause() {\n      this.nativePause();\n    },\n    internalContinue: function internalContinue() {\n      this.nativeContinue();\n    },\n    handleScroll: function handleScroll(nativeEvent) {\n      this.updateBarStateAndEmitEvent('handle-scroll', nativeEvent);\n    },\n    updateBarStateAndEmitEvent: function updateBarStateAndEmitEvent(eventType) {\n      var nativeEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      this.updateNativeModeBarState();\n      if (eventType) {\n        this.emitEvent(eventType, nativeEvent);\n      }\n      if (this.mergedOptions.bar.onlyShowBarOnScroll) {\n        if (eventType == 'handle-scroll' || eventType == 'handle-resize' || eventType == 'refresh-status' || eventType == 'window-resize' || eventType == 'options-change') {\n          this.showAndDefferedHideBar(true /* forceHideBar: true */);\n        }\n      } else {\n        this.showAndDefferedHideBar();\n      }\n    },\n    getScrollProcess: function getScrollProcess(elm) {\n      var _ref = elm || this.scrollPanelElm,\n          scrollHeight = _ref.scrollHeight,\n          scrollWidth = _ref.scrollWidth,\n          clientHeight = _ref.clientHeight,\n          clientWidth = _ref.clientWidth,\n          scrollTop = _ref.scrollTop,\n          scrollLeft = _ref.scrollLeft;\n\n      var v = Math.min(scrollTop / (scrollHeight - clientHeight || 1), 1);\n      var h = Math.min(scrollLeft / (scrollWidth - clientWidth || 1), 1);\n\n      return {\n        v: v,\n        h: h\n      };\n    },\n    emitEvent: function emitEvent(eventType) {\n      var nativeEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var _scrollPanelElm = this.scrollPanelElm,\n          scrollTop = _scrollPanelElm.scrollTop,\n          scrollLeft = _scrollPanelElm.scrollLeft;\n\n\n      var vertical = {\n        type: 'vertical'\n      };\n      var horizontal = {\n        type: 'horizontal'\n      };\n\n      var _getScrollProcess = this.getScrollProcess(),\n          v = _getScrollProcess.v,\n          h = _getScrollProcess.h;\n\n      vertical.process = v;\n      horizontal.process = h;\n\n      vertical['barSize'] = this.bar.vBar.state.size;\n      horizontal['barSize'] = this.bar.hBar.state.size;\n      vertical['scrollTop'] = scrollTop;\n      horizontal['scrollLeft'] = scrollLeft;\n\n      this.$emit(eventType, vertical, horizontal, nativeEvent);\n    },\n    initVariables: function initVariables() {\n      this.$el._isVuescroll = true;\n    },\n    refreshInternalStatus: function refreshInternalStatus() {\n      // 1.set vuescroll height or width according to\n      // sizeStrategy\n      this.setVsSize();\n      // 2. registry resize event\n      this.registryResize();\n      // 3. update scrollbar's height/width\n      this.updateBarStateAndEmitEvent('refresh-status');\n    },\n    registryResize: function registryResize() {\n      var _this = this;\n\n      var resizeEnable = this.mergedOptions.vuescroll.detectResize;\n\n      /* istanbul ignore next */\n      if (this.destroyResize && resizeEnable) {\n        return;\n      }\n\n      if (this.destroyResize) {\n        this.destroyResize();\n      }\n\n      if (!resizeEnable) {\n        return;\n      }\n\n      var contentElm = this.scrollContentElm;\n\n      var vm = this;\n      var handleWindowResize = function handleWindowResize() /* istanbul ignore next */{\n        vm.updateBarStateAndEmitEvent('window-resize');\n      };\n      var handleDomResize = function handleDomResize() {\n        var currentSize = {};\n        currentSize['width'] = _this.scrollPanelElm.scrollWidth;\n        currentSize['height'] = _this.scrollPanelElm.scrollHeight;\n        _this.updateBarStateAndEmitEvent('handle-resize', currentSize);\n\n        // Since content sie changes, we should tell parent to set\n        // correct size to fit content's size\n        _this.setVsSize();\n      };\n      window.addEventListener('resize', handleWindowResize, false);\n\n      var destroyDomResize = installResizeDetection(contentElm, handleDomResize);\n\n      var destroyWindowResize = function destroyWindowResize() {\n        window.removeEventListener('resize', handleWindowResize, false);\n      };\n\n      this.destroyResize = function () {\n        destroyWindowResize();\n        destroyDomResize();\n\n        _this.destroyResize = null;\n      };\n    },\n    getPosition: function getPosition() {\n      return this.getNativePosition();\n    }\n  }\n};\n\nvar config = {\n  vuescroll: {\n    wheelScrollDuration: 0,\n    wheelDirectionReverse: false,\n    checkShiftKey: true\n  }\n};\n\nvar component = _install(core, createPanel, [config]);\n\nfunction install(Vue$$1) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  Vue$$1.component(opts.name || component.name, component);\n  Vue$$1.prototype.$vuescrollConfig = opts.ops || {};\n}\n\nvar Vuescroll = _extends({\n  install: install,\n  version: '4.17.3',\n  refreshAll: refreshAll,\n  scrollTo: scrollTo\n}, component);\n\n/* istanbul ignore if */\nif (typeof window !== 'undefined' && window.Vue) {\n  window.Vue.use(Vuescroll);\n}\n\nreturn Vuescroll;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY4MC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEtBQTRELDRCQUE0QixtQkFBTyxDQUFDLEdBQUs7QUFDdEcsQ0FBQyxDQUN3QztBQUN6QyxDQUFDLHlCQUF5Qjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7QUFNRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0NBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCOztBQUU5RDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsR0FBRyxJQUFJO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsK0NBQStDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlCQUFpQixrQkFBa0IsT0FBTzs7QUFFNUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELHVCQUF1QjtBQUM3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxV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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPLGdDQUFnQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELCtEQUErRDtBQUMvRCx5R0FBeUc7QUFDekcsZ0VBQWdFO0FBQ2hFLHVFQUF1RTtBQUN2RSx1SUFBdUk7QUFDdkksdUVBQXVFO0FBQ3ZFLDhFQUE4RTtBQUM5RSxpSUFBaUk7QUFDakksOEVBQThFO0FBQzlFLHFGQUFxRjtBQUNyRixpSkFBaUo7QUFDako7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxvQkFBb0IsUUFBUSxTQUFTLGFBQWEsY0FBYyxjQUFjLFlBQVksV0FBVyxZQUFZLGdCQUFnQixxQkFBcUI7QUFDNUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBGQUEwRjtBQUMxRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3Z1ZXNjcm9sbC9kaXN0L3Z1ZXNjcm9sbC1uYXRpdmUuanM/MjkwMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgICogVnVlc2Nyb2xsIHY0LjE3LjNcbiAgICAqIChjKSAyMDE4LTIwMjEgWWkoWXZlcykgV2FuZ1xuICAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gICAgKiBHaXRodWI6IGh0dHBzOi8vZ2l0aHViLmNvbS9ZdmVzQ29kaW5nL3Z1ZXNjcm9sbFxuICAgICogV2Vic2l0ZTogaHR0cDovL3Z1ZXNjcm9sbGpzLnl2ZXNjb2Rpbmcub3JnL1xuICAgICovXG4gICBcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCd2dWUnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWyd2dWUnXSwgZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLnZ1ZXNjcm9sbCA9IGZhY3RvcnkoZ2xvYmFsLlZ1ZSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKFZ1ZSkgeyAndXNlIHN0cmljdCc7XG5cblZ1ZSA9IFZ1ZSAmJiBWdWUuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSA/IFZ1ZVsnZGVmYXVsdCddIDogVnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzSUUoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNTZXJ2ZXIoKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBhZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIGFnZW50LmluZGV4T2YoJ21zaWUnKSAhPT0gLTEgfHwgYWdlbnQuaW5kZXhPZigndHJpZGVudCcpICE9PSAtMSB8fCBhZ2VudC5pbmRleE9mKCcgZWRnZS8nKSAhPT0gLTE7XG59XG5cbnZhciBpc0lvcyA9IGZ1bmN0aW9uIGlzSW9zKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzU2VydmVyKCkpIHJldHVybiBmYWxzZTtcblxuICB2YXIgdSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIHJldHVybiAhIXUubWF0Y2goL1xcKGlbXjtdKzsoIFU7KT8gQ1BVLitNYWMgT1MgWC8pO1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciBpc1NlcnZlciA9IGZ1bmN0aW9uIGlzU2VydmVyKCkge1xuICByZXR1cm4gVnVlLnByb3RvdHlwZS4kaXNTZXJ2ZXI7XG59O1xuXG52YXIgdG91Y2hNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiB0b3VjaE1hbmFnZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgdG91Y2hNYW5hZ2VyKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKHRvdWNoTWFuYWdlciwgW3tcbiAgICBrZXk6ICdnZXRFdmVudE9iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEV2ZW50T2JqZWN0KG9yaWdpbkV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy50b3VjaE9iamVjdCA/IHRoaXMuaXNUb3VjaCA/IG9yaWdpbkV2ZW50LnRvdWNoZXMgOiBbb3JpZ2luRXZlbnRdIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRUb3VjaE9iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRvdWNoT2JqZWN0KCkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi97XG4gICAgICBpZiAoaXNTZXJ2ZXIoKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgIHRoaXMuaXNUb3VjaCA9IGZhbHNlO1xuICAgICAgdmFyIGFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgICBwbGF0Zm9ybSA9IG5hdmlnYXRvci5wbGF0Zm9ybSxcbiAgICAgICAgICB0b3VjaE9iamVjdCA9IHt9O1xuICAgICAgdG91Y2hPYmplY3QudG91Y2ggPSAhISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgIXdpbmRvdy5vcGVyYSB8fCAnbXNtYXh0b3VjaHBvaW50cycgaW4gd2luZG93Lm5hdmlnYXRvciB8fCAnbWF4dG91Y2hwb2ludHMnIGluIHdpbmRvdy5uYXZpZ2F0b3IgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCB8fCBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyA+IDApO1xuICAgICAgdG91Y2hPYmplY3Qubm9uRGVza1RvdWNoID0gdG91Y2hPYmplY3QudG91Y2ggJiYgIS93aW4zMi9pLnRlc3QocGxhdGZvcm0pIHx8IHRvdWNoT2JqZWN0LnRvdWNoICYmIC93aW4zMi9pLnRlc3QocGxhdGZvcm0pICYmIC9tb2JpbGUvaS50ZXN0KGFnZW50KTtcblxuICAgICAgdG91Y2hPYmplY3QuZXZlbnRUeXBlID0gJ29ubW91c2Vkb3duJyBpbiB3aW5kb3cgJiYgIXRvdWNoT2JqZWN0Lm5vbkRlc2tUb3VjaCA/ICdtb3VzZScgOiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgPyAndG91Y2gnIDogJ21zbWF4dG91Y2hwb2ludHMnIGluIHdpbmRvdy5uYXZpZ2F0b3IgfHwgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAwID8gJ21zdG91Y2hwb2ludHMnIDogJ21heHRvdWNocG9pbnRzJyBpbiB3aW5kb3cubmF2aWdhdG9yIHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAgPyAndG91Y2hwb2ludHMnIDogJ21vdXNlJztcbiAgICAgIHN3aXRjaCAodG91Y2hPYmplY3QuZXZlbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ21vdXNlJzpcbiAgICAgICAgICB0b3VjaE9iamVjdC50b3VjaHN0YXJ0ID0gJ21vdXNlZG93bic7XG4gICAgICAgICAgdG91Y2hPYmplY3QudG91Y2hlbmQgPSAnbW91c2V1cCc7XG4gICAgICAgICAgdG91Y2hPYmplY3QudG91Y2htb3ZlID0gJ21vdXNlbW92ZSc7XG5cbiAgICAgICAgICB0b3VjaE9iamVjdC50b3VjaGVudGVyID0gJ21vdXNlZW50ZXInO1xuICAgICAgICAgIHRvdWNoT2JqZWN0LnRvdWNobW92ZSA9ICdtb3VzZW1vdmUnO1xuICAgICAgICAgIHRvdWNoT2JqZWN0LnRvdWNobGVhdmUgPSAnbW91c2VsZWF2ZSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvdWNoJzpcbiAgICAgICAgICB0b3VjaE9iamVjdC50b3VjaHN0YXJ0ID0gJ3RvdWNoc3RhcnQnO1xuICAgICAgICAgIHRvdWNoT2JqZWN0LnRvdWNoZW5kID0gJ3RvdWNoZW5kJztcbiAgICAgICAgICB0b3VjaE9iamVjdC50b3VjaG1vdmUgPSAndG91Y2htb3ZlJztcbiAgICAgICAgICB0b3VjaE9iamVjdC50b3VjaGNhbmNlbCA9ICd0b3VjaGNhbmNlbCc7XG5cbiAgICAgICAgICB0b3VjaE9iamVjdC50b3VjaGVudGVyID0gJ3RvdWNoc3RhcnQnO1xuICAgICAgICAgIHRvdWNoT2JqZWN0LnRvdWNobW92ZSA9ICd0b3VjaG1vdmUnO1xuICAgICAgICAgIHRvdWNoT2JqZWN0LnRvdWNobGVhdmUgPSAndG91Y2hlbmQnO1xuICAgICAgICAgIHRoaXMuaXNUb3VjaCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21zdG91Y2hwb2ludHMnOlxuICAgICAgICAgIHRvdWNoT2JqZWN0LnRvdWNoc3RhcnQgPSAnTVNQb2ludGVyRG93bic7XG4gICAgICAgICAgdG91Y2hPYmplY3QudG91Y2hlbmQgPSAnTVNQb2ludGVyVXAnO1xuICAgICAgICAgIHRvdWNoT2JqZWN0LnRvdWNobW92ZSA9ICdNU1BvaW50ZXJNb3ZlJztcbiAgICAgICAgICB0b3VjaE9iamVjdC50b3VjaGNhbmNlbCA9ICdNU1BvaW50ZXJDYW5jZWwnO1xuXG4gICAgICAgICAgdG91Y2hPYmplY3QudG91Y2hlbnRlciA9ICdNU1BvaW50ZXJEb3duJztcbiAgICAgICAgICB0b3VjaE9iamVjdC50b3VjaG1vdmUgPSAnTVNQb2ludGVyTW92ZSc7XG4gICAgICAgICAgdG91Y2hPYmplY3QudG91Y2hsZWF2ZSA9ICdNU1BvaW50ZXJVcCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvdWNocG9pbnRzJzpcbiAgICAgICAgICB0b3VjaE9iamVjdC50b3VjaHN0YXJ0ID0gJ3BvaW50ZXJkb3duJztcbiAgICAgICAgICB0b3VjaE9iamVjdC50b3VjaGVuZCA9ICdwb2ludGVydXAnO1xuICAgICAgICAgIHRvdWNoT2JqZWN0LnRvdWNobW92ZSA9ICdwb2ludGVybW92ZSc7XG4gICAgICAgICAgdG91Y2hPYmplY3QudG91Y2hjYW5jZWwgPSAncG9pbnRlcmNhbmNlbCc7XG5cbiAgICAgICAgICB0b3VjaE9iamVjdC50b3VjaGVudGVyID0gJ3BvaW50ZXJkb3duJztcbiAgICAgICAgICB0b3VjaE9iamVjdC50b3VjaG1vdmUgPSAncG9pbnRlcm1vdmUnO1xuICAgICAgICAgIHRvdWNoT2JqZWN0LnRvdWNobGVhdmUgPSAncG9pbnRlcnVwJztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudG91Y2hPYmplY3QgPSB0b3VjaE9iamVjdDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIHRvdWNoTWFuYWdlcjtcbn0oKTtcblxuZnVuY3Rpb24gZGVlcENvcHkoZnJvbSwgdG8sIHNoYWxsb3cpIHtcbiAgaWYgKHNoYWxsb3cgJiYgaXNVbmRlZih0bykpIHtcbiAgICByZXR1cm4gZnJvbTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KGZyb20pKSB7XG4gICAgdG8gPSBbXTtcbiAgICBmcm9tLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICB0b1tpbmRleF0gPSBkZWVwQ29weShpdGVtLCB0b1tpbmRleF0pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGZyb20pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmooZnJvbSkpIHtcbiAgICAgIHJldHVybiBmcm9tO1xuICAgIH1cbiAgICB0byA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgICB0b1trZXldID0gX3R5cGVvZihmcm9tW2tleV0pID09PSAnb2JqZWN0JyA/IGRlZXBDb3B5KGZyb21ba2V5XSwgdG9ba2V5XSkgOiBmcm9tW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3QoZnJvbSwgdG8sIGZvcmNlLCBzaGFsbG93KSB7XG4gIGlmIChzaGFsbG93ICYmIGlzVW5kZWYodG8pKSB7XG4gICAgcmV0dXJuIGZyb207XG4gIH1cblxuICB0byA9IHRvIHx8IHt9O1xuXG4gIGlmIChpc0FycmF5KGZyb20pKSB7XG4gICAgaWYgKCFpc0FycmF5KHRvKSAmJiBmb3JjZSkge1xuICAgICAgdG8gPSBbXTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkodG8pKSB7XG4gICAgICBmcm9tLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHRvW2luZGV4XSA9IG1lcmdlT2JqZWN0KGl0ZW0sIHRvW2luZGV4XSwgZm9yY2UsIHNoYWxsb3cpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZyb20pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmooZnJvbSkpIHtcbiAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICB0byA9IGZyb207XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKGZyb21ba2V5XSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKGlzVW5kZWYodG9ba2V5XSkpIHtcbiAgICAgICAgICAgIHRvW2tleV0gPSBkZWVwQ29weShmcm9tW2tleV0sIHRvW2tleV0sIHNoYWxsb3cpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXJnZU9iamVjdChmcm9tW2tleV0sIHRvW2tleV0sIGZvcmNlLCBzaGFsbG93KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzVW5kZWYodG9ba2V5XSkgfHwgZm9yY2UpIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG87XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlKHRhcmdldCwga2V5LCBzb3VyY2UsIHNvdWNlS2V5KSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIXNvdXJjZVtrZXldICYmIHR5cGVvZiBzb3VyY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc291Y2VLZXkgPSBzb3VjZUtleSB8fCBrZXk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHNvdXJjZVtzb3VjZUtleV07XG4gICAgfSxcblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxudmFyIHNjcm9sbEJhcldpZHRoID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0R3V0dGVyKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoaXNTZXJ2ZXIoKSkgcmV0dXJuIDA7XG4gIGlmIChzY3JvbGxCYXJXaWR0aCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gc2Nyb2xsQmFyV2lkdGg7XG4gIHZhciBvdXRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBvdXRlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIG91dGVyLnN0eWxlLndpZHRoID0gJzEwMHB4JztcbiAgb3V0ZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBvdXRlci5zdHlsZS50b3AgPSAnLTk5OTlweCc7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xuXG4gIHZhciB3aWR0aE5vU2Nyb2xsID0gb3V0ZXIub2Zmc2V0V2lkdGg7XG4gIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG5cbiAgdmFyIGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGlubmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XG5cbiAgdmFyIHdpZHRoV2l0aFNjcm9sbCA9IGlubmVyLm9mZnNldFdpZHRoO1xuICBvdXRlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG91dGVyKTtcbiAgc2Nyb2xsQmFyV2lkdGggPSB3aWR0aE5vU2Nyb2xsIC0gd2lkdGhXaXRoU2Nyb2xsO1xuXG4gIHJldHVybiBzY3JvbGxCYXJXaWR0aDtcbn1cblxuZnVuY3Rpb24gZXZlbnRDZW50ZXIoZG9tLCBldmVudE5hbWUsIGhhbmRlcikge1xuICB2YXIgY2FwdHVyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAnb24nO1xuXG4gIHR5cGUgPT0gJ29uJyA/IGRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGVyLCBjYXB0dXJlKSA6IGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGVyLCBjYXB0dXJlKTtcbn1cblxuXG52YXIgd2FybiA9IGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gIGNvbnNvbGUud2FybignW3Z1ZXNjcm9sbF0gJyArIG1zZyk7XG59O1xuXG5mdW5jdGlvbiBpc0NoaWxkSW5QYXJlbnQoY2hpbGQsIHBhcmVudCkge1xuICB2YXIgZmxhZyA9IGZhbHNlO1xuICBpZiAoIWNoaWxkIHx8ICFwYXJlbnQpIHtcbiAgICByZXR1cm4gZmxhZztcbiAgfVxuICB3aGlsZSAoY2hpbGQucGFyZW50Tm9kZSAhPT0gcGFyZW50ICYmIGNoaWxkLnBhcmVudE5vZGUubm9kZVR5cGUgIT09IDkgJiYgIWNoaWxkLnBhcmVudE5vZGUuX2lzVnVlc2Nyb2xsKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlO1xuICB9XG4gIGlmIChjaGlsZC5wYXJlbnROb2RlID09IHBhcmVudCkge1xuICAgIGZsYWcgPSB0cnVlO1xuICB9XG4gIHJldHVybiBmbGFnO1xufVxuXG5mdW5jdGlvbiBnZXRQcmVmaXgoZ2xvYmFsKSB7XG4gIHZhciBkb2NTdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbiAgdmFyIGVuZ2luZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChnbG9iYWwub3BlcmEgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9wZXJhKSA9PT0gJ1tvYmplY3QgT3BlcmFdJykge1xuICAgIGVuZ2luZSA9ICdwcmVzdG8nO1xuICB9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovZWxzZSBpZiAoJ01vekFwcGVhcmFuY2UnIGluIGRvY1N0eWxlKSB7XG4gICAgICBlbmdpbmUgPSAnZ2Vja28nO1xuICAgIH0gZWxzZSBpZiAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY1N0eWxlKSB7XG4gICAgICBlbmdpbmUgPSAnd2Via2l0JztcbiAgICB9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovZWxzZSBpZiAodHlwZW9mIG5hdmlnYXRvci5jcHVDbGFzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZW5naW5lID0gJ3RyaWRlbnQnO1xuICAgICAgfVxuICB2YXIgdmVuZG9yUHJlZml4ID0ge1xuICAgIHRyaWRlbnQ6ICdtcycsXG4gICAgZ2Vja286ICdtb3onLFxuICAgIHdlYmtpdDogJ3dlYmtpdCcsXG4gICAgcHJlc3RvOiAnTydcbiAgfVtlbmdpbmVdO1xuICByZXR1cm4gdmVuZG9yUHJlZml4O1xufVxuXG5mdW5jdGlvbiBnZXRDb21wbGl0YWJsZVN0eWxlKHByb3BlcnR5LCB2YWx1ZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzU2VydmVyKCkpIHJldHVybiBmYWxzZTtcblxuICB2YXIgY29tcGF0aWJsZVZhbHVlID0gJy0nICsgZ2V0UHJlZml4KHdpbmRvdykgKyAnLScgKyB2YWx1ZTtcbiAgdmFyIHRlc3RFbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGVzdEVsbS5zdHlsZVtwcm9wZXJ0eV0gPSBjb21wYXRpYmxlVmFsdWU7XG4gIGlmICh0ZXN0RWxtLnN0eWxlW3Byb3BlcnR5XSA9PSBjb21wYXRpYmxlVmFsdWUpIHtcbiAgICByZXR1cm4gY29tcGF0aWJsZVZhbHVlO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBJbnNlcnQgY2hpbGRyZW4gaW50byB1c2VyLXBhc3NlZCBzbG90IGF0IHZub2RlIGxldmVsXG4gKi9cbmZ1bmN0aW9uIGluc2VydENoaWxkcmVuSW50b1Nsb3QoaCkge1xuICB2YXIgcGFyZW50Vm5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICB2YXIgY2hpbGRWTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG4gIHZhciBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgdmFyIHN3YXBDaGlsZHJlbiA9IGFyZ3VtZW50c1s0XTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gc3dhcENoaWxkcmVuID8gW10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KGNoaWxkVk5vZGUpLCB0b0NvbnN1bWFibGVBcnJheShwYXJlbnRWbm9kZSkpIDogW10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHBhcmVudFZub2RlKSwgdG9Db25zdW1hYmxlQXJyYXkoY2hpbGRWTm9kZSkpO1xuICB9XG5cbiAgcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZVswXTtcblxuICB2YXIgX2dldFZub2RlSW5mbyA9IGdldFZub2RlSW5mbyhwYXJlbnRWbm9kZSksXG4gICAgICBjaCA9IF9nZXRWbm9kZUluZm8uY2gsXG4gICAgICB0YWcgPSBfZ2V0Vm5vZGVJbmZvLnRhZyxcbiAgICAgIGlzQ29tcG9uZW50ID0gX2dldFZub2RlSW5mby5pc0NvbXBvbmVudDtcblxuICBpZiAoaXNDb21wb25lbnQpIHtcbiAgICBwYXJlbnRWbm9kZS5kYXRhID0gbWVyZ2VPYmplY3QoeyBhdHRyczogcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEgfSwgcGFyZW50Vm5vZGUuZGF0YSwgZmFsc2UsIC8vIGZvcmNlOiBmYWxzZVxuICAgIHRydWUgLy8gc2hhbGxvdzogdHJ1ZVxuICAgICk7XG4gIH1cbiAgY2ggPSBzd2FwQ2hpbGRyZW4gPyBbXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoY2hpbGRWTm9kZSksIHRvQ29uc3VtYWJsZUFycmF5KGNoKSkgOiBbXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoY2gpLCB0b0NvbnN1bWFibGVBcnJheShjaGlsZFZOb2RlKSk7XG4gIGRlbGV0ZSBwYXJlbnRWbm9kZS5kYXRhLnNsb3Q7XG5cbiAgcmV0dXJuIGgodGFnLCBtZXJnZU9iamVjdChkYXRhLCBwYXJlbnRWbm9kZS5kYXRhLCBmYWxzZSwgdHJ1ZSksIGNoKTtcbn1cblxuLyoqXG4gKiAgR2V0IHRoZSBpbmZvIG9mIGEgdm5vZGUsXG4gKiB2bm9kZSBtdXN0IGJlIHBhcmVudFZub2RlXG4gKi9cbmZ1bmN0aW9uIGdldFZub2RlSW5mbyh2bm9kZSkge1xuICBpZiAoIXZub2RlIHx8IHZub2RlLmxlbmd0aCA+IDEpIHJldHVybiB7fTtcblxuICB2bm9kZSA9IHZub2RlWzBdID8gdm5vZGVbMF0gOiB2bm9kZTtcbiAgdmFyIGlzQ29tcG9uZW50ID0gISF2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICB2YXIgY2ggPSB2b2lkIDA7XG4gIHZhciB0YWcgPSB2b2lkIDA7XG5cbiAgaWYgKGlzQ29tcG9uZW50KSB7XG4gICAgY2ggPSB2bm9kZS5jb21wb25lbnRPcHRpb25zLmNoaWxkcmVuIHx8IFtdO1xuICAgIHRhZyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnMudGFnO1xuICB9IGVsc2Uge1xuICAgIGNoID0gdm5vZGUuY2hpbGRyZW4gfHwgW107XG4gICAgdGFnID0gdm5vZGUudGFnO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc0NvbXBvbmVudDogaXNDb21wb25lbnQsXG4gICAgY2g6IGNoLFxuICAgIHRhZzogdGFnXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSB2dWVzY3JvbGwgaW5zdGFuY2UgaW5zdGVhZCBvZlxuICogdXNlciBwYXNzIGNvbXBvbmVudCBsaWtlIHNsb3QuXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWxQYXJlbnQoY3R4KSB7XG4gIHZhciBwYXJlbnQgPSBjdHguJHBhcmVudDtcbiAgaWYgKCFwYXJlbnQuX2lzVnVlc2Nyb2xsUm9vdCAmJiBwYXJlbnQpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgfVxuICByZXR1cm4gcGFyZW50O1xufVxuXG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkoXykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShfKTtcbn07XG52YXIgaXNQbGFpbk9iaiA9IGZ1bmN0aW9uIGlzUGxhaW5PYmooXykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKF8pID09ICdbb2JqZWN0IE9iamVjdF0nO1xufTtcbnZhciBpc1VuZGVmID0gZnVuY3Rpb24gaXNVbmRlZihfKSB7XG4gIHJldHVybiB0eXBlb2YgXyA9PT0gJ3VuZGVmaW5lZCc7XG59O1xuXG5mdW5jdGlvbiBnZXROdW1lcmljVmFsdWUoZGlzdGFuY2UsIHNpemUpIHtcbiAgdmFyIG51bWJlciA9IHZvaWQgMDtcbiAgaWYgKCEobnVtYmVyID0gLygtP1xcZCsoPzpcXC5cXGQrPyk/KSUkLy5leGVjKGRpc3RhbmNlKSkpIHtcbiAgICBudW1iZXIgPSBkaXN0YW5jZSAtIDA7XG4gIH0gZWxzZSB7XG4gICAgbnVtYmVyID0gbnVtYmVyWzFdIC0gMDtcbiAgICBudW1iZXIgPSBzaXplICogbnVtYmVyIC8gMTAwO1xuICB9XG4gIHJldHVybiBudW1iZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlKHN0eWxlSWQsIGNzc1RleHQpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc1NlcnZlcigpIHx8IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0eWxlSWQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXG4gIHN0eWxlLmlkID0gc3R5bGVJZDtcbiAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3NUZXh0KSk7XG4gIH1cblxuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cblxuLy8gSGlkZSB0aGUgaW9zIG5hdGl2ZSBzY3JvbGxiYXIuXG5mdW5jdGlvbiBjcmVhdGVIaWRlQmFyU3R5bGUoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHtcbiAgICB2YXIgY3NzVGV4dCA9ICcuX19oaWRlYmFyOjotd2Via2l0LXNjcm9sbGJhciB7XFxuICAgICAgd2lkdGg6IDA7XFxuICAgICAgaGVpZ2h0OiAwO1xcbiAgICB9JztcblxuICAgIGNyZWF0ZVN0eWxlKCd2dWVzY3JvbGwtaGlkZS1pb3MtYmFyJywgY3NzVGV4dCk7XG4gIH1cbn1cblxuLy8gY3JlYXRlIHNsaWRlIG1vZGUgc3R5bGVcblxudmFyIGFwaSA9IHtcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB2c0luc3RhbmNlc1t0aGlzLl91aWRdID0gdGhpcztcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICBkZWxldGUgdnNJbnN0YW5jZXNbdGhpcy5fdWlkXTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgLy8gcHVibGljIGFwaVxuICAgIHNjcm9sbFRvOiBmdW5jdGlvbiBzY3JvbGxUbyhfcmVmLCBzcGVlZCwgZWFzaW5nKSB7XG4gICAgICB2YXIgeCA9IF9yZWYueCxcbiAgICAgICAgICB5ID0gX3JlZi55O1xuXG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICAgIGlmIChzcGVlZCA9PT0gdHJ1ZSB8fCB0eXBlb2Ygc3BlZWQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3BlZWQgPSB0aGlzLm1lcmdlZE9wdGlvbnMuc2Nyb2xsUGFuZWwuc3BlZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmludGVybmFsU2Nyb2xsVG8oeCwgeSwgc3BlZWQsIGVhc2luZyk7XG4gICAgfSxcbiAgICBzY3JvbGxCeTogZnVuY3Rpb24gc2Nyb2xsQnkoX3JlZjIsIHNwZWVkLCBlYXNpbmcpIHtcbiAgICAgIHZhciBfcmVmMiRkeCA9IF9yZWYyLmR4LFxuICAgICAgICAgIGR4ID0gX3JlZjIkZHggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmMiRkeCxcbiAgICAgICAgICBfcmVmMiRkeSA9IF9yZWYyLmR5LFxuICAgICAgICAgIGR5ID0gX3JlZjIkZHkgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmMiRkeTtcblxuICAgICAgdmFyIF9nZXRQb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcbiAgICAgICAgICBfZ2V0UG9zaXRpb24kc2Nyb2xsTGUgPSBfZ2V0UG9zaXRpb24uc2Nyb2xsTGVmdCxcbiAgICAgICAgICBzY3JvbGxMZWZ0ID0gX2dldFBvc2l0aW9uJHNjcm9sbExlID09PSB1bmRlZmluZWQgPyAwIDogX2dldFBvc2l0aW9uJHNjcm9sbExlLFxuICAgICAgICAgIF9nZXRQb3NpdGlvbiRzY3JvbGxUbyA9IF9nZXRQb3NpdGlvbi5zY3JvbGxUb3AsXG4gICAgICAgICAgc2Nyb2xsVG9wID0gX2dldFBvc2l0aW9uJHNjcm9sbFRvID09PSB1bmRlZmluZWQgPyAwIDogX2dldFBvc2l0aW9uJHNjcm9sbFRvO1xuXG4gICAgICBpZiAoZHgpIHtcbiAgICAgICAgc2Nyb2xsTGVmdCArPSBnZXROdW1lcmljVmFsdWUoZHgsIHRoaXMuc2Nyb2xsUGFuZWxFbG0uc2Nyb2xsV2lkdGggLSB0aGlzLiRlbC5jbGllbnRXaWR0aCk7XG4gICAgICB9XG4gICAgICBpZiAoZHkpIHtcbiAgICAgICAgc2Nyb2xsVG9wICs9IGdldE51bWVyaWNWYWx1ZShkeSwgdGhpcy5zY3JvbGxQYW5lbEVsbS5zY3JvbGxIZWlnaHQgLSB0aGlzLiRlbC5jbGllbnRIZWlnaHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnRlcm5hbFNjcm9sbFRvKHNjcm9sbExlZnQsIHNjcm9sbFRvcCwgc3BlZWQsIGVhc2luZyk7XG4gICAgfSxcbiAgICBzY3JvbGxJbnRvVmlldzogZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoZWxtKSB7XG4gICAgICB2YXIgYW5pbWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgdmFyIHBhcmVudEVsbSA9IHRoaXMuJGVsO1xuXG4gICAgICBpZiAodHlwZW9mIGVsbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWxtID0gcGFyZW50RWxtLnF1ZXJ5U2VsZWN0b3IoZWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0NoaWxkSW5QYXJlbnQoZWxtLCBwYXJlbnRFbG0pKSB7XG4gICAgICAgIHdhcm4oJ1RoZSBlbGVtZW50IG9yIHNlbGVjdG9yIHlvdSBwYXNzZWQgaXMgbm90IHRoZSBlbGVtZW50IG9mIFZ1ZXNjcm9sbCwgcGxlYXNlIHBhc3MgdGhlIGVsZW1lbnQgdGhhdCBpcyBpbiBWdWVzY3JvbGwgdG8gc2Nyb2xsSW50b1ZpZXcgQVBJLiAnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXJlbnQgZWxtIGxlZnQsIHRvcFxuXG4gICAgICB2YXIgXyRlbCRnZXRCb3VuZGluZ0NsaWVuID0gdGhpcy4kZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgbGVmdCA9IF8kZWwkZ2V0Qm91bmRpbmdDbGllbi5sZWZ0LFxuICAgICAgICAgIHRvcCA9IF8kZWwkZ2V0Qm91bmRpbmdDbGllbi50b3A7XG4gICAgICAvLyBjaGlsZCBlbG0gbGVmdCwgdG9wXG5cblxuICAgICAgdmFyIF9lbG0kZ2V0Qm91bmRpbmdDbGllbiA9IGVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICBjaGlsZExlZnQgPSBfZWxtJGdldEJvdW5kaW5nQ2xpZW4ubGVmdCxcbiAgICAgICAgICBjaGlsZFRvcCA9IF9lbG0kZ2V0Qm91bmRpbmdDbGllbi50b3A7XG5cbiAgICAgIHZhciBkaWZmWCA9IGxlZnQgLSBjaGlsZExlZnQ7XG4gICAgICB2YXIgZGlmZlkgPSB0b3AgLSBjaGlsZFRvcDtcblxuICAgICAgdGhpcy5zY3JvbGxCeSh7XG4gICAgICAgIGR4OiAtZGlmZlgsXG4gICAgICAgIGR5OiAtZGlmZllcbiAgICAgIH0sIGFuaW1hdGUpO1xuICAgIH0sXG4gICAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHRoaXMucmVmcmVzaEludGVybmFsU3RhdHVzKCk7XG4gICAgICAvLyByZWZyZXNoIGFnYWluIHRvIGtlZXAgc3RhdHVzIGlzIGNvcnJlY3RcbiAgICAgIHRoaXMuJG5leHRUaWNrKHRoaXMucmVmcmVzaEludGVybmFsU3RhdHVzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiBQdWJsaWMgQXBpICovXG5cbi8qKlxuICogUmVmcmVzaCBhbGxcbiAqL1xudmFyIHZzSW5zdGFuY2VzID0ge307XG5mdW5jdGlvbiByZWZyZXNoQWxsKCkge1xuICBmb3IgKHZhciB2cyBpbiB2c0luc3RhbmNlcykge1xuICAgIHZzSW5zdGFuY2VzW3ZzXS5yZWZyZXNoKCk7XG4gIH1cbn1cblxudmFyIGJhc2VDb25maWcgPSB7XG4gIC8vIHZ1ZXNjcm9sbFxuICB2dWVzY3JvbGw6IHtcbiAgICAvLyB2dWVzY3JvbGwncyBzaXplKGhlaWdodC93aWR0aCkgc2hvdWxkIGJlIGEgcGVyY2VudCgxMDAlKVxuICAgIC8vIG9yIGJlIGEgbnVtYmVyIHRoYXQgaXMgZXF1YWwgdG8gaXRzIHBhcmVudE5vZGUncyB3aWR0aCBvclxuICAgIC8vIGhlaWdodCA/XG4gICAgc2l6ZVN0cmF0ZWd5OiAncGVyY2VudCcsXG4gICAgLyoqIFdoZXRoZXIgdG8gZGV0ZWN0IGRvbSByZXNpemUgb3Igbm90ICovXG4gICAgZGV0ZWN0UmVzaXplOiB0cnVlLFxuICAgIC8qKiBFbmFibGUgbG9ja2luZyB0byB0aGUgbWFpbiBheGlzIGlmIHVzZXIgbW92ZXMgb25seSBzbGlnaHRseSBvbiBvbmUgb2YgdGhlbSBhdCBzdGFydCAqL1xuICAgIGxvY2tpbmc6IHRydWVcbiAgfSxcbiAgc2Nyb2xsUGFuZWw6IHtcbiAgICAvLyB3aGVuIGNvbXBvbmVudCBtb3VudGVkLi4gaXQgd2lsbCBhdXRvbWF0aWNhbGx5IHNjcm9sbHMuXG4gICAgaW5pdGlhbFNjcm9sbFk6IGZhbHNlLFxuICAgIGluaXRpYWxTY3JvbGxYOiBmYWxzZSxcbiAgICAvLyBmZWF0OiAjMTFcbiAgICBzY3JvbGxpbmdYOiB0cnVlLFxuICAgIHNjcm9sbGluZ1k6IHRydWUsXG4gICAgc3BlZWQ6IDMwMCxcbiAgICBlYXNpbmc6IHVuZGVmaW5lZCxcbiAgICAvLyBTb21ldGltZXMsIHRoZSBuYXRpdmViYXIgbWF5YmUgb24gdGhlIGxlZnQsXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ZdmVzQ29kaW5nL3Z1ZXNjcm9sbC9pc3N1ZXMvNjRcbiAgICB2ZXJ0aWNhbE5hdGl2ZUJhclBvczogJ3JpZ2h0JyxcbiAgICBtYXhIZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICBtYXhXaWR0aDogdW5kZWZpbmVkXG4gIH0sXG5cbiAgLy9cbiAgcmFpbDoge1xuICAgIGJhY2tncm91bmQ6ICcjMDFhOTlhJyxcbiAgICBvcGFjaXR5OiAwLFxuICAgIGJvcmRlcjogJ25vbmUnLFxuICAgIC8qKiBSYWlsJ3Mgc2l6ZShIZWlnaHQvV2lkdGgpICwgZGVmYXVsdCAtPiA2cHggKi9cbiAgICBzaXplOiAnNnB4JyxcbiAgICAvKiogU3BlY2lmeSByYWlsJ3MgYm9yZGVyLXJhZGl1cywgb3IgdGhlIGJvcmRlci1yYWRpdXMgb2YgcmFpbCBhbmQgYmFyIHdpbGwgYmUgZXF1YWwgdG8gdGhlIHJhaWwncyBzaXplLiBkZWZhdWx0IC0+IGZhbHNlICoqL1xuICAgIHNwZWNpZnlCb3JkZXJSYWRpdXM6IGZhbHNlLFxuICAgIC8qKiBSYWlsIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSB0d28gZW5kcyBvZiB0aGUgWCBheGlzIGFuZCBZIGF4aXMuICoqL1xuICAgIGd1dHRlck9mRW5kczogbnVsbCxcbiAgICAvKiogUmFpbCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgc2lkZSBvZiBjb250YWluZXIuICoqL1xuICAgIGd1dHRlck9mU2lkZTogJzJweCcsXG4gICAgLyoqIFdoZXRoZXIgdG8ga2VlcCByYWlsIHNob3cgb3Igbm90LCBkZWZhdWx0IC0+IGZhbHNlLCBldmVudCBjb250ZW50IGhlaWdodCBpcyBub3QgZW5vdWdoICovXG4gICAga2VlcFNob3c6IGZhbHNlXG4gIH0sXG4gIGJhcjoge1xuICAgIC8qKiBIb3cgbG9uZyB0byBoaWRlIGJhciBhZnRlciBtb3VzZWxlYXZlLCBkZWZhdWx0IC0+IDUwMCAqL1xuICAgIHNob3dEZWxheTogNTAwLFxuICAgIC8qKiBTcGVjaWZ5IGJhcidzIGJvcmRlci1yYWRpdXMsIG9yIHRoZSBib3JkZXItcmFkaXVzIG9mIHJhaWwgYW5kIGJhciB3aWxsIGJlIGVxdWFsIHRvIHRoZSByYWlsJ3Mgc2l6ZS4gZGVmYXVsdCAtPiBmYWxzZSAqKi9cbiAgICBzcGVjaWZ5Qm9yZGVyUmFkaXVzOiBmYWxzZSxcbiAgICAvKiogV2hldGhlciB0byBzaG93IGJhciBvbiBzY3JvbGxpbmcsIGRlZmF1bHQgLT4gdHJ1ZSAqL1xuICAgIG9ubHlTaG93QmFyT25TY3JvbGw6IHRydWUsXG4gICAgLyoqIFdoZXRoZXIgdG8ga2VlcCBzaG93IG9yIG5vdCwgZGVmYXVsdCAtPiBmYWxzZSAqL1xuICAgIGtlZXBTaG93OiBmYWxzZSxcbiAgICAvKiogQmFyJ3MgYmFja2dyb3VuZCAsIGRlZmF1bHQgLT4gIzAwYTY1MCAqL1xuICAgIGJhY2tncm91bmQ6ICdyZ2IoMywgMTg1LCAxMTgpJyxcbiAgICAvKiogQmFyJ3Mgb3BhY2l0eSwgZGVmYXVsdCAtPiAxICAqL1xuICAgIG9wYWNpdHk6IDEsXG4gICAgLyoqIGJhcidzIHNpemUoSGVpZ2h0L1dpZHRoKSAsIGRlZmF1bHQgLT4gNnB4ICovXG5cbiAgICBzaXplOiAnNnB4JyxcbiAgICBtaW5TaXplOiAwLFxuICAgIGRpc2FibGU6IGZhbHNlXG4gIH0sXG4gIHNjcm9sbEJ1dHRvbjoge1xuICAgIGVuYWJsZTogZmFsc2UsXG4gICAgYmFja2dyb3VuZDogJ3JnYigzLCAxODUsIDExOCknLFxuICAgIG9wYWNpdHk6IDEsXG4gICAgc3RlcDogMTgwLFxuICAgIG1vdXNlZG93blN0ZXA6IDMwXG4gIH1cbn07XG4vKipcbiAqIHZhbGlkYXRlIHRoZSBvcHRpb25zXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0ge2FueX0gb3BzXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlT3BzKG9wcykge1xuICB2YXIgcmVuZGVyRXJyb3IgPSBmYWxzZTtcbiAgdmFyIHNjcm9sbFBhbmVsID0gb3BzLnNjcm9sbFBhbmVsO1xuICB2YXIgX29wcyRiYXIgPSBvcHMuYmFyLFxuICAgICAgdkJhciA9IF9vcHMkYmFyLnZCYXIsXG4gICAgICBoQmFyID0gX29wcyRiYXIuaEJhcjtcbiAgdmFyIF9vcHMkcmFpbCA9IG9wcy5yYWlsLFxuICAgICAgdlJhaWwgPSBfb3BzJHJhaWwudlJhaWwsXG4gICAgICBoUmFpbCA9IF9vcHMkcmFpbC5oUmFpbDtcblxuICAvLyB2YWxpZGF0ZSBzY3JvbGxQYW5lbFxuXG4gIHZhciBpbml0aWFsU2Nyb2xsWSA9IHNjcm9sbFBhbmVsWydpbml0aWFsU2Nyb2xsWSddO1xuICB2YXIgaW5pdGlhbFNjcm9sbFggPSBzY3JvbGxQYW5lbFsnaW5pdGlhbFNjcm9sbFgnXTtcblxuICBpZiAoaW5pdGlhbFNjcm9sbFkgJiYgIVN0cmluZyhpbml0aWFsU2Nyb2xsWSkubWF0Y2goL15cXGQrKFxcLlxcZCspPyglKT8kLykpIHtcbiAgICB3YXJuKCdUaGUgcHJvcCBgaW5pdGlhbFNjcm9sbFlgIG9yIGBpbml0aWFsU2Nyb2xsWGAgc2hvdWxkIGJlIGEgcGVyY2VudCBudW1iZXIgbGlrZSBgMTAlYCBvciBhbiBleGFjdCBudW1iZXIgdGhhdCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBsaWtlIGAxMDBgLicpO1xuICB9XG4gIGlmIChpbml0aWFsU2Nyb2xsWCAmJiAhU3RyaW5nKGluaXRpYWxTY3JvbGxYKS5tYXRjaCgvXlxcZCsoXFwuXFxkKyk/KCUpPyQvKSkge1xuICAgIHdhcm4oJ1RoZSBwcm9wIGBpbml0aWFsU2Nyb2xsWWAgb3IgYGluaXRpYWxTY3JvbGxYYCBzaG91bGQgYmUgYSBwZXJjZW50IG51bWJlciBsaWtlIGAxMCVgIG9yIGFuIGV4YWN0IG51bWJlciB0aGF0IGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwIGxpa2UgYDEwMGAuJyk7XG4gIH1cblxuICAvLyB2YWxpZGF0ZSBkZXByZWNhdGVkIHZCYXIvaEJhciB2UmFpbC9oUmFpbFxuICBpZiAodkJhciB8fCBoQmFyIHx8IHZSYWlsIHx8IGhSYWlsKSB7XG4gICAgd2FybignVGhlIG9wdGlvbnM6IHZSYWlsLCBoUmFpbCwgdkJhciwgaEJhciBoYXZlIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2NC43LjAsJyArICdwbGVhc2UgdXNlIGNvcnJlc3BvbmluZyByYWlsL2JhciBpbnN0ZWFkIScpO1xuICB9XG5cbiAgaWYgKF9leHRyYVZhbGlkYXRlKSB7XG4gICAgX2V4dHJhVmFsaWRhdGUgPSBbXS5jb25jYXQoX2V4dHJhVmFsaWRhdGUpO1xuICAgIF9leHRyYVZhbGlkYXRlLmZvckVhY2goZnVuY3Rpb24gKGhhc0Vycm9yKSB7XG4gICAgICBpZiAoaGFzRXJyb3Iob3BzKSkge1xuICAgICAgICByZW5kZXJFcnJvciA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlbmRlckVycm9yO1xufVxuXG52YXIgX2V4dHJhVmFsaWRhdGUgPSBudWxsO1xudmFyIGV4dGVuZE9wdHMgPSBmdW5jdGlvbiBleHRlbmRPcHRzKGV4dHJhT3B0cywgZXh0cmFWYWxpZGF0ZSkge1xuICBleHRyYU9wdHMgPSBbXS5jb25jYXQoZXh0cmFPcHRzKTtcbiAgZXh0cmFPcHRzLmZvckVhY2goZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBtZXJnZU9iamVjdChvcHRzLCBiYXNlQ29uZmlnKTtcbiAgfSk7XG5cbiAgX2V4dHJhVmFsaWRhdGUgPSBleHRyYVZhbGlkYXRlO1xufTtcblxuLy8gYWxsIG1vZGVzXG5cbi8vIGRvIG5vdGhpbmdcblxuLy8gc29tZSBzbWFsbCBjaGFuZ2VzLlxudmFyIHNtYWxsQ2hhbmdlQXJyYXkgPSBbJ21lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnB1bGxSZWZyZXNoLnRpcHMnLCAnbWVyZ2VkT3B0aW9ucy52dWVzY3JvbGwucHVzaExvYWQudGlwcycsICdtZXJnZWRPcHRpb25zLnZ1ZXNjcm9sbC5zY3JvbGxlci5kaXNhYmxlJywgJ21lcmdlZE9wdGlvbnMucmFpbCcsICdtZXJnZWRPcHRpb25zLmJhciddO1xuLy8gcmVmcmVzaC9sb2FkIGRvbSByZWYva2V5Li4uXG5cbnZhciBzY3JvbGxNYXAgPSB7XG4gIHZlcnRpY2FsOiB7XG4gICAgc2l6ZTogJ2hlaWdodCcsXG4gICAgb3BzU2l6ZTogJ3dpZHRoJyxcbiAgICBwb3NOYW1lOiAndG9wJyxcbiAgICBvcHBvc05hbWU6ICdib3R0b20nLFxuICAgIHNpZGVQb3NOYW1lOiAncmlnaHQnLFxuICAgIHBhZ2U6ICdwYWdlWScsXG4gICAgc2Nyb2xsOiAnc2Nyb2xsVG9wJyxcbiAgICBzY3JvbGxTaXplOiAnc2Nyb2xsSGVpZ2h0JyxcbiAgICBvZmZzZXQ6ICdvZmZzZXRIZWlnaHQnLFxuICAgIGNsaWVudDogJ2NsaWVudFknLFxuICAgIGF4aXM6ICdZJyxcbiAgICBzY3JvbGxCdXR0b246IHtcbiAgICAgIHN0YXJ0OiAndG9wJyxcbiAgICAgIGVuZDogJ2JvdHRvbSdcbiAgICB9XG4gIH0sXG4gIGhvcml6b250YWw6IHtcbiAgICBzaXplOiAnd2lkdGgnLFxuICAgIG9wc1NpemU6ICdoZWlnaHQnLFxuICAgIHBvc05hbWU6ICdsZWZ0JyxcbiAgICBvcHBvc05hbWU6ICdyaWdodCcsXG4gICAgc2lkZVBvc05hbWU6ICdib3R0b20nLFxuICAgIHBhZ2U6ICdwYWdlWCcsXG4gICAgc2Nyb2xsOiAnc2Nyb2xsTGVmdCcsXG4gICAgc2Nyb2xsU2l6ZTogJ3Njcm9sbFdpZHRoJyxcbiAgICBvZmZzZXQ6ICdvZmZzZXRXaWR0aCcsXG4gICAgY2xpZW50OiAnY2xpZW50WCcsXG4gICAgYXhpczogJ1gnLFxuICAgIHNjcm9sbEJ1dHRvbjoge1xuICAgICAgc3RhcnQ6ICdsZWZ0JyxcbiAgICAgIGVuZDogJ3JpZ2h0J1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGdsb2JhbCkge1xuICAvLyBDaGVjayBmb3IgcmVxdWVzdCBhbmltYXRpb24gRnJhbWUgc3VwcG9ydFxuICB2YXIgcmVxdWVzdEZyYW1lID0gZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnbG9iYWwud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdsb2JhbC5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZ2xvYmFsLm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gIHZhciBpc05hdGl2ZSA9ICEhcmVxdWVzdEZyYW1lO1xuXG4gIGlmIChyZXF1ZXN0RnJhbWUgJiYgIS9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcXChcXClcXHMqXFx7XFxzKlxcW25hdGl2ZSBjb2RlXFxdXFxzKlxcfS9pLnRlc3QocmVxdWVzdEZyYW1lLnRvU3RyaW5nKCkpKSB7XG4gICAgaXNOYXRpdmUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc05hdGl2ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2ssIHJvb3QpIHtcbiAgICAgIHJlcXVlc3RGcmFtZShjYWxsYmFjaywgcm9vdCk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBUQVJHRVRfRlBTID0gNjA7XG4gIHZhciByZXF1ZXN0cyA9IHt9O1xuICB2YXIgcmFmSGFuZGxlID0gMTtcbiAgdmFyIGludGVydmFsSGFuZGxlID0gbnVsbDtcbiAgdmFyIGxhc3RBY3RpdmUgPSArbmV3IERhdGUoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGNhbGxiYWNrSGFuZGxlID0gcmFmSGFuZGxlKys7XG5cbiAgICAvLyBTdG9yZSBjYWxsYmFja1xuICAgIHJlcXVlc3RzW2NhbGxiYWNrSGFuZGxlXSA9IGNhbGxiYWNrO1xuXG4gICAgLy8gQ3JlYXRlIHRpbWVvdXQgYXQgZmlyc3QgcmVxdWVzdFxuICAgIGlmIChpbnRlcnZhbEhhbmRsZSA9PT0gbnVsbCkge1xuICAgICAgaW50ZXJ2YWxIYW5kbGUgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aW1lID0gK25ldyBEYXRlKCk7XG4gICAgICAgIHZhciBjdXJyZW50UmVxdWVzdHMgPSByZXF1ZXN0cztcblxuICAgICAgICAvLyBSZXNldCBkYXRhIHN0cnVjdHVyZSBiZWZvcmUgZXhlY3V0aW5nIGNhbGxiYWNrc1xuICAgICAgICByZXF1ZXN0cyA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50UmVxdWVzdHMpIHtcbiAgICAgICAgICBpZiAoY3VycmVudFJlcXVlc3RzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZXF1ZXN0c1trZXldKHRpbWUpO1xuICAgICAgICAgICAgbGFzdEFjdGl2ZSA9IHRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgdGltZW91dCB3aGVuIG5vdGhpbmcgaGFwcGVucyBmb3IgYSBjZXJ0YWluXG4gICAgICAgIC8vIHBlcmlvZCBvZiB0aW1lXG4gICAgICAgIGlmICh0aW1lIC0gbGFzdEFjdGl2ZSA+IDI1MDApIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSGFuZGxlKTtcbiAgICAgICAgICBpbnRlcnZhbEhhbmRsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDAgLyBUQVJHRVRfRlBTKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbGJhY2tIYW5kbGU7XG4gIH07XG59XG5cbnZhciBjb2xvckNhY2hlID0ge307XG52YXIgcmdiUmVnID0gL3JnYlxcKC87XG52YXIgZXh0cmFjdFJnYkNvbG9yID0gL3JnYlxcKCguKilcXCkvO1xuXG4vLyBUcmFuc2Zvcm0gYSBjb21tb24gY29sb3IgaW50IG9hIGByZ2JBYCBjb2xvclxuZnVuY3Rpb24gZ2V0UmdiQUNvbG9yKGNvbG9yLCBvcGFjaXR5KSB7XG4gIHZhciBpZCA9IGNvbG9yICsgJyYnICsgb3BhY2l0eTtcbiAgaWYgKGNvbG9yQ2FjaGVbaWRdKSB7XG4gICAgcmV0dXJuIGNvbG9yQ2FjaGVbaWRdO1xuICB9XG5cbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuc3R5bGUuYmFja2dyb3VuZCA9IGNvbG9yO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gIHZhciBjb21wdXRlZENvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZGl2KS5iYWNrZ3JvdW5kQ29sb3I7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFyZ2JSZWcudGVzdChjb21wdXRlZENvbG9yKSkge1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIHJldHVybiBjb2xvckNhY2hlW2lkXSA9ICdyZ2JhKCcgKyBleHRyYWN0UmdiQ29sb3IuZXhlYyhjb21wdXRlZENvbG9yKVsxXSArICcsICcgKyBvcGFjaXR5ICsgJyknO1xufVxuXG52YXIgYmFyID0ge1xuICBuYW1lOiAnYmFyJyxcbiAgcHJvcHM6IHtcbiAgICBvcHM6IE9iamVjdCxcbiAgICBzdGF0ZTogT2JqZWN0LFxuICAgIGhpZGVCYXI6IEJvb2xlYW4sXG4gICAgb3RoZXJCYXJIaWRlOiBCb29sZWFuLFxuICAgIHR5cGU6IFN0cmluZ1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGJhcjogZnVuY3Rpb24gYmFyKCkge1xuICAgICAgcmV0dXJuIHNjcm9sbE1hcFt0aGlzLnR5cGVdO1xuICAgIH0sXG4gICAgYmFyU2l6ZTogZnVuY3Rpb24gYmFyU2l6ZSgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnN0YXRlLnNpemUsIHRoaXMub3BzLmJhci5taW5TaXplKTtcbiAgICB9LFxuICAgIGJhclJhdGlvOiBmdW5jdGlvbiBiYXJSYXRpbygpIHtcbiAgICAgIHJldHVybiAoMSAtIHRoaXMuYmFyU2l6ZSkgLyAoMSAtIHRoaXMuc3RhdGUuc2l6ZSk7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgdmFyIF9zdHlsZSwgX3N0eWxlMiwgX2JhclN0eWxlO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvKiogR2V0IHJnYkEgZm9ybWF0IGJhY2tncm91bmQgY29sb3IgKi9cbiAgICB2YXIgcmFpbEJhY2tncm91bmRDb2xvciA9IGdldFJnYkFDb2xvcih2bS5vcHMucmFpbC5iYWNrZ3JvdW5kLCB2bS5vcHMucmFpbC5vcGFjaXR5KTtcblxuICAgIGlmICghdGhpcy50b3VjaE1hbmFnZXIpIHtcbiAgICAgIHRoaXMudG91Y2hNYW5hZ2VyID0gbmV3IHRvdWNoTWFuYWdlcigpO1xuICAgIH1cblxuICAgIC8qKiBSYWlsIERhdGEgKi9cbiAgICB2YXIgcmFpbFNpemUgPSB2bS5vcHMucmFpbC5zaXplO1xuICAgIHZhciBlbmRQb3MgPSB2bS5vdGhlckJhckhpZGUgPyAwIDogcmFpbFNpemU7XG4gICAgdmFyIHRvdWNoT2JqID0gdm0udG91Y2hNYW5hZ2VyLmdldFRvdWNoT2JqZWN0KCk7XG4gICAgdmFyIHJhaWwgPSB7XG4gICAgICBjbGFzczogJ19fcmFpbC1pcy0nICsgdm0udHlwZSxcbiAgICAgIHN0eWxlOiAoX3N0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgJ3otaW5kZXgnOiAnMScsXG5cbiAgICAgICAgYm9yZGVyUmFkaXVzOiB2bS5vcHMucmFpbC5zcGVjaWZ5Qm9yZGVyUmFkaXVzIHx8IHJhaWxTaXplLFxuICAgICAgICBiYWNrZ3JvdW5kOiByYWlsQmFja2dyb3VuZENvbG9yLFxuICAgICAgICBib3JkZXI6IHZtLm9wcy5yYWlsLmJvcmRlclxuICAgICAgfSwgZGVmaW5lUHJvcGVydHkoX3N0eWxlLCB2bS5iYXIub3BzU2l6ZSwgcmFpbFNpemUpLCBkZWZpbmVQcm9wZXJ0eShfc3R5bGUsIHZtLmJhci5wb3NOYW1lLCB2bS5vcHMucmFpbFsnZ3V0dGVyT2ZFbmRzJ10gfHwgMCksIGRlZmluZVByb3BlcnR5KF9zdHlsZSwgdm0uYmFyLm9wcG9zTmFtZSwgdm0ub3BzLnJhaWxbJ2d1dHRlck9mRW5kcyddIHx8IGVuZFBvcyksIGRlZmluZVByb3BlcnR5KF9zdHlsZSwgdm0uYmFyLnNpZGVQb3NOYW1lLCB2bS5vcHMucmFpbFsnZ3V0dGVyT2ZTaWRlJ10pLCBfc3R5bGUpXG4gICAgfTtcblxuICAgIGlmICh0b3VjaE9iaikge1xuICAgICAgdmFyIF9yYWlsJG9uO1xuXG4gICAgICByYWlsLm9uID0gKF9yYWlsJG9uID0ge30sIGRlZmluZVByb3BlcnR5KF9yYWlsJG9uLCB0b3VjaE9iai50b3VjaGVudGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZtLnNldFJhaWxIb3ZlcigpO1xuICAgICAgfSksIGRlZmluZVByb3BlcnR5KF9yYWlsJG9uLCB0b3VjaE9iai50b3VjaGxlYXZlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZtLnNldFJhaWxMZWF2ZSgpO1xuICAgICAgfSksIF9yYWlsJG9uKTtcbiAgICB9XG5cbiAgICAvLyBsZWZ0IHNwYWNlIGZvciBzY3JvbGwgYnV0dG9uXG4gICAgdmFyIGJ1dHRvblNpemUgPSB2bS5vcHMuc2Nyb2xsQnV0dG9uLmVuYWJsZSA/IHJhaWxTaXplIDogMDtcbiAgICB2YXIgYmFyV3JhcHBlciA9IHtcbiAgICAgIGNsYXNzOiAnX19iYXItd3JhcC1pcy0nICsgdm0udHlwZSxcbiAgICAgIHN0eWxlOiAoX3N0eWxlMiA9IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIGJvcmRlclJhZGl1czogdm0ub3BzLnJhaWwuc3BlY2lmeUJvcmRlclJhZGl1cyB8fCByYWlsU2l6ZVxuICAgICAgfSwgZGVmaW5lUHJvcGVydHkoX3N0eWxlMiwgdm0uYmFyLnBvc05hbWUsIGJ1dHRvblNpemUpLCBkZWZpbmVQcm9wZXJ0eShfc3R5bGUyLCB2bS5iYXIub3Bwb3NOYW1lLCBidXR0b25TaXplKSwgX3N0eWxlMiksXG4gICAgICBvbjoge31cbiAgICB9O1xuXG4gICAgdmFyIHNjcm9sbERpc3RhbmNlID0gdm0uc3RhdGUucG9zVmFsdWUgKiB2bS5zdGF0ZS5zaXplO1xuICAgIHZhciBwb3MgPSBzY3JvbGxEaXN0YW5jZSAqIHZtLmJhclJhdGlvIC8gdm0uYmFyU2l6ZTtcbiAgICB2YXIgb3BhY2l0eSA9IHZtLnN0YXRlLm9wYWNpdHk7XG4gICAgdmFyIHBhcmVudCA9IGdldFJlYWxQYXJlbnQodGhpcyk7XG5cbiAgICAvLyBzZXQgY2xhc3MgaG9va1xuICAgIHBhcmVudC5zZXRDbGFzc0hvb2sodGhpcy50eXBlID09ICd2ZXJ0aWNhbCcgPyAndkJhclZpc2libGUnIDogJ2hCYXJWaXNpYmxlJywgISFvcGFjaXR5KTtcblxuICAgIC8qKiBTY3JvbGxiYXIgc3R5bGUgKi9cbiAgICB2YXIgYmFyU3R5bGUgPSAoX2JhclN0eWxlID0ge1xuICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIG1hcmdpbjogJ2F1dG8nLFxuICAgICAgdHJhbnNpdGlvbjogJ29wYWNpdHkgMC41cycsXG4gICAgICAndXNlci1zZWxlY3QnOiAnbm9uZScsXG4gICAgICAnYm9yZGVyLXJhZGl1cyc6ICdpbmhlcml0J1xuXG4gICAgfSwgZGVmaW5lUHJvcGVydHkoX2JhclN0eWxlLCB2bS5iYXIuc2l6ZSwgdm0uYmFyU2l6ZSAqIDEwMCArICclJyksIGRlZmluZVByb3BlcnR5KF9iYXJTdHlsZSwgJ2JhY2tncm91bmQnLCB2bS5vcHMuYmFyLmJhY2tncm91bmQpLCBkZWZpbmVQcm9wZXJ0eShfYmFyU3R5bGUsIHZtLmJhci5vcHNTaXplLCB2bS5vcHMuYmFyLnNpemUpLCBkZWZpbmVQcm9wZXJ0eShfYmFyU3R5bGUsICdvcGFjaXR5Jywgb3BhY2l0eSksIGRlZmluZVByb3BlcnR5KF9iYXJTdHlsZSwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUnICsgc2Nyb2xsTWFwW3ZtLnR5cGVdLmF4aXMgKyAnKCcgKyBwb3MgKyAnJSknKSwgX2JhclN0eWxlKTtcbiAgICB2YXIgYmFyID0ge1xuICAgICAgc3R5bGU6IGJhclN0eWxlLFxuICAgICAgY2xhc3M6ICdfX2Jhci1pcy0nICsgdm0udHlwZSxcbiAgICAgIHJlZjogJ3RodW1iJyxcbiAgICAgIG9uOiB7fVxuICAgIH07XG5cbiAgICBpZiAodm0udHlwZSA9PSAndmVydGljYWwnKSB7XG4gICAgICBiYXJXcmFwcGVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgLy8gTGV0IGJhciB0byBiZSBvbiB0aGUgY2VudGVyLlxuICAgICAgYmFyLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgYmFyLnN0eWxlLnJpZ2h0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFyV3JhcHBlci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICBiYXIuc3R5bGUudG9wID0gMDtcbiAgICAgIGJhci5zdHlsZS5ib3R0b20gPSAwO1xuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAge1xuICAgICAgdmFyIF90b3VjaE9iaiA9IHRoaXMudG91Y2hNYW5hZ2VyLmdldFRvdWNoT2JqZWN0KCk7XG4gICAgICBiYXIub25bX3RvdWNoT2JqLnRvdWNoc3RhcnRdID0gdGhpcy5jcmVhdGVCYXJFdmVudCgpO1xuICAgICAgYmFyV3JhcHBlci5vbltfdG91Y2hPYmoudG91Y2hzdGFydF0gPSB0aGlzLmNyZWF0ZVRyYWNrRXZlbnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaChcbiAgICAgICdkaXYnLFxuICAgICAgcmFpbCxcbiAgICAgIFt0aGlzLmNyZWF0ZVNjcm9sbGJhckJ1dHRvbihoLCAnc3RhcnQnKSwgdGhpcy5oaWRlQmFyID8gbnVsbCA6IGgoXG4gICAgICAgICdkaXYnLFxuICAgICAgICBiYXJXcmFwcGVyLFxuICAgICAgICBbaCgnZGl2JywgYmFyKV1cbiAgICAgICksIHRoaXMuY3JlYXRlU2Nyb2xsYmFyQnV0dG9uKGgsICdlbmQnKV1cbiAgICApO1xuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0JhckRyYWdnaW5nOiBmYWxzZVxuICAgIH07XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIHNldFJhaWxIb3ZlcjogZnVuY3Rpb24gc2V0UmFpbEhvdmVyKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGdldFJlYWxQYXJlbnQodGhpcyk7XG4gICAgICB2YXIgc3RhdGUgPSBwYXJlbnQudnVlc2Nyb2xsLnN0YXRlO1xuXG4gICAgICBpZiAoIXN0YXRlLmlzUmFpbEhvdmVyKSB7XG4gICAgICAgIHN0YXRlLmlzUmFpbEhvdmVyID0gdHJ1ZTtcbiAgICAgICAgcGFyZW50LnNob3dCYXIoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldFJhaWxMZWF2ZTogZnVuY3Rpb24gc2V0UmFpbExlYXZlKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGdldFJlYWxQYXJlbnQodGhpcyk7XG4gICAgICB2YXIgc3RhdGUgPSBwYXJlbnQudnVlc2Nyb2xsLnN0YXRlO1xuXG4gICAgICBzdGF0ZS5pc1JhaWxIb3ZlciA9IGZhbHNlO1xuICAgICAgcGFyZW50LmhpZGVCYXIoKTtcbiAgICB9LFxuICAgIHNldEJhckRyYWc6IGZ1bmN0aW9uIHNldEJhckRyYWcodmFsKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL3tcbiAgICAgIHRoaXMuJGVtaXQoJ3NldEJhckRyYWcnLCB0aGlzLmlzQmFyRHJhZ2dpbmcgPSB2YWwpO1xuXG4gICAgICB2YXIgcGFyZW50ID0gZ2V0UmVhbFBhcmVudCh0aGlzKTtcbiAgICAgIC8vIHNldCBjbGFzcyBob29rXG4gICAgICBwYXJlbnQuc2V0Q2xhc3NIb29rKHRoaXMudHlwZSA9PSAndmVydGljYWwnID8gJ3ZCYXJEcmFnZ2luZycgOiAnaEJhckRyYWdnaW5nJywgISF2YWwpO1xuICAgIH0sXG4gICAgY3JlYXRlQmFyRXZlbnQ6IGZ1bmN0aW9uIGNyZWF0ZUJhckV2ZW50KCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXM7XG5cbiAgICAgIHZhciBwYXJlbnQgPSBnZXRSZWFsUGFyZW50KGN0eCk7XG4gICAgICB2YXIgdG91Y2hPYmogPSBjdHgudG91Y2hNYW5hZ2VyLmdldFRvdWNoT2JqZWN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIG1vdXNlZG93bihlKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL3tcbiAgICAgICAgdmFyIGV2ZW50ID0gY3R4LnRvdWNoTWFuYWdlci5nZXRFdmVudE9iamVjdChlKTtcbiAgICAgICAgaWYgKCFldmVudCkgcmV0dXJuO1xuXG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQgPSBldmVudFswXTtcblxuICAgICAgICBkb2N1bWVudC5vbnNlbGVjdHN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgY3R4LmF4aXNTdGFydFBvcyA9IGV2ZW50W2N0eC5iYXIuY2xpZW50XSAtIGN0eC4kcmVmc1sndGh1bWInXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtjdHguYmFyLnBvc05hbWVdO1xuXG4gICAgICAgIC8vIFRlbGwgcGFyZW50IHRoYXQgdGhlIG1vdXNlIGhhcyBiZWVuIGRvd24uXG4gICAgICAgIGN0eC5zZXRCYXJEcmFnKHRydWUpO1xuICAgICAgICBldmVudENlbnRlcihkb2N1bWVudCwgdG91Y2hPYmoudG91Y2htb3ZlLCBtb3VzZW1vdmUpO1xuICAgICAgICBldmVudENlbnRlcihkb2N1bWVudCwgdG91Y2hPYmoudG91Y2hlbmQsIG1vdXNldXApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtb3VzZW1vdmUoZSkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi97XG4gICAgICAgIGlmICghY3R4LmF4aXNTdGFydFBvcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBldmVudCA9IGN0eC50b3VjaE1hbmFnZXIuZ2V0RXZlbnRPYmplY3QoZSk7XG4gICAgICAgIGlmICghZXZlbnQpIHJldHVybjtcblxuICAgICAgICBldmVudCA9IGV2ZW50WzBdO1xuXG4gICAgICAgIHZhciB0aHVibVBhcmVudCA9IGN0eC4kcmVmcy50aHVtYi5wYXJlbnROb2RlO1xuXG4gICAgICAgIHZhciBkZWx0YSA9IGV2ZW50W2N0eC5iYXIuY2xpZW50XSAtIHRodWJtUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2N0eC5iYXIucG9zTmFtZV07XG4gICAgICAgIGRlbHRhID0gZGVsdGEgLyBjdHguYmFyUmF0aW87XG5cbiAgICAgICAgdmFyIHBlcmNlbnQgPSAoZGVsdGEgLSBjdHguYXhpc1N0YXJ0UG9zKSAvIHRodWJtUGFyZW50W2N0eC5iYXIub2Zmc2V0XTtcbiAgICAgICAgcGFyZW50LnNjcm9sbFRvKGRlZmluZVByb3BlcnR5KHt9LCBjdHguYmFyLmF4aXMudG9Mb3dlckNhc2UoKSwgcGFyZW50LnNjcm9sbFBhbmVsRWxtW2N0eC5iYXIuc2Nyb2xsU2l6ZV0gKiBwZXJjZW50KSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtb3VzZXVwKCkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi97XG4gICAgICAgIGN0eC5zZXRCYXJEcmFnKGZhbHNlKTtcbiAgICAgICAgcGFyZW50LmhpZGVCYXIoKTtcblxuICAgICAgICBkb2N1bWVudC5vbnNlbGVjdHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgY3R4LmF4aXNTdGFydFBvcyA9IDA7XG5cbiAgICAgICAgZXZlbnRDZW50ZXIoZG9jdW1lbnQsIHRvdWNoT2JqLnRvdWNobW92ZSwgbW91c2Vtb3ZlLCBmYWxzZSwgJ29mZicpO1xuICAgICAgICBldmVudENlbnRlcihkb2N1bWVudCwgdG91Y2hPYmoudG91Y2hlbmQsIG1vdXNldXAsIGZhbHNlLCAnb2ZmJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb3VzZWRvd247XG4gICAgfSxcbiAgICBjcmVhdGVUcmFja0V2ZW50OiBmdW5jdGlvbiBjcmVhdGVUcmFja0V2ZW50KCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVDbGlja1RyYWNrKGUpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGdldFJlYWxQYXJlbnQoY3R4KTtcblxuICAgICAgICB2YXIgX2N0eCRiYXIgPSBjdHguYmFyLFxuICAgICAgICAgICAgY2xpZW50ID0gX2N0eCRiYXIuY2xpZW50LFxuICAgICAgICAgICAgb2Zmc2V0ID0gX2N0eCRiYXIub2Zmc2V0LFxuICAgICAgICAgICAgcG9zTmFtZSA9IF9jdHgkYmFyLnBvc05hbWUsXG4gICAgICAgICAgICBheGlzID0gX2N0eCRiYXIuYXhpcztcblxuICAgICAgICB2YXIgdGh1bWIgPSBjdHguJHJlZnNbJ3RodW1iJ107XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRodW1iKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGJhck9mZnNldCA9IHRodW1iW29mZnNldF07XG4gICAgICAgIHZhciBldmVudCA9IGN0eC50b3VjaE1hbmFnZXIuZ2V0RXZlbnRPYmplY3QoZSlbMF07XG5cbiAgICAgICAgdmFyIHBlcmNlbnQgPSAoZXZlbnRbY2xpZW50XSAtIGUuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtwb3NOYW1lXSAtIGJhck9mZnNldCAvIDIpIC8gKGUuY3VycmVudFRhcmdldFtvZmZzZXRdIC0gYmFyT2Zmc2V0KTtcblxuICAgICAgICBwYXJlbnQuc2Nyb2xsVG8oZGVmaW5lUHJvcGVydHkoe30sIGF4aXMudG9Mb3dlckNhc2UoKSwgcGVyY2VudCAqIDEwMCArICclJykpO1xuICAgICAgfTtcbiAgICB9LFxuXG5cbiAgICAvLyBTY3JvbGxidXRvbiByZWxhdGl2ZSB0aGluZ3MuLi5cbiAgICBjcmVhdGVTY3JvbGxiYXJCdXR0b246IGZ1bmN0aW9uIGNyZWF0ZVNjcm9sbGJhckJ1dHRvbihoLCB0eXBlIC8qIHN0YXJ0IG9yIGVuZCAgKi8pIHtcbiAgICAgIHZhciBfc3R5bGUzO1xuXG4gICAgICB2YXIgYmFyQ29udGV4dCA9IHRoaXM7XG5cbiAgICAgIGlmICghYmFyQ29udGV4dC5vcHMuc2Nyb2xsQnV0dG9uLmVuYWJsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpemUgPSBiYXJDb250ZXh0Lm9wcy5yYWlsLnNpemU7XG4gICAgICB2YXIgX2JhckNvbnRleHQkb3BzJHNjcm9sID0gYmFyQ29udGV4dC5vcHMuc2Nyb2xsQnV0dG9uLFxuICAgICAgICAgIG9wYWNpdHkgPSBfYmFyQ29udGV4dCRvcHMkc2Nyb2wub3BhY2l0eSxcbiAgICAgICAgICBiYWNrZ3JvdW5kID0gX2JhckNvbnRleHQkb3BzJHNjcm9sLmJhY2tncm91bmQ7XG5cbiAgICAgIHZhciBib3JkZXJDb2xvciA9IGdldFJnYkFDb2xvcihiYWNrZ3JvdW5kLCBvcGFjaXR5KTtcblxuICAgICAgdmFyIHdyYXBwZXJQcm9wcyA9IHtcbiAgICAgICAgY2xhc3M6IFsnX19iYXItYnV0dG9uJywgJ19fYmFyLWJ1dHRvbi1pcy0nICsgYmFyQ29udGV4dC50eXBlICsgJy0nICsgdHlwZV0sXG4gICAgICAgIHN0eWxlOiAoX3N0eWxlMyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfc3R5bGUzLCBiYXJDb250ZXh0LmJhci5zY3JvbGxCdXR0b25bdHlwZV0sIDApLCBkZWZpbmVQcm9wZXJ0eShfc3R5bGUzLCAnd2lkdGgnLCBzaXplKSwgZGVmaW5lUHJvcGVydHkoX3N0eWxlMywgJ2hlaWdodCcsIHNpemUpLCBkZWZpbmVQcm9wZXJ0eShfc3R5bGUzLCAncG9zaXRpb24nLCAnYWJzb2x1dGUnKSwgZGVmaW5lUHJvcGVydHkoX3N0eWxlMywgJ2N1cnNvcicsICdwb2ludGVyJyksIGRlZmluZVByb3BlcnR5KF9zdHlsZTMsICdkaXNwbGF5JywgJ3RhYmxlJyksIF9zdHlsZTMpLFxuICAgICAgICByZWY6IHR5cGVcbiAgICAgIH07XG5cbiAgICAgIHZhciBpbm5lclByb3BzID0ge1xuICAgICAgICBjbGFzczogJ19fYmFyLWJ1dHRvbi1pbm5lcicsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgYm9yZGVyOiAnY2FsYygnICsgc2l6ZSArICcgLyAyLjUpIHNvbGlkIHRyYW5zcGFyZW50JyxcbiAgICAgICAgICB3aWR0aDogJzAnLFxuICAgICAgICAgIGhlaWdodDogJzAnLFxuICAgICAgICAgIG1hcmdpbjogJ2F1dG8nLFxuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIHRvcDogJzAnLFxuICAgICAgICAgIGJvdHRvbTogJzAnLFxuICAgICAgICAgIHJpZ2h0OiAnMCcsXG4gICAgICAgICAgbGVmdDogJzAnXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7fVxuICAgICAgfTtcblxuICAgICAgaWYgKGJhckNvbnRleHQudHlwZSA9PSAndmVydGljYWwnKSB7XG4gICAgICAgIGlmICh0eXBlID09ICdzdGFydCcpIHtcbiAgICAgICAgICBpbm5lclByb3BzLnN0eWxlWydib3JkZXItYm90dG9tLWNvbG9yJ10gPSBib3JkZXJDb2xvcjtcbiAgICAgICAgICBpbm5lclByb3BzLnN0eWxlWyd0cmFuc2Zvcm0nXSA9ICd0cmFuc2xhdGVZKC0yNSUpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbm5lclByb3BzLnN0eWxlWydib3JkZXItdG9wLWNvbG9yJ10gPSBib3JkZXJDb2xvcjtcbiAgICAgICAgICBpbm5lclByb3BzLnN0eWxlWyd0cmFuc2Zvcm0nXSA9ICd0cmFuc2xhdGVZKDI1JSknO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZSA9PSAnc3RhcnQnKSB7XG4gICAgICAgICAgaW5uZXJQcm9wcy5zdHlsZVsnYm9yZGVyLXJpZ2h0LWNvbG9yJ10gPSBib3JkZXJDb2xvcjtcbiAgICAgICAgICBpbm5lclByb3BzLnN0eWxlWyd0cmFuc2Zvcm0nXSA9ICd0cmFuc2xhdGVYKC0yNSUpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbm5lclByb3BzLnN0eWxlWydib3JkZXItbGVmdC1jb2xvciddID0gYm9yZGVyQ29sb3I7XG4gICAgICAgICAgaW5uZXJQcm9wcy5zdHlsZVsndHJhbnNmb3JtJ10gPSAndHJhbnNsYXRlWCgyNSUpJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAge1xuICAgICAgICB2YXIgdG91Y2hPYmogPSB0aGlzLnRvdWNoTWFuYWdlci5nZXRUb3VjaE9iamVjdCgpO1xuICAgICAgICBpbm5lclByb3BzLm9uW3RvdWNoT2JqLnRvdWNoc3RhcnRdID0gdGhpcy5jcmVhdGVTY3JvbGxCdXR0b25FdmVudCh0eXBlLCB0b3VjaE9iaik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoKFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgd3JhcHBlclByb3BzLFxuICAgICAgICBbaCgnZGl2JywgaW5uZXJQcm9wcyldXG4gICAgICApO1xuICAgIH0sXG4gICAgY3JlYXRlU2Nyb2xsQnV0dG9uRXZlbnQ6IGZ1bmN0aW9uIGNyZWF0ZVNjcm9sbEJ1dHRvbkV2ZW50KHR5cGUsIHRvdWNoT2JqKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcztcbiAgICAgIHZhciBwYXJlbnQgPSBnZXRSZWFsUGFyZW50KGN0eCk7XG5cbiAgICAgIHZhciBfY3R4JG9wcyRzY3JvbGxCdXR0b24gPSBjdHgub3BzLnNjcm9sbEJ1dHRvbixcbiAgICAgICAgICBzdGVwID0gX2N0eCRvcHMkc2Nyb2xsQnV0dG9uLnN0ZXAsXG4gICAgICAgICAgbW91c2Vkb3duU3RlcCA9IF9jdHgkb3BzJHNjcm9sbEJ1dHRvbi5tb3VzZWRvd25TdGVwO1xuXG5cbiAgICAgIHZhciBzdGVwV2l0aERpcmVjdGlvbiA9IHR5cGUgPT0gJ3N0YXJ0JyA/IC1zdGVwIDogc3RlcDtcbiAgICAgIHZhciBtb3VzZWRvd25TdGVwV2l0aERpcmVjdGlvbiA9IHR5cGUgPT0gJ3N0YXJ0JyA/IC1tb3VzZWRvd25TdGVwIDogbW91c2Vkb3duU3RlcDtcbiAgICAgIHZhciByZWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUod2luZG93KTtcblxuICAgICAgLy8gYmFyIHByb3BzOiB0eXBlXG4gICAgICB2YXIgYmFyVHlwZSA9IGN0eC50eXBlO1xuXG4gICAgICB2YXIgaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgIHZhciBpc01vdXNlb3V0ID0gdHJ1ZTtcbiAgICAgIHZhciB0aW1lb3V0SWQgPSB2b2lkIDA7XG5cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0KGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cbiAgICAgICAgaWYgKDMgPT0gZS53aGljaCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBjbGFzcyBob29rXG4gICAgICAgIHBhcmVudC5zZXRDbGFzc0hvb2soJ2NsaWtpbmcnICsgYmFyVHlwZSArIHR5cGUgKyAnQnV0dG9uJywgdHJ1ZSk7XG5cbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlzTW91c2VvdXQgPSBmYWxzZTtcblxuICAgICAgICBwYXJlbnQuc2Nyb2xsQnkoZGVmaW5lUHJvcGVydHkoe30sICdkJyArIGN0eC5iYXIuYXhpcy50b0xvd2VyQ2FzZSgpLCBzdGVwV2l0aERpcmVjdGlvbikpO1xuXG4gICAgICAgIGV2ZW50Q2VudGVyKGRvY3VtZW50LCB0b3VjaE9iai50b3VjaGVuZCwgZW5kUHJlc3MsIGZhbHNlKTtcblxuICAgICAgICBpZiAodG91Y2hPYmoudG91Y2hzdGFydCA9PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgIHZhciBlbG0gPSBjdHguJHJlZnNbdHlwZV07XG4gICAgICAgICAgZXZlbnRDZW50ZXIoZWxtLCAnbW91c2VlbnRlcicsIGVudGVyLCBmYWxzZSk7XG4gICAgICAgICAgZXZlbnRDZW50ZXIoZWxtLCAnbW91c2VsZWF2ZScsIGxlYXZlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL3tcbiAgICAgICAgICBpc01vdXNlRG93biA9IHRydWU7XG4gICAgICAgICAgcmVmKHByZXNzaW5nLCB3aW5kb3cpO1xuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwcmVzc2luZygpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICove1xuICAgICAgICBpZiAoaXNNb3VzZURvd24gJiYgIWlzTW91c2VvdXQpIHtcbiAgICAgICAgICBwYXJlbnQuc2Nyb2xsQnkoZGVmaW5lUHJvcGVydHkoe30sICdkJyArIGN0eC5iYXIuYXhpcy50b0xvd2VyQ2FzZSgpLCBtb3VzZWRvd25TdGVwV2l0aERpcmVjdGlvbiksIGZhbHNlKTtcbiAgICAgICAgICByZWYocHJlc3NpbmcsIHdpbmRvdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW5kUHJlc3MoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBpc01vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICBldmVudENlbnRlcihkb2N1bWVudCwgdG91Y2hPYmoudG91Y2hlbmQsIGVuZFByZXNzLCBmYWxzZSwgJ29mZicpO1xuXG4gICAgICAgIGlmICh0b3VjaE9iai50b3VjaHN0YXJ0ID09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgdmFyIGVsbSA9IGN0eC4kcmVmc1t0eXBlXTtcbiAgICAgICAgICBldmVudENlbnRlcihlbG0sICdtb3VzZWVudGVyJywgZW50ZXIsIGZhbHNlLCAnb2ZmJyk7XG4gICAgICAgICAgZXZlbnRDZW50ZXIoZWxtLCAnbW91c2VsZWF2ZScsIGxlYXZlLCBmYWxzZSwgJ29mZicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50LnNldENsYXNzSG9vaygnY2xpa2luZycgKyBiYXJUeXBlICsgdHlwZSArICdCdXR0b24nLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVudGVyKCkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi97XG4gICAgICAgIGlzTW91c2VvdXQgPSBmYWxzZTtcbiAgICAgICAgcHJlc3NpbmcoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGVhdmUoKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL3tcbiAgICAgICAgaXNNb3VzZW91dCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldEJhckRhdGEodm0sIHR5cGUpIHtcbiAgdmFyIGF4aXMgPSBzY3JvbGxNYXBbdHlwZV0uYXhpcztcbiAgLyoqIHR5cGUuY2hhckF0KDApID0gdkJhci9oQmFyICovXG4gIHZhciBiYXJUeXBlID0gdHlwZS5jaGFyQXQoMCkgKyAnQmFyJztcblxuICB2YXIgaGlkZUJhciA9ICF2bS5iYXJbYmFyVHlwZV0uc3RhdGUuc2l6ZSB8fCAhdm0ubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbFsnc2Nyb2xsaW5nJyArIGF4aXNdIHx8IHZtLnJlZnJlc2hMb2FkICYmIHR5cGUgIT09ICd2ZXJ0aWNhbCcgfHwgdm0ubWVyZ2VkT3B0aW9ucy5iYXIuZGlzYWJsZTtcblxuICB2YXIga2VlcFNob3dSYWlsID0gdm0ubWVyZ2VkT3B0aW9ucy5yYWlsLmtlZXBTaG93O1xuXG4gIGlmIChoaWRlQmFyICYmICFrZWVwU2hvd1JhaWwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaGlkZUJhcjogaGlkZUJhcixcbiAgICBwcm9wczoge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIG9wczoge1xuICAgICAgICBiYXI6IHZtLm1lcmdlZE9wdGlvbnMuYmFyLFxuICAgICAgICByYWlsOiB2bS5tZXJnZWRPcHRpb25zLnJhaWwsXG4gICAgICAgIHNjcm9sbEJ1dHRvbjogdm0ubWVyZ2VkT3B0aW9ucy5zY3JvbGxCdXR0b25cbiAgICAgIH0sXG4gICAgICBzdGF0ZTogdm0uYmFyW2JhclR5cGVdLnN0YXRlLFxuICAgICAgaGlkZUJhcjogaGlkZUJhclxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIHNldEJhckRyYWc6IHZtLnNldEJhckRyYWdcbiAgICB9LFxuICAgIHJlZjogdHlwZSArICdCYXInLFxuICAgIGtleTogdHlwZVxuICB9O1xufVxuXG4vKipcbiAqIGNyZWF0ZSBiYXJzXG4gKlxuICogQHBhcmFtIHthbnl9IHNpemVcbiAqIEBwYXJhbSB7YW55fSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhcihoLCB2bSkge1xuICB2YXIgdmVydGljYWxCYXJQcm9wcyA9IGdldEJhckRhdGEodm0sICd2ZXJ0aWNhbCcpO1xuICB2YXIgaG9yaXpvbnRhbEJhclByb3BzID0gZ2V0QmFyRGF0YSh2bSwgJ2hvcml6b250YWwnKTtcblxuICAvLyBzZXQgY2xhc3MgaG9va3NcbiAgdm0uc2V0Q2xhc3NIb29rKCdoYXNWQmFyJywgISEodmVydGljYWxCYXJQcm9wcyAmJiAhdmVydGljYWxCYXJQcm9wcy5oaWRlQmFyKSk7XG4gIHZtLnNldENsYXNzSG9vaygnaGFzSEJhcicsICEhKGhvcml6b250YWxCYXJQcm9wcyAmJiAhaG9yaXpvbnRhbEJhclByb3BzLmhpZGVCYXIpKTtcblxuICByZXR1cm4gW3ZlcnRpY2FsQmFyUHJvcHMgPyBoKCdiYXInLCBfZXh0ZW5kcyh7fSwgdmVydGljYWxCYXJQcm9wcywge1xuICAgIHByb3BzOiBfZXh0ZW5kcyh7IG90aGVyQmFySGlkZTogIWhvcml6b250YWxCYXJQcm9wcyB9LCB2ZXJ0aWNhbEJhclByb3BzLnByb3BzKVxuICB9KSkgOiBudWxsLCBob3Jpem9udGFsQmFyUHJvcHMgPyBoKCdiYXInLCBfZXh0ZW5kcyh7fSwgaG9yaXpvbnRhbEJhclByb3BzLCB7XG4gICAgcHJvcHM6IF9leHRlbmRzKHsgb3RoZXJCYXJIaWRlOiAhdmVydGljYWxCYXJQcm9wcyB9LCBob3Jpem9udGFsQmFyUHJvcHMucHJvcHMpXG4gIH0pKSA6IG51bGxdO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgbGlrZSBhIEhPQywgSXQgZXh0cmFjdHMgdGhlIGNvbW1vbiBwYXJ0cyBvZiB0aGVcbiAqIG5hdGl2ZS1tb2RlLCBzbGlkZS1tb2RlIGFuZCBtaXgtbW9kZS5cbiAqIEVhY2ggbW9kZSBtdXN0IGltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG4gKiAxLiByZWZyZXNoSW50ZXJuYWxTdGF0dXMgOiB1c2UgdG8gcmVmcmVzaCB0aGUgY29tcG9uZW50XG4gKiAyLiBkZXN0cm95IDogRGVzdHJveSBzb21lIHJlZ2lzdHJ5ZWQgZXZlbnRzIGJlZm9yZSBjb21wb25lbnQgZGVzdHJveS5cbiAqIDMuIHVwZGF0ZUJhclN0YXRlQW5kRW1pdEV2ZW50OiB1c2UgdG8gdXBkYXRlIGJhciBzdGF0ZXMgYW5kIGVtaXQgZXZlbnRzLlxuICovXG5cbnZhciBjcmVhdGVDb21wb25lbnQgPSBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQoX3JlZikge1xuICB2YXIgX3JlbmRlciA9IF9yZWYucmVuZGVyLFxuICAgICAgY29tcG9uZW50cyA9IF9yZWYuY29tcG9uZW50cyxcbiAgICAgIG1peGlucyA9IF9yZWYubWl4aW5zO1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICd2dWVTY3JvbGwnLFxuICAgIHByb3BzOiB7XG4gICAgICBvcHM6IHsgdHlwZTogT2JqZWN0IH1cbiAgICB9LFxuICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgbWl4aW5zOiBbYXBpXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoW10uY29uY2F0KG1peGlucykpKSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLyoqXG4gICAgICAgKiBCZWdpbiB0byBtZXJnZSBvcHRpb25zXG4gICAgICAgKi9cblxuICAgICAgdmFyIF9nZmMgPSBtZXJnZU9iamVjdCh0aGlzLiR2dWVzY3JvbGxDb25maWcgfHwge30sIHt9KTtcbiAgICAgIHZhciBvcHMgPSBtZXJnZU9iamVjdChiYXNlQ29uZmlnLCBfZ2ZjKTtcblxuICAgICAgdGhpcy4kb3B0aW9ucy5wcm9wc0RhdGEub3BzID0gdGhpcy4kb3B0aW9ucy5wcm9wc0RhdGEub3BzIHx8IHt9O1xuICAgICAgT2JqZWN0LmtleXModGhpcy4kb3B0aW9ucy5wcm9wc0RhdGEub3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAge1xuICAgICAgICAgIGRlZmluZVJlYWN0aXZlKF90aGlzLm1lcmdlZE9wdGlvbnMsIGtleSwgX3RoaXMuJG9wdGlvbnMucHJvcHNEYXRhLm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gZnJvbSBvcHMgdG8gbWVyZ2VkT3B0aW9uc1xuICAgICAgbWVyZ2VPYmplY3Qob3BzLCB0aGlzLm1lcmdlZE9wdGlvbnMpO1xuXG4gICAgICB0aGlzLl9pc1Z1ZXNjcm9sbFJvb3QgPSB0cnVlO1xuICAgICAgdGhpcy5yZW5kZXJFcnJvciA9IHZhbGlkYXRlT3BzKHRoaXMubWVyZ2VkT3B0aW9ucyk7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgaWYgKHZtLnJlbmRlckVycm9yKSB7XG4gICAgICAgIHJldHVybiBoKCdkaXYnLCBbW3ZtLiRzbG90c1snZGVmYXVsdCddXV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZtLnRvdWNoTWFuYWdlcikgdm0udG91Y2hNYW5hZ2VyID0gbmV3IHRvdWNoTWFuYWdlcigpO1xuXG4gICAgICAvLyB2dWVzY3JvbGwgZGF0YVxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgaGVpZ2h0OiB2bS52dWVzY3JvbGwuc3RhdGUuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB2bS52dWVzY3JvbGwuc3RhdGUud2lkdGgsXG4gICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3M6IF9leHRlbmRzKHsgX192dWVzY3JvbGw6IHRydWUgfSwgdm0uY2xhc3NIb29rcylcbiAgICAgIH07XG5cbiAgICAgIHZhciB0b3VjaE9iaiA9IHZtLnRvdWNoTWFuYWdlci5nZXRUb3VjaE9iamVjdCgpO1xuICAgICAgaWYgKHRvdWNoT2JqKSB7XG4gICAgICAgIHZhciBfZGF0YSRvbjtcblxuICAgICAgICBkYXRhLm9uID0gKF9kYXRhJG9uID0ge30sIGRlZmluZVByb3BlcnR5KF9kYXRhJG9uLCB0b3VjaE9iai50b3VjaGVudGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdm0udnVlc2Nyb2xsLnN0YXRlLnBvaW50ZXJMZWF2ZSA9IGZhbHNlO1xuICAgICAgICAgIHZtLnVwZGF0ZUJhclN0YXRlQW5kRW1pdEV2ZW50KCk7XG5cbiAgICAgICAgICB2bS5zZXRDbGFzc0hvb2soJ21vdXNlRW50ZXInLCB0cnVlKTtcbiAgICAgICAgfSksIGRlZmluZVByb3BlcnR5KF9kYXRhJG9uLCB0b3VjaE9iai50b3VjaGxlYXZlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdm0udnVlc2Nyb2xsLnN0YXRlLnBvaW50ZXJMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgdm0uaGlkZUJhcigpO1xuXG4gICAgICAgICAgdm0uc2V0Q2xhc3NIb29rKCdtb3VzZUVudGVyJywgZmFsc2UpO1xuICAgICAgICB9KSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb24sIHRvdWNoT2JqLnRvdWNobW92ZSwgZnVuY3Rpb24gKCkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi97XG4gICAgICAgICAgdm0udnVlc2Nyb2xsLnN0YXRlLnBvaW50ZXJMZWF2ZSA9IGZhbHNlO1xuICAgICAgICAgIHZtLnVwZGF0ZUJhclN0YXRlQW5kRW1pdEV2ZW50KCk7XG4gICAgICAgIH0pLCBfZGF0YSRvbik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaCA9IFtfcmVuZGVyKGgsIHZtKV0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KGNyZWF0ZUJhcihoLCB2bSkpKTtcblxuICAgICAgdmFyIF9jdXN0b21Db250YWluZXIgPSB0aGlzLiRzbG90c1snc2Nyb2xsLWNvbnRhaW5lciddO1xuICAgICAgaWYgKF9jdXN0b21Db250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIGluc2VydENoaWxkcmVuSW50b1Nsb3QoaCwgX2N1c3RvbUNvbnRhaW5lciwgY2gsIGRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIFtjaF1cbiAgICAgICk7XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5yZW5kZXJFcnJvcikge1xuICAgICAgICB0aGlzLmluaXRWYXJpYWJsZXMoKTtcbiAgICAgICAgdGhpcy5pbml0V2F0Y2hPcHNDaGFuZ2UoKTtcbiAgICAgICAgLy8gQ2FsbCBleHRlcm5hbCBtZXJnZWQgQXBpXG4gICAgICAgIHRoaXMucmVmcmVzaEludGVybmFsU3RhdHVzKCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVkQ2JzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5zY3JvbGxUb0FuY2hvcigpO1xuICAgICAgICAgIC8vIG5lZWQgdG8gcmVmbG93IHRvIGRlYWwgd2l0aCB0aGVcbiAgICAgICAgICAvLyBsYXRlc3QgdGhpbmcuXG4gICAgICAgICAgX3RoaXMyLnVwZGF0ZUJhclN0YXRlQW5kRW1pdEV2ZW50KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLnVwZGF0ZWRDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgY2IuY2FsbChfdGhpczMpO1xuICAgICAgfSk7XG4gICAgICAvLyBDbGVhclxuICAgICAgdGhpcy51cGRhdGVkQ2JzID0gW107XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveSkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvKiogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBDb21wdXRlZCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgIGNvbXB1dGVkOiB7XG4gICAgICBzY3JvbGxQYW5lbEVsbTogZnVuY3Rpb24gc2Nyb2xsUGFuZWxFbG0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzWydzY3JvbGxQYW5lbCddLl9pc1Z1ZSA/IHRoaXMuJHJlZnNbJ3Njcm9sbFBhbmVsJ10uJGVsIDogdGhpcy4kcmVmc1snc2Nyb2xsUGFuZWwnXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2dWVzY3JvbGw6IHtcbiAgICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBwb2ludGVyTGVhdmU6IHRydWUsXG4gICAgICAgICAgICBpc1JhaWxIb3ZlcjogZmFsc2UsXG4gICAgICAgICAgICAvKiogRGVmYXVsdCBzaXplU3RyYXRlZ2llcyAqL1xuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgLy8gY3VycmVudCBzaXplIHN0cmF0ZWd5XG4gICAgICAgICAgICBjdXJyZW50U2l6ZVN0cmF0ZWd5OiAncGVyY2VudCcsXG4gICAgICAgICAgICBjdXJyZW50U2Nyb2xsU3RhdGU6IG51bGwsXG4gICAgICAgICAgICBjdXJyZW50U2Nyb2xsSW5mbzogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYmFyOiB7XG4gICAgICAgICAgdkJhcjoge1xuICAgICAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgICAgcG9zVmFsdWU6IDAsXG4gICAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGhCYXI6IHtcbiAgICAgICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICAgIHBvc1ZhbHVlOiAwLFxuICAgICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXJnZWRPcHRpb25zOiB7XG4gICAgICAgICAgdnVlc2Nyb2xsOiB7fSxcbiAgICAgICAgICBzY3JvbGxQYW5lbDoge30sXG4gICAgICAgICAgc2Nyb2xsQ29udGVudDoge30sXG4gICAgICAgICAgcmFpbDoge30sXG4gICAgICAgICAgYmFyOiB7fVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVkQ2JzOiBbXSxcbiAgICAgICAgcmVuZGVyRXJyb3I6IGZhbHNlLFxuXG4gICAgICAgIGNsYXNzSG9va3M6IHtcbiAgICAgICAgICBoYXNWQmFyOiBmYWxzZSxcbiAgICAgICAgICBoYXNIQmFyOiBmYWxzZSxcblxuICAgICAgICAgIHZCYXJWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICBoQmFyVmlzaWJsZTogZmFsc2UsXG5cbiAgICAgICAgICB2QmFyRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgIGhCYXJEcmFnZ2luZzogZmFsc2UsXG5cbiAgICAgICAgICBjbGlraW5nVmVydGljYWxTdGFydEJ1dHRvbjogZmFsc2UsXG4gICAgICAgICAgY2xpa2luZ1ZlcnRpY2FsRW5kQnV0dG9uOiBmYWxzZSxcbiAgICAgICAgICBjbGlraW5nSG9yaXpvbnRhbFN0YXJ0QnV0dG9uOiBmYWxzZSxcbiAgICAgICAgICBjbGlraW5nSG9yaXpvbnRhbEVuZEJ1dHRvbjogZmFsc2UsXG5cbiAgICAgICAgICBtb3VzZUVudGVyOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKiogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgbWV0aG9kczoge1xuICAgICAgLyoqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBIYW5kbGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgc2Nyb2xsaW5nQ29tcGxldGU6IGZ1bmN0aW9uIHNjcm9sbGluZ0NvbXBsZXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUJhclN0YXRlQW5kRW1pdEV2ZW50KCdoYW5kbGUtc2Nyb2xsLWNvbXBsZXRlJyk7XG4gICAgICB9LFxuICAgICAgc2V0QmFyRHJhZzogZnVuY3Rpb24gc2V0QmFyRHJhZyh2YWwpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhpcy52dWVzY3JvbGwuc3RhdGUuaXNEcmFnZ2luZyA9IHZhbDtcbiAgICAgIH0sXG4gICAgICBzZXRDbGFzc0hvb2s6IGZ1bmN0aW9uIHNldENsYXNzSG9vayhuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNsYXNzSG9va3NbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTb21lIEhlbHBlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgIC8qXG4gICAgICAgKiBUbyBoYXZlIGEgZ29vZCB1eCwgaW5zdGVhZCBvZiBoaWRpbmcgYmFyIGltbWVkaWF0ZWx5LCB3ZSBoaWRlIGJhclxuICAgICAgICogYWZ0ZXIgc29tZSBzZWNvbmRzIGJ5IHVzaW5nIHRoaXMgc2ltcGxlIGRlYm91bmNlLWhpZGViYXIgbWV0aG9kLlxuICAgICAgICovXG4gICAgICBzaG93QW5kRGVmZmVyZWRIaWRlQmFyOiBmdW5jdGlvbiBzaG93QW5kRGVmZmVyZWRIaWRlQmFyKGZvcmNlSGlkZUJhcikge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICB0aGlzLnNob3dCYXIoKTtcblxuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgICAgICAgIHRoaXMudGltZW91dElkID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM0LnRpbWVvdXRJZCA9IDA7XG4gICAgICAgICAgX3RoaXM0LmhpZGVCYXIoZm9yY2VIaWRlQmFyKTtcbiAgICAgICAgfSwgdGhpcy5tZXJnZWRPcHRpb25zLmJhci5zaG93RGVsYXkpO1xuICAgICAgfSxcbiAgICAgIHNob3dCYXI6IGZ1bmN0aW9uIHNob3dCYXIoKSB7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5tZXJnZWRPcHRpb25zLmJhci5vcGFjaXR5O1xuICAgICAgICB0aGlzLmJhci52QmFyLnN0YXRlLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICB0aGlzLmJhci5oQmFyLnN0YXRlLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgfSxcbiAgICAgIGhpZGVCYXI6IGZ1bmN0aW9uIGhpZGVCYXIoZm9yY2VIaWRlQmFyKSB7XG4gICAgICAgIHZhciBfdnVlc2Nyb2xsJHN0YXRlID0gdGhpcy52dWVzY3JvbGwuc3RhdGUsXG4gICAgICAgICAgICBpc0RyYWdnaW5nID0gX3Z1ZXNjcm9sbCRzdGF0ZS5pc0RyYWdnaW5nLFxuICAgICAgICAgICAgaXNSYWlsSG92ZXIgPSBfdnVlc2Nyb2xsJHN0YXRlLmlzUmFpbEhvdmVyO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgICAgIGlmIChpc0RyYWdnaW5nIHx8IGlzUmFpbEhvdmVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcmNlSGlkZUJhciAmJiAhdGhpcy5tZXJnZWRPcHRpb25zLmJhci5rZWVwU2hvdykge1xuICAgICAgICAgIHRoaXMuYmFyLmhCYXIuc3RhdGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgdGhpcy5iYXIudkJhci5zdGF0ZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBpc0RyYWdnaW5nIGNvbmRpdGlvblxuICAgICAgICAvLyB0byBwcmV2ZW50IGZyb20gaGlkaW5nIGJhciB3aGlsZSBkcmFnZ2luZyB0aGUgYmFyXG4gICAgICAgIGlmICghdGhpcy5tZXJnZWRPcHRpb25zLmJhci5rZWVwU2hvdyAmJiAhdGhpcy52dWVzY3JvbGwuc3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgICAgIHRoaXMuYmFyLnZCYXIuc3RhdGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgdGhpcy5iYXIuaEJhci5zdGF0ZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZU51bWJlcmljU2l6ZTogZnVuY3Rpb24gdXNlTnVtYmVyaWNTaXplKCkge1xuICAgICAgICB0aGlzLnZ1ZXNjcm9sbC5zdGF0ZS5jdXJyZW50U2l6ZVN0cmF0ZWd5ID0gJ251bWJlcic7XG4gICAgICAgIHZhciBfbWVyZ2VkT3B0aW9ucyRzY3JvbGwgPSB0aGlzLm1lcmdlZE9wdGlvbnMuc2Nyb2xsUGFuZWwsXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBfbWVyZ2VkT3B0aW9ucyRzY3JvbGwubWF4SGVpZ2h0LFxuICAgICAgICAgICAgbWF4V2lkdGggPSBfbWVyZ2VkT3B0aW9ucyRzY3JvbGwubWF4V2lkdGg7XG4gICAgICAgIHZhciBfJGVsJHBhcmVudE5vZGUgPSB0aGlzLiRlbC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgcGFyZW50Q2xpZW50SGVpZ2h0ID0gXyRlbCRwYXJlbnROb2RlLmNsaWVudEhlaWdodCxcbiAgICAgICAgICAgIHBhcmVudENsaWVudFdpZHRoID0gXyRlbCRwYXJlbnROb2RlLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgX3Njcm9sbFBhbmVsRWxtID0gdGhpcy5zY3JvbGxQYW5lbEVsbSxcbiAgICAgICAgICAgIHNjcm9sbEhlaWdodCA9IF9zY3JvbGxQYW5lbEVsbS5zY3JvbGxIZWlnaHQsXG4gICAgICAgICAgICBzY3JvbGxXaWR0aCA9IF9zY3JvbGxQYW5lbEVsbS5zY3JvbGxXaWR0aDtcblxuICAgICAgICB2YXIgd2lkdGggPSB2b2lkIDA7XG4gICAgICAgIHZhciBoZWlnaHQgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKG1heEhlaWdodCB8fCBtYXhXaWR0aCkge1xuICAgICAgICAgIGhlaWdodCA9IHNjcm9sbEhlaWdodCA8PSBtYXhIZWlnaHQgPyB1bmRlZmluZWQgOiBtYXhIZWlnaHQ7XG4gICAgICAgICAgd2lkdGggPSBzY3JvbGxXaWR0aCA8PSBtYXhXaWR0aCA/IHVuZGVmaW5lZCA6IG1heFdpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlaWdodCA9IHBhcmVudENsaWVudEhlaWdodDtcbiAgICAgICAgICB3aWR0aCA9IHBhcmVudENsaWVudFdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52dWVzY3JvbGwuc3RhdGUuaGVpZ2h0ID0gaGVpZ2h0ID8gaGVpZ2h0ICsgJ3B4JyA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy52dWVzY3JvbGwuc3RhdGUud2lkdGggPSB3aWR0aCA/IHdpZHRoICsgJ3B4JyA6IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICB1c2VQZXJjZW50U2l6ZTogZnVuY3Rpb24gdXNlUGVyY2VudFNpemUoKSB7XG4gICAgICAgIHRoaXMudnVlc2Nyb2xsLnN0YXRlLmN1cnJlbnRTaXplU3RyYXRlZ3kgPSAncGVyY2VudCc7XG5cbiAgICAgICAgdGhpcy52dWVzY3JvbGwuc3RhdGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLnZ1ZXNjcm9sbC5zdGF0ZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIH0sXG5cbiAgICAgIC8vIFNldCBpdHMgc2l6ZSB0byBiZSBlcXVhbCB0byBpdHMgcGFyZW50Tm9kZVxuICAgICAgc2V0VnNTaXplOiBmdW5jdGlvbiBzZXRWc1NpemUoKSB7XG4gICAgICAgIHZhciBzaXplU3RyYXRlZ3kgPSB0aGlzLm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnNpemVTdHJhdGVneTtcbiAgICAgICAgdmFyIF9tZXJnZWRPcHRpb25zJHNjcm9sbDIgPSB0aGlzLm1lcmdlZE9wdGlvbnMuc2Nyb2xsUGFuZWwsXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBfbWVyZ2VkT3B0aW9ucyRzY3JvbGwyLm1heEhlaWdodCxcbiAgICAgICAgICAgIG1heFdpZHRoID0gX21lcmdlZE9wdGlvbnMkc2Nyb2xsMi5tYXhXaWR0aDtcbiAgICAgICAgdmFyIF9zY3JvbGxQYW5lbEVsbTIgPSB0aGlzLnNjcm9sbFBhbmVsRWxtLFxuICAgICAgICAgICAgY2xpZW50SGVpZ2h0ID0gX3Njcm9sbFBhbmVsRWxtMi5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICBjbGllbnRXaWR0aCA9IF9zY3JvbGxQYW5lbEVsbTIuY2xpZW50V2lkdGg7XG5cbiAgICAgICAgaWYgKHNpemVTdHJhdGVneSA9PSAnbnVtYmVyJyB8fCBtYXhIZWlnaHQgJiYgY2xpZW50SGVpZ2h0ID4gbWF4SGVpZ2h0IHx8IG1heFdpZHRoICYmIGNsaWVudFdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICB0aGlzLnVzZU51bWJlcmljU2l6ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHNpemVTdHJhdGVneSA9PSAncGVyY2VudCcgJiYgY2xpZW50SGVpZ2h0ICE9IG1heEhlaWdodCAmJiBjbGllbnRXaWR0aCAhPSBtYXhXaWR0aCkge1xuICAgICAgICAgIHRoaXMudXNlUGVyY2VudFNpemUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuXG4gICAgICAvKiogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEluaXQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICBpbml0V2F0Y2hPcHNDaGFuZ2U6IGZ1bmN0aW9uIGluaXRXYXRjaE9wc0NoYW5nZSgpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHdhdGNoT3B0cyA9IHtcbiAgICAgICAgICBkZWVwOiB0cnVlLFxuICAgICAgICAgIHN5bmM6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4kd2F0Y2goJ21lcmdlZE9wdGlvbnMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXM1LmlzU21hbGxDaGFuZ2VUaGlzVGljaykge1xuICAgICAgICAgICAgICBfdGhpczUuaXNTbWFsbENoYW5nZVRoaXNUaWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgIF90aGlzNS51cGRhdGVCYXJTdGF0ZUFuZEVtaXRFdmVudCgnb3B0aW9ucy1jaGFuZ2UnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXM1LnJlZnJlc2hJbnRlcm5hbFN0YXR1cygpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9LCB3YXRjaE9wdHMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBhbHNvIHdhdGNoIGBzbWFsbGAgY2hhbmdlcywgYW5kIHdoZW4gc21hbGwgY2hhbmdlcyBoYXBwZW4sIHdlIHNlbmRcbiAgICAgICAgICogYSBzaWduYWwgdG8gdnVlc2Nyb2xsLCB0byB0ZWxsIGl0OlxuICAgICAgICAgKiAxLiB3ZSBkb24ndCBuZWVkIHRvIHJlZ2lzdHJ5IHJlc2l6ZVxuICAgICAgICAgKiAyLiB3ZSBkb24ndCBuZWVkIHRvIHJlZ2lzdHJ5IHNjcm9sbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc21hbGxDaGFuZ2VBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgX3RoaXM1LiR3YXRjaChvcHRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczUuaXNTbWFsbENoYW5nZVRoaXNUaWNrID0gdHJ1ZTtcbiAgICAgICAgICB9LCB3YXRjaE9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIHNjcm9sbFRvIGhhc2gtYW5jaG9yIHdoaWxlIG1vdW50ZWQgY29tcG9uZW50IGhhdmUgbW91bnRlZC5cbiAgICAgIHNjcm9sbFRvQW5jaG9yOiBmdW5jdGlvbiBzY3JvbGxUb0FuY2hvcigpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICove1xuICAgICAgICB2YXIgdmFsaWRhdGVIYXNoU2VsZWN0b3IgPSBmdW5jdGlvbiB2YWxpZGF0ZUhhc2hTZWxlY3RvcihoYXNoKSB7XG4gICAgICAgICAgcmV0dXJuICgvXiNbYS16QS1aX11cXGQqJC8udGVzdChoYXNoKVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgICAgaWYgKCFoYXNoIHx8IChoYXNoID0gaGFzaC5zbGljZShoYXNoLmxhc3RJbmRleE9mKCcjJykpKSAmJiAhdmFsaWRhdGVIYXNoU2VsZWN0b3IoaGFzaCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihoYXNoKTtcbiAgICAgICAgaWYgKCFpc0NoaWxkSW5QYXJlbnQoZWxtLCB0aGlzLiRlbCkgfHwgdGhpcy5tZXJnZWRPcHRpb25zLnNjcm9sbFBhbmVsLmluaXRpYWxTY3JvbGxZIHx8IHRoaXMubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbC5pbml0aWFsU2Nyb2xsWCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcoZWxtKTtcbiAgICAgIH1cblxuICAgICAgLyoqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSZWdpc3RyeSBSZXNpemUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICB9XG4gIH07XG59O1xuXG4vLyBiZWdpbiBpbXBvcnRpbmdcbnZhciBzY3JvbGxQYW5lbCA9IHtcbiAgbmFtZTogJ3Njcm9sbFBhbmVsJyxcbiAgcHJvcHM6IHsgb3BzOiB7IHR5cGU6IE9iamVjdCwgcmVxdWlyZWQ6IHRydWUgfSB9LFxuICBtZXRob2RzOiB7XG4gICAgLy8gdHJpZ2dlciBzY3JvbGxQYW5lbCBvcHRpb25zIGluaXRpYWxTY3JvbGxYLFxuICAgIC8vIGluaXRpYWxTY3JvbGxZXG4gICAgdXBkYXRlSW5pdGlhbFNjcm9sbDogZnVuY3Rpb24gdXBkYXRlSW5pdGlhbFNjcm9sbCgpIHtcbiAgICAgIHZhciB4ID0gMDtcbiAgICAgIHZhciB5ID0gMDtcblxuICAgICAgdmFyIHBhcmVudCA9IGdldFJlYWxQYXJlbnQodGhpcyk7XG5cbiAgICAgIGlmICh0aGlzLm9wcy5pbml0aWFsU2Nyb2xsWCkge1xuICAgICAgICB4ID0gdGhpcy5vcHMuaW5pdGlhbFNjcm9sbFg7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHMuaW5pdGlhbFNjcm9sbFkpIHtcbiAgICAgICAgeSA9IHRoaXMub3BzLmluaXRpYWxTY3JvbGxZO1xuICAgICAgfVxuICAgICAgaWYgKHggfHwgeSkge1xuICAgICAgICBwYXJlbnQuc2Nyb2xsVG8oeyB4OiB4LCB5OiB5IH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBfdGhpcy51cGRhdGVJbml0aWFsU2Nyb2xsKCk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBjbGFzczogWydfX3BhbmVsJ10sXG4gICAgICBzdHlsZToge1xuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHBhcmVudCA9IGdldFJlYWxQYXJlbnQodGhpcyk7XG5cbiAgICB2YXIgX2N1c3RvbVBhbmVsID0gcGFyZW50LiRzbG90c1snc2Nyb2xsLXBhbmVsJ107XG4gICAgaWYgKF9jdXN0b21QYW5lbCkge1xuICAgICAgcmV0dXJuIGluc2VydENoaWxkcmVuSW50b1Nsb3QoaCwgX2N1c3RvbVBhbmVsLCB0aGlzLiRzbG90cy5kZWZhdWx0LCBkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaChcbiAgICAgICdkaXYnLFxuICAgICAgZGF0YSxcbiAgICAgIFtbdGhpcy4kc2xvdHMuZGVmYXVsdF1dXG4gICAgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbml0IGZvbGxvd2luZyB0aGluZ3NcbiAqIDEuIENvbXBvbmVudFxuICogMi4gUmVuZGVyXG4gKiAzLiBDb25maWdcbiAqL1xuZnVuY3Rpb24gX2luc3RhbGwoY29yZSwgcmVuZGVyKSB7XG4gIHZhciBfY29tcG9uZW50cztcblxuICB2YXIgZXh0cmFDb25maWdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcbiAgdmFyIGV4dHJhVmFsaWRhdG9ycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogW107XG5cbiAgdmFyIGNvbXBvbmVudHMgPSAoX2NvbXBvbmVudHMgPSB7fSwgZGVmaW5lUHJvcGVydHkoX2NvbXBvbmVudHMsIHNjcm9sbFBhbmVsLm5hbWUsIHNjcm9sbFBhbmVsKSwgZGVmaW5lUHJvcGVydHkoX2NvbXBvbmVudHMsIGJhci5uYW1lLCBiYXIpLCBfY29tcG9uZW50cyk7XG5cbiAgdmFyIG9wdHMgPSB7fTtcbiAgb3B0cy5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgb3B0cy5yZW5kZXIgPSByZW5kZXI7XG4gIG9wdHMubWl4aW5zID0gY29yZTtcblxuICB2YXIgY29tcCA9IGNyZWF0ZUNvbXBvbmVudChvcHRzKTtcblxuICAvLyBJbml0IENvbmZpZ1xuICBleHRlbmRPcHRzKGV4dHJhQ29uZmlncywgZXh0cmFWYWxpZGF0b3JzKTtcblxuICByZXR1cm4gY29tcDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNoaWxkcmVuIG9mIHBhcmVudCB0aG9zZSBhcmUgaW4gdmlld3BvcnRcbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudFZpZXdwb3J0RG9tKHBhcmVudCwgY29udGFpbmVyKSB7XG4gIHZhciBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbjtcbiAgdmFyIGRvbUZyYWdtZW50ID0gW107XG5cbiAgdmFyIGlzQ3VycmVudHZpZXcgPSBmdW5jdGlvbiBpc0N1cnJlbnR2aWV3KGRvbSkge1xuICAgIHZhciBfZG9tJGdldEJvdW5kaW5nQ2xpZW4gPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGxlZnQgPSBfZG9tJGdldEJvdW5kaW5nQ2xpZW4ubGVmdCxcbiAgICAgICAgdG9wID0gX2RvbSRnZXRCb3VuZGluZ0NsaWVuLnRvcCxcbiAgICAgICAgd2lkdGggPSBfZG9tJGdldEJvdW5kaW5nQ2xpZW4ud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9kb20kZ2V0Qm91bmRpbmdDbGllbi5oZWlnaHQ7XG5cbiAgICB2YXIgX2NvbnRhaW5lciRnZXRCb3VuZGluID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBwYXJlbnRMZWZ0ID0gX2NvbnRhaW5lciRnZXRCb3VuZGluLmxlZnQsXG4gICAgICAgIHBhcmVudFRvcCA9IF9jb250YWluZXIkZ2V0Qm91bmRpbi50b3AsXG4gICAgICAgIHBhcmVudEhlaWdodCA9IF9jb250YWluZXIkZ2V0Qm91bmRpbi5oZWlnaHQsXG4gICAgICAgIHBhcmVudFdpZHRoID0gX2NvbnRhaW5lciRnZXRCb3VuZGluLndpZHRoO1xuXG4gICAgaWYgKGxlZnQgLSBwYXJlbnRMZWZ0ICsgd2lkdGggPiAwICYmIGxlZnQgLSBwYXJlbnRMZWZ0IDwgcGFyZW50V2lkdGggJiYgdG9wIC0gcGFyZW50VG9wICsgaGVpZ2h0ID4gMCAmJiB0b3AgLSBwYXJlbnRUb3AgPCBwYXJlbnRIZWlnaHQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkb20gPSBjaGlsZHJlbi5pdGVtKGkpO1xuICAgIGlmIChpc0N1cnJlbnR2aWV3KGRvbSkgJiYgIWRvbS5pc1Jlc2l6ZUVsbSkge1xuICAgICAgZG9tRnJhZ21lbnQucHVzaChkb20pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZG9tRnJhZ21lbnQ7XG59XG5cbi8qKlxuICogIENvbXBhdGlibGUgdG8gc2Nyb2xsZXIncyBhbmltYXRpb24gZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWFzaW5nRnVuY3Rpb24oZWFzaW5nLCBlYXNpbmdQYXR0ZXJuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGltZSkge1xuICAgIHJldHVybiBlYXNpbmdQYXR0ZXJuKGVhc2luZywgdGltZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBlYXNpbmcgcGF0dGVyblxuICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2NmZXJkaW5hbmRpL3Ntb290aC1zY3JvbGwvYmxvYi9tYXN0ZXIvc3JjL2pzL3Ntb290aC1zY3JvbGwuanNcbiAqIG1vZGlmaWVkIGJ5IHdhbmd5aTcwOTlcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEVhc2luZyBwYXR0ZXJuXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaW1lIGFuaW1hdGlvbiBzaG91bGQgdGFrZSB0byBjb21wbGV0ZVxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZWFzaW5nUGF0dGVybihlYXNpbmcsIHRpbWUpIHtcbiAgdmFyIHBhdHRlcm4gPSBudWxsO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB7XG4gICAgLy8gRGVmYXVsdCBFYXNpbmcgUGF0dGVybnNcbiAgICBpZiAoZWFzaW5nID09PSAnZWFzZUluUXVhZCcpIHBhdHRlcm4gPSB0aW1lICogdGltZTsgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgIGlmIChlYXNpbmcgPT09ICdlYXNlT3V0UXVhZCcpIHBhdHRlcm4gPSB0aW1lICogKDIgLSB0aW1lKTsgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICBpZiAoZWFzaW5nID09PSAnZWFzZUluT3V0UXVhZCcpIHBhdHRlcm4gPSB0aW1lIDwgMC41ID8gMiAqIHRpbWUgKiB0aW1lIDogLTEgKyAoNCAtIDIgKiB0aW1lKSAqIHRpbWU7IC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgIGlmIChlYXNpbmcgPT09ICdlYXNlSW5DdWJpYycpIHBhdHRlcm4gPSB0aW1lICogdGltZSAqIHRpbWU7IC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICBpZiAoZWFzaW5nID09PSAnZWFzZU91dEN1YmljJykgcGF0dGVybiA9IC0tdGltZSAqIHRpbWUgKiB0aW1lICsgMTsgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICBpZiAoZWFzaW5nID09PSAnZWFzZUluT3V0Q3ViaWMnKSBwYXR0ZXJuID0gdGltZSA8IDAuNSA/IDQgKiB0aW1lICogdGltZSAqIHRpbWUgOiAodGltZSAtIDEpICogKDIgKiB0aW1lIC0gMikgKiAoMiAqIHRpbWUgLSAyKSArIDE7IC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgIGlmIChlYXNpbmcgPT09ICdlYXNlSW5RdWFydCcpIHBhdHRlcm4gPSB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lOyAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgaWYgKGVhc2luZyA9PT0gJ2Vhc2VPdXRRdWFydCcpIHBhdHRlcm4gPSAxIC0gLS10aW1lICogdGltZSAqIHRpbWUgKiB0aW1lOyAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgIGlmIChlYXNpbmcgPT09ICdlYXNlSW5PdXRRdWFydCcpIHBhdHRlcm4gPSB0aW1lIDwgMC41ID8gOCAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgOiAxIC0gOCAqIC0tdGltZSAqIHRpbWUgKiB0aW1lICogdGltZTsgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgaWYgKGVhc2luZyA9PT0gJ2Vhc2VJblF1aW50JykgcGF0dGVybiA9IHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lOyAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgaWYgKGVhc2luZyA9PT0gJ2Vhc2VPdXRRdWludCcpIHBhdHRlcm4gPSAxICsgLS10aW1lICogdGltZSAqIHRpbWUgKiB0aW1lICogdGltZTsgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICBpZiAoZWFzaW5nID09PSAnZWFzZUluT3V0UXVpbnQnKSBwYXR0ZXJuID0gdGltZSA8IDAuNSA/IDE2ICogdGltZSAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgOiAxICsgMTYgKiAtLXRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lOyAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgfVxuICByZXR1cm4gcGF0dGVybiB8fCB0aW1lOyAvLyBubyBlYXNpbmcsIG5vIGFjY2VsZXJhdGlvblxufVxuXG5mdW5jdGlvbiBub29wKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciBub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbn07XG5cbnZhciBTY3JvbGxDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY3JvbGxDb250cm9sKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFNjcm9sbENvbnRyb2wpO1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoU2Nyb2xsQ29udHJvbCwgW3tcbiAgICBrZXk6ICdwYXVzZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0b3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbnRpbnVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRpbnVlKCkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIXRoaXMuaXNQYXVzZWQpIHJldHVybjtcblxuICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgdGhpcy50cyA9IG5vdygpIC0gdGhpcy5wZXJjZW50ICogdGhpcy5zcGQ7XG4gICAgICB0aGlzLmV4ZWNTY3JvbGwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGFydFNjcm9sbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0U2Nyb2xsKHN0LCBlZCwgc3BkKSB7XG4gICAgICB2YXIgc3RlcENiID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBub29wO1xuICAgICAgdmFyIGNvbXBsZXRlQ2IgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IG5vb3A7XG4gICAgICB2YXIgdmVydGlmeUNiID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBub29wO1xuICAgICAgdmFyIGVhc2luZ01ldGhvZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogbm9vcDtcblxuICAgICAgdmFyIGRmID0gZWQgLSBzdDtcbiAgICAgIHZhciBkaXIgPSBkZiA+IDAgPyAtMSA6IDE7XG4gICAgICB2YXIgbnQgPSBub3coKTtcblxuICAgICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpciAhPSB0aGlzLmRpciB8fCBudCAtIHRoaXMudHMgPiAyMDApIHtcbiAgICAgICAgdGhpcy50cyA9IG50O1xuXG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICB0aGlzLnN0ID0gc3Q7XG4gICAgICAgIHRoaXMuZWQgPSBlZDtcbiAgICAgICAgdGhpcy5kZiA9IGRmO1xuICAgICAgfSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL2Vsc2Uge1xuICAgICAgICAgIHRoaXMuZGYgKz0gZGY7XG4gICAgICAgIH1cblxuICAgICAgdGhpcy5zcGQgPSBzcGQ7XG5cbiAgICAgIHRoaXMuY29tcGxldGVDYiA9IGNvbXBsZXRlQ2I7XG4gICAgICB0aGlzLnZlcnRpZnlDYiA9IHZlcnRpZnlDYjtcbiAgICAgIHRoaXMuc3RlcENiID0gc3RlcENiO1xuICAgICAgdGhpcy5lYXNpbmdNZXRob2QgPSBlYXNpbmdNZXRob2Q7XG5cbiAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHRoaXMuZXhlY1Njcm9sbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2V4ZWNTY3JvbGwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGVjU2Nyb2xsKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLmRmKSByZXR1cm47XG5cbiAgICAgIHZhciBwZXJjZW50ID0gdGhpcy5wZXJjZW50IHx8IDA7XG4gICAgICB0aGlzLnBlcmNlbnQgPSAwO1xuICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIV90aGlzLmlzUnVubmluZyB8fCAhX3RoaXMudmVydGlmeUNiKHBlcmNlbnQpIHx8IF90aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgIF90aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBlcmNlbnQgPSAobm93KCkgLSBfdGhpcy50cykgLyBfdGhpcy5zcGQ7XG5cbiAgICAgICAgaWYgKF90aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgICAgX3RoaXMucGVyY2VudCA9IHBlcmNlbnQ7XG4gICAgICAgICAgX3RoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMuc3QgKyBfdGhpcy5kZiAqIF90aGlzLmVhc2luZ01ldGhvZChwZXJjZW50KTtcbiAgICAgICAgICBfdGhpcy5zdGVwQ2IodmFsdWUpO1xuICAgICAgICAgIF90aGlzLnJlZihsb29wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0cmlnZ2VyIGNvbXBsZXRlXG4gICAgICAgICAgX3RoaXMuc3RlcENiKF90aGlzLnN0ICsgX3RoaXMuZGYpO1xuICAgICAgICAgIF90aGlzLmNvbXBsZXRlQ2IoKTtcblxuICAgICAgICAgIF90aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnJlZihsb29wKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuc3QgPSAwO1xuICAgICAgdGhpcy5lZCA9IDA7XG4gICAgICB0aGlzLmRmID0gMDtcbiAgICAgIHRoaXMuc3BkID0gMDtcbiAgICAgIHRoaXMudHMgPSAwO1xuICAgICAgdGhpcy5kaXIgPSAwO1xuICAgICAgdGhpcy5yZWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUod2luZG93KTtcblxuICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNjcm9sbENvbnRyb2w7XG59KCk7XG5cbmZ1bmN0aW9uIHNjcm9sbFRvKGVsbSwgeCwgeSkge1xuICB2YXIgc3BlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDMwMDtcbiAgdmFyIGVhc2luZyA9IGFyZ3VtZW50c1s0XTtcbiAgdmFyIHNjcm9sbGluZ0NvbXBsZXRlID0gYXJndW1lbnRzWzVdO1xuXG4gIHZhciBzY3JvbGxMZWZ0ID0gdm9pZCAwLFxuICAgICAgc2Nyb2xsVG9wID0gdm9pZCAwLFxuICAgICAgc2Nyb2xsSGVpZ2h0ID0gdm9pZCAwLFxuICAgICAgc2Nyb2xsV2lkdGggPSB2b2lkIDAsXG4gICAgICBjbGllbnRXaWR0aCA9IHZvaWQgMCxcbiAgICAgIGNsaWVudEhlaWdodCA9IHZvaWQgMDtcblxuICB2YXIgX2VsbSA9IGVsbSxcbiAgICAgIG5vZGVUeXBlID0gX2VsbS5ub2RlVHlwZTtcblxuICB2YXIgc2Nyb2xsWCA9IG5ldyBTY3JvbGxDb250cm9sKCk7XG4gIHZhciBzY3JvbGxZID0gbmV3IFNjcm9sbENvbnRyb2woKTtcblxuICBpZiAoIW5vZGVUeXBlKSB7XG4gICAgd2FybignWW91IG11c3QgcGFzcyBhIGRvbSBmb3IgdGhlIGZpcnN0IHBhcmFtLCAnICsgJ2ZvciB3aW5kb3cgc2Nyb2xsaW5nLCAnICsgJ3lvdSBjYW4gcGFzcyBkb2N1bWVudCBhcyB0aGUgZmlyc3QgcGFyYW0uJyk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAobm9kZVR5cGUgPT0gOSkge1xuICAgIC8vIGRvY3VtZW50XG4gICAgZWxtID0gZWxtLnNjcm9sbGluZ0VsZW1lbnQ7XG4gIH1cblxuICB2YXIgX2VsbTIgPSBlbG07XG4gIHNjcm9sbExlZnQgPSBfZWxtMi5zY3JvbGxMZWZ0O1xuICBzY3JvbGxUb3AgPSBfZWxtMi5zY3JvbGxUb3A7XG4gIHNjcm9sbEhlaWdodCA9IF9lbG0yLnNjcm9sbEhlaWdodDtcbiAgc2Nyb2xsV2lkdGggPSBfZWxtMi5zY3JvbGxXaWR0aDtcbiAgY2xpZW50V2lkdGggPSBfZWxtMi5jbGllbnRXaWR0aDtcbiAgY2xpZW50SGVpZ2h0ID0gX2VsbTIuY2xpZW50SGVpZ2h0O1xuXG5cbiAgaWYgKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJykge1xuICAgIHggPSBzY3JvbGxMZWZ0O1xuICB9IGVsc2Uge1xuICAgIHggPSBnZXROdW1lcmljVmFsdWUoeCwgc2Nyb2xsV2lkdGggLSBjbGllbnRXaWR0aCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB5ID09PSAndW5kZWZpbmVkJykge1xuICAgIHkgPSBzY3JvbGxUb3A7XG4gIH0gZWxzZSB7XG4gICAgeSA9IGdldE51bWVyaWNWYWx1ZSh5LCBzY3JvbGxIZWlnaHQgLSBjbGllbnRIZWlnaHQpO1xuICB9XG5cbiAgdmFyIGVhc2luZ01ldGhvZCA9IGNyZWF0ZUVhc2luZ0Z1bmN0aW9uKGVhc2luZywgZWFzaW5nUGF0dGVybik7XG4gIHNjcm9sbFguc3RhcnRTY3JvbGwoc2Nyb2xsTGVmdCwgeCwgc3BlZWQsIGZ1bmN0aW9uIChkeCkge1xuICAgIGVsbS5zY3JvbGxMZWZ0ID0gZHg7XG4gIH0sIHNjcm9sbGluZ0NvbXBsZXRlLCB1bmRlZmluZWQsIGVhc2luZ01ldGhvZCk7XG4gIHNjcm9sbFkuc3RhcnRTY3JvbGwoc2Nyb2xsVG9wLCB5LCBzcGVlZCwgZnVuY3Rpb24gKGR5KSB7XG4gICAgZWxtLnNjcm9sbFRvcCA9IGR5O1xuICB9LCBzY3JvbGxpbmdDb21wbGV0ZSwgdW5kZWZpbmVkLCBlYXNpbmdNZXRob2QpO1xufVxuXG52YXIgYXBpJDEgPSB7XG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgLy8gcmVnaXN0cnkgc2Nyb2xsXG4gICAgdGhpcy5zY3JvbGxYID0gbmV3IFNjcm9sbENvbnRyb2woKTtcbiAgICB0aGlzLnNjcm9sbFkgPSBuZXcgU2Nyb2xsQ29udHJvbCgpO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBuYXRpdmVTdG9wOiBmdW5jdGlvbiBuYXRpdmVTdG9wKCkge1xuICAgICAgdGhpcy5zY3JvbGxYLnN0b3AoKTtcbiAgICAgIHRoaXMuc2Nyb2xsWS5zdG9wKCk7XG4gICAgfSxcbiAgICBuYXRpdmVQYXVzZTogZnVuY3Rpb24gbmF0aXZlUGF1c2UoKSB7XG4gICAgICB0aGlzLnNjcm9sbFgucGF1c2UoKTtcbiAgICAgIHRoaXMuc2Nyb2xsWS5wYXVzZSgpO1xuICAgIH0sXG4gICAgbmF0aXZlQ29udGludWU6IGZ1bmN0aW9uIG5hdGl2ZUNvbnRpbnVlKCkge1xuICAgICAgdGhpcy5zY3JvbGxYLmNvbnRpbnVlKCk7XG4gICAgICB0aGlzLnNjcm9sbFkuY29udGludWUoKTtcbiAgICB9LFxuICAgIG5hdGl2ZVNjcm9sbFRvOiBmdW5jdGlvbiBuYXRpdmVTY3JvbGxUbyh4LCB5LCBzcGVlZCwgZWFzaW5nKSB7XG4gICAgICBpZiAoc3BlZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNwZWVkID0gdGhpcy5tZXJnZWRPcHRpb25zLnNjcm9sbFBhbmVsLnNwZWVkO1xuICAgICAgfVxuICAgICAgdmFyIGVsbSA9IHRoaXMuc2Nyb2xsUGFuZWxFbG07XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gZWxtLnNjcm9sbFRvcCxcbiAgICAgICAgICBzY3JvbGxMZWZ0ID0gZWxtLnNjcm9sbExlZnQsXG4gICAgICAgICAgc2Nyb2xsV2lkdGggPSBlbG0uc2Nyb2xsV2lkdGgsXG4gICAgICAgICAgY2xpZW50V2lkdGggPSBlbG0uY2xpZW50V2lkdGgsXG4gICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gZWxtLnNjcm9sbEhlaWdodCxcbiAgICAgICAgICBjbGllbnRIZWlnaHQgPSBlbG0uY2xpZW50SGVpZ2h0O1xuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHggPSBzY3JvbGxMZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IGdldE51bWVyaWNWYWx1ZSh4LCBzY3JvbGxXaWR0aCAtIGNsaWVudFdpZHRoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgeSA9IHNjcm9sbFRvcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSBnZXROdW1lcmljVmFsdWUoeSwgc2Nyb2xsSGVpZ2h0IC0gY2xpZW50SGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwZWVkKSB7XG4gICAgICAgIGVhc2luZyA9IGVhc2luZyB8fCB0aGlzLm1lcmdlZE9wdGlvbnMuc2Nyb2xsUGFuZWwuZWFzaW5nO1xuICAgICAgICB2YXIgZWFzaW5nTWV0aG9kID0gY3JlYXRlRWFzaW5nRnVuY3Rpb24oZWFzaW5nLCBlYXNpbmdQYXR0ZXJuKTtcblxuICAgICAgICBpZiAoeCAhPSBzY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgdGhpcy5zY3JvbGxYLnN0YXJ0U2Nyb2xsKHNjcm9sbExlZnQsIHgsIHNwZWVkLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgZWxtLnNjcm9sbExlZnQgPSB4O1xuICAgICAgICAgIH0sIHRoaXMuc2Nyb2xsaW5nQ29tcGxldGUuYmluZCh0aGlzKSwgdW5kZWZpbmVkLCBlYXNpbmdNZXRob2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgIT0gc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgdGhpcy5zY3JvbGxZLnN0YXJ0U2Nyb2xsKHNjcm9sbFRvcCwgeSwgc3BlZWQsIGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICBlbG0uc2Nyb2xsVG9wID0geTtcbiAgICAgICAgICB9LCB0aGlzLnNjcm9sbGluZ0NvbXBsZXRlLmJpbmQodGhpcyksIHVuZGVmaW5lZCwgZWFzaW5nTWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxtLnNjcm9sbFRvcCA9IHk7XG4gICAgICAgIGVsbS5zY3JvbGxMZWZ0ID0geDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEN1cnJlbnR2aWV3RG9tTmF0aXZlOiBmdW5jdGlvbiBnZXRDdXJyZW50dmlld0RvbU5hdGl2ZSgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnNjcm9sbENvbnRlbnRFbG07XG4gICAgICB2YXIgZG9tRnJhZ21lbnQgPSBnZXRDdXJyZW50Vmlld3BvcnREb20ocGFyZW50LCB0aGlzLiRlbCk7XG4gICAgICByZXR1cm4gZG9tRnJhZ21lbnQ7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRQYW5lbERhdGEoY29udGV4dCkge1xuICAvLyBzY3JvbGxQYW5lbCBkYXRhIHN0YXJ0XG4gIHZhciBkYXRhID0ge1xuICAgIHJlZjogJ3Njcm9sbFBhbmVsJyxcbiAgICBzdHlsZToge1xuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBvdmVyZmxvd1k6ICdzY3JvbGwnLFxuICAgICAgb3ZlcmZsb3dYOiAnc2Nyb2xsJ1xuICAgIH0sXG4gICAgY2xhc3M6IFtdLFxuICAgIG5hdGl2ZU9uOiB7XG4gICAgICAnJnNjcm9sbCc6IGNvbnRleHQuaGFuZGxlU2Nyb2xsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgb3BzOiBjb250ZXh0Lm1lcmdlZE9wdGlvbnMuc2Nyb2xsUGFuZWxcbiAgICB9XG4gIH07XG5cbiAgY29udGV4dC5zY3JvbGxZRW5hYmxlID0gdHJ1ZTtcbiAgY29udGV4dC5zY3JvbGxYRW5hYmxlID0gdHJ1ZTtcblxuICBkYXRhLm5hdGl2ZU9uLkRPTU1vdXNlU2Nyb2xsID0gZGF0YS5uYXRpdmVPbi5tb3VzZXdoZWVsID0gY29udGV4dC5vbk1vdXNlV2hlZWw7XG5cbiAgdmFyIF9jb250ZXh0JG1lcmdlZE9wdGlvbiA9IGNvbnRleHQubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbCxcbiAgICAgIHNjcm9sbGluZ1kgPSBfY29udGV4dCRtZXJnZWRPcHRpb24uc2Nyb2xsaW5nWSxcbiAgICAgIHNjcm9sbGluZ1ggPSBfY29udGV4dCRtZXJnZWRPcHRpb24uc2Nyb2xsaW5nWDtcblxuXG4gIGlmICghY29udGV4dC5iYXIuaEJhci5zdGF0ZS5zaXplIHx8ICFzY3JvbGxpbmdYKSB7XG4gICAgY29udGV4dC5zY3JvbGxYRW5hYmxlID0gZmFsc2U7XG4gICAgZGF0YS5zdHlsZS5vdmVyZmxvd1ggPSAnaGlkZGVuJztcbiAgfVxuXG4gIGlmICghY29udGV4dC5iYXIudkJhci5zdGF0ZS5zaXplIHx8ICFzY3JvbGxpbmdZKSB7XG4gICAgY29udGV4dC5zY3JvbGxZRW5hYmxlID0gZmFsc2U7XG4gICAgZGF0YS5zdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJztcbiAgfVxuXG4gIHZhciBndXR0ZXIgPSBnZXRHdXR0ZXIoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghZ3V0dGVyKSB7XG4gICAgY3JlYXRlSGlkZUJhclN0eWxlKCk7XG4gICAgZGF0YS5jbGFzcy5wdXNoKCdfX2hpZGViYXInKTtcbiAgICBpZiAoaXNJb3MoKSkge1xuICAgICAgZGF0YS5zdHlsZVsnLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmcnXSA9ICd0b3VjaCc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGhpZGUgc3lzdGVtIGJhciBieSB1c2UgYSBuZWdhdGl2ZSB2YWx1ZSBweFxuICAgIC8vIGd1dHRlciBzaG91bGQgYmUgMCB3aGVuIG1hbnVhbGx5IGRpc2FibGUgc2Nyb2xsaW5nWCAjMTRcbiAgICBpZiAoY29udGV4dC5iYXIudkJhci5zdGF0ZS5zaXplICYmIGNvbnRleHQubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbC5zY3JvbGxpbmdZKSB7XG4gICAgICBpZiAoY29udGV4dC5tZXJnZWRPcHRpb25zLnNjcm9sbFBhbmVsLnZlcnRpY2FsTmF0aXZlQmFyUG9zID09ICdyaWdodCcpIHtcbiAgICAgICAgZGF0YS5zdHlsZS5tYXJnaW5SaWdodCA9ICctJyArIGd1dHRlciArICdweCc7XG4gICAgICB9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovZWxzZSB7XG4gICAgICAgICAgZGF0YS5zdHlsZS5tYXJnaW5MZWZ0ID0gJy0nICsgZ3V0dGVyICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dC5iYXIuaEJhci5zdGF0ZS5zaXplICYmIGNvbnRleHQubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbC5zY3JvbGxpbmdYKSB7XG4gICAgICBkYXRhLnN0eWxlLmhlaWdodCA9ICdjYWxjKDEwMCUgKyAnICsgZ3V0dGVyICsgJ3B4KSc7XG4gICAgfVxuICB9XG5cbiAgLy8gY2xlYXIgbGVnZW5jeSBzdHlsZXMgb2Ygc2xpZGUgbW9kZS4uLlxuICBkYXRhLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcnO1xuICBkYXRhLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIGNyZWF0ZSBhIHNjcm9sbFBhbmVsXG4gKlxuICogQHBhcmFtIHthbnl9IHNpemVcbiAqIEBwYXJhbSB7YW55fSBjb250ZXh0XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBjcmVhdGVQYW5lbChoLCBjb250ZXh0KSB7XG4gIHZhciBkYXRhID0ge307XG5cbiAgZGF0YSA9IGdldFBhbmVsRGF0YShjb250ZXh0KTtcblxuICByZXR1cm4gaChcbiAgICAnc2Nyb2xsUGFuZWwnLFxuICAgIGRhdGEsXG4gICAgW2dldFBhbmVsQ2hpbGRyZW4oaCwgY29udGV4dCldXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFBhbmVsQ2hpbGRyZW4oaCwgY29udGV4dCkge1xuICB2YXIgdmlld1N0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICdib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnLFxuICAgICdtaW4td2lkdGgnOiAnMTAwJScsXG4gICAgJ21pbi1oZWlnaHQnOiAnMTAwJSdcbiAgfTtcbiAgdmFyIGRhdGEgPSB7XG4gICAgc3R5bGU6IHZpZXdTdHlsZSxcbiAgICByZWY6ICdzY3JvbGxDb250ZW50JyxcbiAgICBjbGFzczogJ19fdmlldydcbiAgfTtcbiAgdmFyIF9jdXN0b21Db250ZW50ID0gY29udGV4dC4kc2xvdHNbJ3Njcm9sbC1jb250ZW50J107XG5cbiAgaWYgKGNvbnRleHQubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbC5zY3JvbGxpbmdYKSB7XG4gICAgdmlld1N0eWxlLndpZHRoID0gZ2V0Q29tcGxpdGFibGVTdHlsZSgnd2lkdGgnLCAnZml0LWNvbnRlbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLnN0eWxlWyd3aWR0aCddID0gJzEwMCUnO1xuICB9XG5cbiAgaWYgKGNvbnRleHQubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbC5wYWRkaW5nKSB7XG4gICAgZGF0YS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBjb250ZXh0Lm1lcmdlZE9wdGlvbnMucmFpbC5zaXplO1xuICB9XG5cbiAgaWYgKF9jdXN0b21Db250ZW50KSB7XG4gICAgcmV0dXJuIGluc2VydENoaWxkcmVuSW50b1Nsb3QoaCwgX2N1c3RvbUNvbnRlbnQsIGNvbnRleHQuJHNsb3RzLmRlZmF1bHQsIGRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGgoXG4gICAgJ2RpdicsXG4gICAgZGF0YSxcbiAgICBbY29udGV4dC4kc2xvdHMuZGVmYXVsdF1cbiAgKTtcbn1cblxuLy8gZGV0ZWN0IGNvbnRlbnQgc2l6ZSBjaGFuZ2VcbmZ1bmN0aW9uIGluc3RhbGxSZXNpemVEZXRlY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGluamVjdE9iamVjdChlbGVtZW50LCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGluamVjdE9iamVjdChlbGVtZW50LCBjYWxsYmFjaykge1xuICBpZiAoZWxlbWVudC5oYXNSZXNpemVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIE9CSkVDVF9TVFlMRSA9ICdkaXNwbGF5OiBibG9jazsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IGJvcmRlcjogbm9uZTsgcGFkZGluZzogMDsgbWFyZ2luOiAwOyBvcGFjaXR5OiAwOyB6LWluZGV4OiAtMTAwMDsgcG9pbnRlci1ldmVudHM6IG5vbmU7JztcbiAgLy8gZGVmaW5lIGEgd3JhcCBkdWUgdG8gaWUncyB6SW5kZXggYnVnXG4gIHZhciBvYmpXcmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG9ialdyYXAuc3R5bGUuY3NzVGV4dCA9IE9CSkVDVF9TVFlMRTtcbiAgdmFyIG9iamVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29iamVjdCcpO1xuICBvYmplY3Quc3R5bGUuY3NzVGV4dCA9IE9CSkVDVF9TVFlMRTtcbiAgb2JqZWN0LnR5cGUgPSAndGV4dC9odG1sJztcbiAgb2JqZWN0LnRhYkluZGV4ID0gLTE7XG5cbiAgb2JqZWN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBldmVudENlbnRlcihvYmplY3QuY29udGVudERvY3VtZW50LmRlZmF1bHRWaWV3LCAncmVzaXplJywgY2FsbGJhY2spO1xuICB9O1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yL2Jsb2IvYWFmZTlmN2VhMTFkMWVlYmRhYjcyMmM3YzViODY2MzRlNzM0YjliOC9zcmMvZGV0ZWN0aW9uLXN0cmF0ZWd5L29iamVjdC5qcyNMMTU5XG4gIGlmICghaXNJRSgpKSB7XG4gICAgb2JqZWN0LmRhdGEgPSAnYWJvdXQ6YmxhbmsnO1xuICB9XG4gIG9ialdyYXAuaXNSZXNpemVFbG0gPSB0cnVlO1xuICBvYmpXcmFwLmFwcGVuZENoaWxkKG9iamVjdCk7XG4gIGVsZW1lbnQuYXBwZW5kQ2hpbGQob2JqV3JhcCk7XG4gIGlmIChpc0lFKCkpIHtcbiAgICBvYmplY3QuZGF0YSA9ICdhYm91dDpibGFuayc7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKG9iamVjdC5jb250ZW50RG9jdW1lbnQpIHtcbiAgICAgIGV2ZW50Q2VudGVyKG9iamVjdC5jb250ZW50RG9jdW1lbnQuZGVmYXVsdFZpZXcsICdyZXNpemUnLCBjYWxsYmFjaywgJ29mZicpO1xuICAgIH1cbiAgICBlbGVtZW50LnJlbW92ZUNoaWxkKG9ialdyYXApO1xuICAgIGVsZW1lbnQuaGFzUmVzaXplZCA9IGZhbHNlO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZXNlIG1peGVzIGlzIGV4Y2x1c2l2ZSBmb3IgbmF0aXZlIG1vZGVcbiAqL1xuXG52YXIgdXBkYXRlID0ge1xuICBtZXRob2RzOiB7XG4gICAgdXBkYXRlTmF0aXZlTW9kZUJhclN0YXRlOiBmdW5jdGlvbiB1cGRhdGVOYXRpdmVNb2RlQmFyU3RhdGUoKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5zY3JvbGxQYW5lbEVsbTtcbiAgICAgIHZhciBpc1BlcmNlbnQgPSB0aGlzLnZ1ZXNjcm9sbC5zdGF0ZS5jdXJyZW50U2l6ZVN0cmF0ZWd5ID09ICdwZXJjZW50JztcbiAgICAgIHZhciBfdnVlc2Nyb2xsJHN0YXRlID0gdGhpcy52dWVzY3JvbGwuc3RhdGUsXG4gICAgICAgICAgd2lkdGggPSBfdnVlc2Nyb2xsJHN0YXRlLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF92dWVzY3JvbGwkc3RhdGUuaGVpZ2h0O1xuXG4gICAgICB2YXIgY2xpZW50V2lkdGggPSBpc1BlcmNlbnQgfHwgIXdpZHRoID8gY29udGFpbmVyLmNsaWVudFdpZHRoIDogd2lkdGguc2xpY2UoMCwgLTIpOyAvLyB4eHhweCA9PT4geHh4XG4gICAgICB2YXIgY2xpZW50SGVpZ2h0ID0gaXNQZXJjZW50IHx8ICFoZWlnaHQgPyBjb250YWluZXIuY2xpZW50SGVpZ2h0IDogaGVpZ2h0LnNsaWNlKDAsIC0yKTtcblxuICAgICAgdmFyIGhlaWdodFBlcmNlbnRhZ2UgPSBjbGllbnRIZWlnaHQgLyBjb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgdmFyIHdpZHRoUGVyY2VudGFnZSA9IGNsaWVudFdpZHRoIC8gY29udGFpbmVyLnNjcm9sbFdpZHRoO1xuXG4gICAgICB0aGlzLmJhci52QmFyLnN0YXRlLnBvc1ZhbHVlID0gY29udGFpbmVyLnNjcm9sbFRvcCAqIDEwMCAvIGNsaWVudEhlaWdodDtcbiAgICAgIHRoaXMuYmFyLmhCYXIuc3RhdGUucG9zVmFsdWUgPSBjb250YWluZXIuc2Nyb2xsTGVmdCAqIDEwMCAvIGNsaWVudFdpZHRoO1xuXG4gICAgICB0aGlzLmJhci52QmFyLnN0YXRlLnNpemUgPSBoZWlnaHRQZXJjZW50YWdlIDwgMSA/IGhlaWdodFBlcmNlbnRhZ2UgOiAwO1xuICAgICAgdGhpcy5iYXIuaEJhci5zdGF0ZS5zaXplID0gd2lkdGhQZXJjZW50YWdlIDwgMSA/IHdpZHRoUGVyY2VudGFnZSA6IDA7XG4gICAgfSxcbiAgICBnZXROYXRpdmVQb3NpdGlvbjogZnVuY3Rpb24gZ2V0TmF0aXZlUG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JvbGxUb3A6IHRoaXMuc2Nyb2xsUGFuZWxFbG0uc2Nyb2xsVG9wLFxuICAgICAgICBzY3JvbGxMZWZ0OiB0aGlzLnNjcm9sbFBhbmVsRWxtLnNjcm9sbExlZnRcbiAgICAgIH07XG4gICAgfSxcbiAgICBjc3M6IGZ1bmN0aW9uIGNzcyhkb20sIHN0eWxlKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL3tcbiAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20pW3N0eWxlXTtcbiAgICB9LFxuICAgIGNoZWNrU2Nyb2xsYWJsZTogZnVuY3Rpb24gY2hlY2tTY3JvbGxhYmxlKGUsIGRlbHRhWCwgZGVsdGFZKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL3tcbiAgICAgIHZhciBzY3JvbGxhYmxlID0gZmFsc2U7XG5cbiAgICAgIC8vIGNoZWNrIG1vdXNlIHBvaW50IHNjcm9sbGFibGUuXG4gICAgICB2YXIgZG9tID0gZS50YXJnZXQgPyBlLnRhcmdldCA6IGU7XG4gICAgICB3aGlsZSAoZG9tICYmIGRvbS5ub2RlVHlwZSA9PSAxICYmIGRvbSAhPT0gdGhpcy5zY3JvbGxQYW5lbEVsbS5wYXJlbnROb2RlICYmICEvXkJPRFl8SFRNTC8udGVzdChkb20ubm9kZU5hbWUpKSB7XG4gICAgICAgIHZhciBvdiA9IHRoaXMuY3NzKGRvbSwgJ292ZXJmbG93JykgfHwgJyc7XG4gICAgICAgIGlmICgvc2Nyb2xsfGF1dG8vLnRlc3Qob3YpKSB7XG4gICAgICAgICAgdmFyIF9nZXRTY3JvbGxQcm9jZXNzID0gdGhpcy5nZXRTY3JvbGxQcm9jZXNzKGRvbSksXG4gICAgICAgICAgICAgIHYgPSBfZ2V0U2Nyb2xsUHJvY2Vzcy52LFxuICAgICAgICAgICAgICBoID0gX2dldFNjcm9sbFByb2Nlc3MuaDtcblxuICAgICAgICAgIHZhciBpc1Njcm9sbFggPSB0aGlzLmNzcyhkb20sICdvdmVyZmxvd1gnKSAhPT0gJ2hpZGRlbic7XG4gICAgICAgICAgdmFyIGlzU2Nyb2xsWSA9IHRoaXMuY3NzKGRvbSwgJ292ZXJmbG93WScpICE9PSAnaGlkZGVuJztcbiAgICAgICAgICBpZiAoaXNTY3JvbGxYICYmIChkZWx0YVggPCAwICYmIGggPiAwIHx8IGRlbHRhWCA+IDAgJiYgaCA8IDEpIHx8IGlzU2Nyb2xsWSAmJiAoZGVsdGFZIDwgMCAmJiB2ID4gMCB8fCBkZWx0YVkgPiAwICYmIHYgPCAxKSkge1xuICAgICAgICAgICAgc2Nyb2xsYWJsZSA9IGRvbSA9PSB0aGlzLnNjcm9sbFBhbmVsRWxtO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlID8gZG9tLnBhcmVudE5vZGUgOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjcm9sbGFibGU7XG4gICAgfSxcbiAgICBvbk1vdXNlV2hlZWw6IGZ1bmN0aW9uIG9uTW91c2VXaGVlbChldmVudCkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi97XG4gICAgICB2YXIgX21lcmdlZE9wdGlvbnMkdnVlc2NyID0gdGhpcy5tZXJnZWRPcHRpb25zLnZ1ZXNjcm9sbCxcbiAgICAgICAgICBpc1JldmVyc2UgPSBfbWVyZ2VkT3B0aW9ucyR2dWVzY3Iud2hlZWxEaXJlY3Rpb25SZXZlcnNlLFxuICAgICAgICAgIGR1cmF0aW9uID0gX21lcmdlZE9wdGlvbnMkdnVlc2NyLndoZWVsU2Nyb2xsRHVyYXRpb24sXG4gICAgICAgICAgY2hlY2tTaGlmdEtleSA9IF9tZXJnZWRPcHRpb25zJHZ1ZXNjci5jaGVja1NoaWZ0S2V5LFxuICAgICAgICAgIGxvY2tpbmcgPSBfbWVyZ2VkT3B0aW9ucyR2dWVzY3IubG9ja2luZztcblxuXG4gICAgICB2YXIgZGVsdGFYID0gdm9pZCAwO1xuICAgICAgdmFyIGRlbHRhWSA9IHZvaWQgMDtcbiAgICAgIGlmIChldmVudC53aGVlbERlbHRhKSB7XG4gICAgICAgIGlmIChldmVudC5kZWx0YVkgfHwgZXZlbnQuZGVsdGFYKSB7XG4gICAgICAgICAgZGVsdGFYID0gZXZlbnQuZGVsdGFYO1xuICAgICAgICAgIGRlbHRhWSA9IGV2ZW50LmRlbHRhWTtcbiAgICAgICAgICBpZiAobG9ja2luZykge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGV2ZW50LmRlbHRhWCkgPiBNYXRoLmFicyhldmVudC5kZWx0YVkpKSB7XG4gICAgICAgICAgICAgIGRlbHRhWSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWx0YVggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWx0YVggPSAwO1xuICAgICAgICAgIGRlbHRhWSA9IC0xICogZXZlbnQud2hlZWxEZWx0YSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7XG4gICAgICAgIGRlbHRhWSA9IGRlbHRhWCA9IGV2ZW50LmRldGFpbCAqIDE2O1xuICAgICAgICAvLyBob3Jpem9udGFsIHNjcm9sbFxuICAgICAgICBpZiAoZXZlbnQuYXhpcyA9PSAxKSB7XG4gICAgICAgICAgZGVsdGFZID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5heGlzID09IDIpIHtcbiAgICAgICAgICAvLyB2ZXJ0aWNhbCBzY3JvbGxcbiAgICAgICAgICBkZWx0YVggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja1NoaWZ0S2V5ICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgIC8vIHN3YXAgdmFsdWVcbiAgICAgICAgZGVsdGFYIF49IGRlbHRhWTtcbiAgICAgICAgZGVsdGFZIF49IGRlbHRhWDtcbiAgICAgICAgZGVsdGFYIF49IGRlbHRhWTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUmV2ZXJzZSkge1xuICAgICAgICBkZWx0YVggXj0gZGVsdGFZO1xuICAgICAgICBkZWx0YVkgXj0gZGVsdGFYO1xuICAgICAgICBkZWx0YVggXj0gZGVsdGFZO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jaGVja1Njcm9sbGFibGUoZXZlbnQsIGRlbHRhWCwgZGVsdGFZKSkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCeSh7IGR4OiBkZWx0YVgsIGR5OiBkZWx0YVkgfSwgZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBzY3JvbGxDb250ZW50RWxtOiBmdW5jdGlvbiBzY3JvbGxDb250ZW50RWxtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHJlZnNbJ3Njcm9sbENvbnRlbnQnXS5faXNWdWUgPyB0aGlzLiRyZWZzWydzY3JvbGxDb250ZW50J10uJGVsIDogdGhpcy4kcmVmc1snc2Nyb2xsQ29udGVudCddO1xuICAgIH1cbiAgfVxufTtcblxudmFyIG1peGlucyA9IFthcGkkMSwgdXBkYXRlXTtcblxudmFyIGNvcmUgPSB7XG4gIG1peGluczogbWl4aW5zLFxuICBtZXRob2RzOiB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAodGhpcy5kZXN0cm95UmVzaXplKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveVJlc2l6ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0Q3VycmVudHZpZXdEb206IGZ1bmN0aW9uIGdldEN1cnJlbnR2aWV3RG9tKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudHZpZXdEb21OYXRpdmUoKTtcbiAgICB9LFxuICAgIGludGVybmFsU2Nyb2xsVG86IGZ1bmN0aW9uIGludGVybmFsU2Nyb2xsVG8oZGVzdFgsIGRlc3RZLCBhbmltYXRlLCBlYXNpbmcpIHtcbiAgICAgIHRoaXMubmF0aXZlU2Nyb2xsVG8oZGVzdFgsIGRlc3RZLCBhbmltYXRlLCBlYXNpbmcpO1xuICAgIH0sXG4gICAgaW50ZXJuYWxTdG9wOiBmdW5jdGlvbiBpbnRlcm5hbFN0b3AoKSB7XG4gICAgICB0aGlzLm5hdGl2ZVN0b3AoKTtcbiAgICB9LFxuICAgIGludGVybmFsUGF1c2U6IGZ1bmN0aW9uIGludGVybmFsUGF1c2UoKSB7XG4gICAgICB0aGlzLm5hdGl2ZVBhdXNlKCk7XG4gICAgfSxcbiAgICBpbnRlcm5hbENvbnRpbnVlOiBmdW5jdGlvbiBpbnRlcm5hbENvbnRpbnVlKCkge1xuICAgICAgdGhpcy5uYXRpdmVDb250aW51ZSgpO1xuICAgIH0sXG4gICAgaGFuZGxlU2Nyb2xsOiBmdW5jdGlvbiBoYW5kbGVTY3JvbGwobmF0aXZlRXZlbnQpIHtcbiAgICAgIHRoaXMudXBkYXRlQmFyU3RhdGVBbmRFbWl0RXZlbnQoJ2hhbmRsZS1zY3JvbGwnLCBuYXRpdmVFdmVudCk7XG4gICAgfSxcbiAgICB1cGRhdGVCYXJTdGF0ZUFuZEVtaXRFdmVudDogZnVuY3Rpb24gdXBkYXRlQmFyU3RhdGVBbmRFbWl0RXZlbnQoZXZlbnRUeXBlKSB7XG4gICAgICB2YXIgbmF0aXZlRXZlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgIHRoaXMudXBkYXRlTmF0aXZlTW9kZUJhclN0YXRlKCk7XG4gICAgICBpZiAoZXZlbnRUeXBlKSB7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KGV2ZW50VHlwZSwgbmF0aXZlRXZlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWVyZ2VkT3B0aW9ucy5iYXIub25seVNob3dCYXJPblNjcm9sbCkge1xuICAgICAgICBpZiAoZXZlbnRUeXBlID09ICdoYW5kbGUtc2Nyb2xsJyB8fCBldmVudFR5cGUgPT0gJ2hhbmRsZS1yZXNpemUnIHx8IGV2ZW50VHlwZSA9PSAncmVmcmVzaC1zdGF0dXMnIHx8IGV2ZW50VHlwZSA9PSAnd2luZG93LXJlc2l6ZScgfHwgZXZlbnRUeXBlID09ICdvcHRpb25zLWNoYW5nZScpIHtcbiAgICAgICAgICB0aGlzLnNob3dBbmREZWZmZXJlZEhpZGVCYXIodHJ1ZSAvKiBmb3JjZUhpZGVCYXI6IHRydWUgKi8pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dBbmREZWZmZXJlZEhpZGVCYXIoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFNjcm9sbFByb2Nlc3M6IGZ1bmN0aW9uIGdldFNjcm9sbFByb2Nlc3MoZWxtKSB7XG4gICAgICB2YXIgX3JlZiA9IGVsbSB8fCB0aGlzLnNjcm9sbFBhbmVsRWxtLFxuICAgICAgICAgIHNjcm9sbEhlaWdodCA9IF9yZWYuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgIHNjcm9sbFdpZHRoID0gX3JlZi5zY3JvbGxXaWR0aCxcbiAgICAgICAgICBjbGllbnRIZWlnaHQgPSBfcmVmLmNsaWVudEhlaWdodCxcbiAgICAgICAgICBjbGllbnRXaWR0aCA9IF9yZWYuY2xpZW50V2lkdGgsXG4gICAgICAgICAgc2Nyb2xsVG9wID0gX3JlZi5zY3JvbGxUb3AsXG4gICAgICAgICAgc2Nyb2xsTGVmdCA9IF9yZWYuc2Nyb2xsTGVmdDtcblxuICAgICAgdmFyIHYgPSBNYXRoLm1pbihzY3JvbGxUb3AgLyAoc2Nyb2xsSGVpZ2h0IC0gY2xpZW50SGVpZ2h0IHx8IDEpLCAxKTtcbiAgICAgIHZhciBoID0gTWF0aC5taW4oc2Nyb2xsTGVmdCAvIChzY3JvbGxXaWR0aCAtIGNsaWVudFdpZHRoIHx8IDEpLCAxKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdjogdixcbiAgICAgICAgaDogaFxuICAgICAgfTtcbiAgICB9LFxuICAgIGVtaXRFdmVudDogZnVuY3Rpb24gZW1pdEV2ZW50KGV2ZW50VHlwZSkge1xuICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIF9zY3JvbGxQYW5lbEVsbSA9IHRoaXMuc2Nyb2xsUGFuZWxFbG0sXG4gICAgICAgICAgc2Nyb2xsVG9wID0gX3Njcm9sbFBhbmVsRWxtLnNjcm9sbFRvcCxcbiAgICAgICAgICBzY3JvbGxMZWZ0ID0gX3Njcm9sbFBhbmVsRWxtLnNjcm9sbExlZnQ7XG5cblxuICAgICAgdmFyIHZlcnRpY2FsID0ge1xuICAgICAgICB0eXBlOiAndmVydGljYWwnXG4gICAgICB9O1xuICAgICAgdmFyIGhvcml6b250YWwgPSB7XG4gICAgICAgIHR5cGU6ICdob3Jpem9udGFsJ1xuICAgICAgfTtcblxuICAgICAgdmFyIF9nZXRTY3JvbGxQcm9jZXNzID0gdGhpcy5nZXRTY3JvbGxQcm9jZXNzKCksXG4gICAgICAgICAgdiA9IF9nZXRTY3JvbGxQcm9jZXNzLnYsXG4gICAgICAgICAgaCA9IF9nZXRTY3JvbGxQcm9jZXNzLmg7XG5cbiAgICAgIHZlcnRpY2FsLnByb2Nlc3MgPSB2O1xuICAgICAgaG9yaXpvbnRhbC5wcm9jZXNzID0gaDtcblxuICAgICAgdmVydGljYWxbJ2JhclNpemUnXSA9IHRoaXMuYmFyLnZCYXIuc3RhdGUuc2l6ZTtcbiAgICAgIGhvcml6b250YWxbJ2JhclNpemUnXSA9IHRoaXMuYmFyLmhCYXIuc3RhdGUuc2l6ZTtcbiAgICAgIHZlcnRpY2FsWydzY3JvbGxUb3AnXSA9IHNjcm9sbFRvcDtcbiAgICAgIGhvcml6b250YWxbJ3Njcm9sbExlZnQnXSA9IHNjcm9sbExlZnQ7XG5cbiAgICAgIHRoaXMuJGVtaXQoZXZlbnRUeXBlLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCwgbmF0aXZlRXZlbnQpO1xuICAgIH0sXG4gICAgaW5pdFZhcmlhYmxlczogZnVuY3Rpb24gaW5pdFZhcmlhYmxlcygpIHtcbiAgICAgIHRoaXMuJGVsLl9pc1Z1ZXNjcm9sbCA9IHRydWU7XG4gICAgfSxcbiAgICByZWZyZXNoSW50ZXJuYWxTdGF0dXM6IGZ1bmN0aW9uIHJlZnJlc2hJbnRlcm5hbFN0YXR1cygpIHtcbiAgICAgIC8vIDEuc2V0IHZ1ZXNjcm9sbCBoZWlnaHQgb3Igd2lkdGggYWNjb3JkaW5nIHRvXG4gICAgICAvLyBzaXplU3RyYXRlZ3lcbiAgICAgIHRoaXMuc2V0VnNTaXplKCk7XG4gICAgICAvLyAyLiByZWdpc3RyeSByZXNpemUgZXZlbnRcbiAgICAgIHRoaXMucmVnaXN0cnlSZXNpemUoKTtcbiAgICAgIC8vIDMuIHVwZGF0ZSBzY3JvbGxiYXIncyBoZWlnaHQvd2lkdGhcbiAgICAgIHRoaXMudXBkYXRlQmFyU3RhdGVBbmRFbWl0RXZlbnQoJ3JlZnJlc2gtc3RhdHVzJyk7XG4gICAgfSxcbiAgICByZWdpc3RyeVJlc2l6ZTogZnVuY3Rpb24gcmVnaXN0cnlSZXNpemUoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVzaXplRW5hYmxlID0gdGhpcy5tZXJnZWRPcHRpb25zLnZ1ZXNjcm9sbC5kZXRlY3RSZXNpemU7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAodGhpcy5kZXN0cm95UmVzaXplICYmIHJlc2l6ZUVuYWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRlc3Ryb3lSZXNpemUpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95UmVzaXplKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzaXplRW5hYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRlbnRFbG0gPSB0aGlzLnNjcm9sbENvbnRlbnRFbG07XG5cbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICB2YXIgaGFuZGxlV2luZG93UmVzaXplID0gZnVuY3Rpb24gaGFuZGxlV2luZG93UmVzaXplKCkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi97XG4gICAgICAgIHZtLnVwZGF0ZUJhclN0YXRlQW5kRW1pdEV2ZW50KCd3aW5kb3ctcmVzaXplJyk7XG4gICAgICB9O1xuICAgICAgdmFyIGhhbmRsZURvbVJlc2l6ZSA9IGZ1bmN0aW9uIGhhbmRsZURvbVJlc2l6ZSgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTaXplID0ge307XG4gICAgICAgIGN1cnJlbnRTaXplWyd3aWR0aCddID0gX3RoaXMuc2Nyb2xsUGFuZWxFbG0uc2Nyb2xsV2lkdGg7XG4gICAgICAgIGN1cnJlbnRTaXplWydoZWlnaHQnXSA9IF90aGlzLnNjcm9sbFBhbmVsRWxtLnNjcm9sbEhlaWdodDtcbiAgICAgICAgX3RoaXMudXBkYXRlQmFyU3RhdGVBbmRFbWl0RXZlbnQoJ2hhbmRsZS1yZXNpemUnLCBjdXJyZW50U2l6ZSk7XG5cbiAgICAgICAgLy8gU2luY2UgY29udGVudCBzaWUgY2hhbmdlcywgd2Ugc2hvdWxkIHRlbGwgcGFyZW50IHRvIHNldFxuICAgICAgICAvLyBjb3JyZWN0IHNpemUgdG8gZml0IGNvbnRlbnQncyBzaXplXG4gICAgICAgIF90aGlzLnNldFZzU2l6ZSgpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVXaW5kb3dSZXNpemUsIGZhbHNlKTtcblxuICAgICAgdmFyIGRlc3Ryb3lEb21SZXNpemUgPSBpbnN0YWxsUmVzaXplRGV0ZWN0aW9uKGNvbnRlbnRFbG0sIGhhbmRsZURvbVJlc2l6ZSk7XG5cbiAgICAgIHZhciBkZXN0cm95V2luZG93UmVzaXplID0gZnVuY3Rpb24gZGVzdHJveVdpbmRvd1Jlc2l6ZSgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVdpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5kZXN0cm95UmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkZXN0cm95V2luZG93UmVzaXplKCk7XG4gICAgICAgIGRlc3Ryb3lEb21SZXNpemUoKTtcblxuICAgICAgICBfdGhpcy5kZXN0cm95UmVzaXplID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24gZ2V0UG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGNvbmZpZyA9IHtcbiAgdnVlc2Nyb2xsOiB7XG4gICAgd2hlZWxTY3JvbGxEdXJhdGlvbjogMCxcbiAgICB3aGVlbERpcmVjdGlvblJldmVyc2U6IGZhbHNlLFxuICAgIGNoZWNrU2hpZnRLZXk6IHRydWVcbiAgfVxufTtcblxudmFyIGNvbXBvbmVudCA9IF9pbnN0YWxsKGNvcmUsIGNyZWF0ZVBhbmVsLCBbY29uZmlnXSk7XG5cbmZ1bmN0aW9uIGluc3RhbGwoVnVlJCQxKSB7XG4gIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICBWdWUkJDEuY29tcG9uZW50KG9wdHMubmFtZSB8fCBjb21wb25lbnQubmFtZSwgY29tcG9uZW50KTtcbiAgVnVlJCQxLnByb3RvdHlwZS4kdnVlc2Nyb2xsQ29uZmlnID0gb3B0cy5vcHMgfHwge307XG59XG5cbnZhciBWdWVzY3JvbGwgPSBfZXh0ZW5kcyh7XG4gIGluc3RhbGw6IGluc3RhbGwsXG4gIHZlcnNpb246ICc0LjE3LjMnLFxuICByZWZyZXNoQWxsOiByZWZyZXNoQWxsLFxuICBzY3JvbGxUbzogc2Nyb2xsVG9cbn0sIGNvbXBvbmVudCk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgd2luZG93LlZ1ZS51c2UoVnVlc2Nyb2xsKTtcbn1cblxucmV0dXJuIFZ1ZXNjcm9sbDtcblxufSkpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5680\n")},629:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Se\": function() { return /* binding */ mapGetters; }\n/* harmony export */ });\n/* unused harmony exports Store, createLogger, createNamespacedHelpers, install, mapActions, mapMutations, mapState */\n/*!\n * vuex v3.6.2\n * (c) 2021 Evan You\n * @license MIT\n */\nfunction applyMixin (Vue) {\n  var version = Number(Vue.version.split('.')[0]);\n\n  if (version >= 2) {\n    Vue.mixin({ beforeCreate: vuexInit });\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    var _init = Vue.prototype._init;\n    Vue.prototype._init = function (options) {\n      if ( options === void 0 ) options = {};\n\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit;\n      _init.call(this, options);\n    };\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit () {\n    var options = this.$options;\n    // store injection\n    if (options.store) {\n      this.$store = typeof options.store === 'function'\n        ? options.store()\n        : options.store;\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store;\n    }\n  }\n}\n\nvar target = typeof window !== 'undefined'\n  ? window\n  : typeof __webpack_require__.g !== 'undefined'\n    ? __webpack_require__.g\n    : {};\nvar devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\nfunction devtoolPlugin (store) {\n  if (!devtoolHook) { return }\n\n  store._devtoolHook = devtoolHook;\n\n  devtoolHook.emit('vuex:init', store);\n\n  devtoolHook.on('vuex:travel-to-state', function (targetState) {\n    store.replaceState(targetState);\n  });\n\n  store.subscribe(function (mutation, state) {\n    devtoolHook.emit('vuex:mutation', mutation, state);\n  }, { prepend: true });\n\n  store.subscribeAction(function (action, state) {\n    devtoolHook.emit('vuex:action', action, state);\n  }, { prepend: true });\n}\n\n/**\n * Get the first item that pass the test\n * by second argument function\n *\n * @param {Array} list\n * @param {Function} f\n * @return {*}\n */\nfunction find (list, f) {\n  return list.filter(f)[0]\n}\n\n/**\n * Deep copy the given object considering circular structure.\n * This function caches all nested objects and its copies.\n * If it detects circular structure, use cached copy to avoid infinite loop.\n *\n * @param {*} obj\n * @param {Array<Object>} cache\n * @return {*}\n */\nfunction deepCopy (obj, cache) {\n  if ( cache === void 0 ) cache = [];\n\n  // just return if obj is immutable value\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  // if obj is hit, it is in circular structure\n  var hit = find(cache, function (c) { return c.original === obj; });\n  if (hit) {\n    return hit.copy\n  }\n\n  var copy = Array.isArray(obj) ? [] : {};\n  // put the copy into cache at first\n  // because we want to refer it in recursive deepCopy\n  cache.push({\n    original: obj,\n    copy: copy\n  });\n\n  Object.keys(obj).forEach(function (key) {\n    copy[key] = deepCopy(obj[key], cache);\n  });\n\n  return copy\n}\n\n/**\n * forEach for object\n */\nfunction forEachValue (obj, fn) {\n  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });\n}\n\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nfunction isPromise (val) {\n  return val && typeof val.then === 'function'\n}\n\nfunction assert (condition, msg) {\n  if (!condition) { throw new Error((\"[vuex] \" + msg)) }\n}\n\nfunction partial (fn, arg) {\n  return function () {\n    return fn(arg)\n  }\n}\n\n// Base data struct for store's module, package with some attribute and method\nvar Module = function Module (rawModule, runtime) {\n  this.runtime = runtime;\n  // Store some children item\n  this._children = Object.create(null);\n  // Store the origin module object which passed by programmer\n  this._rawModule = rawModule;\n  var rawState = rawModule.state;\n\n  // Store the origin module's state\n  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};\n};\n\nvar prototypeAccessors = { namespaced: { configurable: true } };\n\nprototypeAccessors.namespaced.get = function () {\n  return !!this._rawModule.namespaced\n};\n\nModule.prototype.addChild = function addChild (key, module) {\n  this._children[key] = module;\n};\n\nModule.prototype.removeChild = function removeChild (key) {\n  delete this._children[key];\n};\n\nModule.prototype.getChild = function getChild (key) {\n  return this._children[key]\n};\n\nModule.prototype.hasChild = function hasChild (key) {\n  return key in this._children\n};\n\nModule.prototype.update = function update (rawModule) {\n  this._rawModule.namespaced = rawModule.namespaced;\n  if (rawModule.actions) {\n    this._rawModule.actions = rawModule.actions;\n  }\n  if (rawModule.mutations) {\n    this._rawModule.mutations = rawModule.mutations;\n  }\n  if (rawModule.getters) {\n    this._rawModule.getters = rawModule.getters;\n  }\n};\n\nModule.prototype.forEachChild = function forEachChild (fn) {\n  forEachValue(this._children, fn);\n};\n\nModule.prototype.forEachGetter = function forEachGetter (fn) {\n  if (this._rawModule.getters) {\n    forEachValue(this._rawModule.getters, fn);\n  }\n};\n\nModule.prototype.forEachAction = function forEachAction (fn) {\n  if (this._rawModule.actions) {\n    forEachValue(this._rawModule.actions, fn);\n  }\n};\n\nModule.prototype.forEachMutation = function forEachMutation (fn) {\n  if (this._rawModule.mutations) {\n    forEachValue(this._rawModule.mutations, fn);\n  }\n};\n\nObject.defineProperties( Module.prototype, prototypeAccessors );\n\nvar ModuleCollection = function ModuleCollection (rawRootModule) {\n  // register root module (Vuex.Store options)\n  this.register([], rawRootModule, false);\n};\n\nModuleCollection.prototype.get = function get (path) {\n  return path.reduce(function (module, key) {\n    return module.getChild(key)\n  }, this.root)\n};\n\nModuleCollection.prototype.getNamespace = function getNamespace (path) {\n  var module = this.root;\n  return path.reduce(function (namespace, key) {\n    module = module.getChild(key);\n    return namespace + (module.namespaced ? key + '/' : '')\n  }, '')\n};\n\nModuleCollection.prototype.update = function update$1 (rawRootModule) {\n  update([], this.root, rawRootModule);\n};\n\nModuleCollection.prototype.register = function register (path, rawModule, runtime) {\n    var this$1 = this;\n    if ( runtime === void 0 ) runtime = true;\n\n  if ((false)) {}\n\n  var newModule = new Module(rawModule, runtime);\n  if (path.length === 0) {\n    this.root = newModule;\n  } else {\n    var parent = this.get(path.slice(0, -1));\n    parent.addChild(path[path.length - 1], newModule);\n  }\n\n  // register nested modules\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, function (rawChildModule, key) {\n      this$1.register(path.concat(key), rawChildModule, runtime);\n    });\n  }\n};\n\nModuleCollection.prototype.unregister = function unregister (path) {\n  var parent = this.get(path.slice(0, -1));\n  var key = path[path.length - 1];\n  var child = parent.getChild(key);\n\n  if (!child) {\n    if ((false)) {}\n    return\n  }\n\n  if (!child.runtime) {\n    return\n  }\n\n  parent.removeChild(key);\n};\n\nModuleCollection.prototype.isRegistered = function isRegistered (path) {\n  var parent = this.get(path.slice(0, -1));\n  var key = path[path.length - 1];\n\n  if (parent) {\n    return parent.hasChild(key)\n  }\n\n  return false\n};\n\nfunction update (path, targetModule, newModule) {\n  if ((false)) {}\n\n  // update target module\n  targetModule.update(newModule);\n\n  // update nested modules\n  if (newModule.modules) {\n    for (var key in newModule.modules) {\n      if (!targetModule.getChild(key)) {\n        if ((false)) {}\n        return\n      }\n      update(\n        path.concat(key),\n        targetModule.getChild(key),\n        newModule.modules[key]\n      );\n    }\n  }\n}\n\nvar functionAssert = {\n  assert: function (value) { return typeof value === 'function'; },\n  expected: 'function'\n};\n\nvar objectAssert = {\n  assert: function (value) { return typeof value === 'function' ||\n    (typeof value === 'object' && typeof value.handler === 'function'); },\n  expected: 'function or object with \"handler\" function'\n};\n\nvar assertTypes = {\n  getters: functionAssert,\n  mutations: functionAssert,\n  actions: objectAssert\n};\n\nfunction assertRawModule (path, rawModule) {\n  Object.keys(assertTypes).forEach(function (key) {\n    if (!rawModule[key]) { return }\n\n    var assertOptions = assertTypes[key];\n\n    forEachValue(rawModule[key], function (value, type) {\n      assert(\n        assertOptions.assert(value),\n        makeAssertionMessage(path, key, type, value, assertOptions.expected)\n      );\n    });\n  });\n}\n\nfunction makeAssertionMessage (path, key, type, value, expected) {\n  var buf = key + \" should be \" + expected + \" but \\\"\" + key + \".\" + type + \"\\\"\";\n  if (path.length > 0) {\n    buf += \" in module \\\"\" + (path.join('.')) + \"\\\"\";\n  }\n  buf += \" is \" + (JSON.stringify(value)) + \".\";\n  return buf\n}\n\nvar Vue; // bind on install\n\nvar Store = function Store (options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  // Auto install if it is not done yet and `window` has `Vue`.\n  // To allow users to avoid auto-installation in some cases,\n  // this code should be placed here. See #731\n  if (!Vue && typeof window !== 'undefined' && window.Vue) {\n    install(window.Vue);\n  }\n\n  if ((false)) {}\n\n  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];\n  var strict = options.strict; if ( strict === void 0 ) strict = false;\n\n  // store internal state\n  this._committing = false;\n  this._actions = Object.create(null);\n  this._actionSubscribers = [];\n  this._mutations = Object.create(null);\n  this._wrappedGetters = Object.create(null);\n  this._modules = new ModuleCollection(options);\n  this._modulesNamespaceMap = Object.create(null);\n  this._subscribers = [];\n  this._watcherVM = new Vue();\n  this._makeLocalGettersCache = Object.create(null);\n\n  // bind commit and dispatch to self\n  var store = this;\n  var ref = this;\n  var dispatch = ref.dispatch;\n  var commit = ref.commit;\n  this.dispatch = function boundDispatch (type, payload) {\n    return dispatch.call(store, type, payload)\n  };\n  this.commit = function boundCommit (type, payload, options) {\n    return commit.call(store, type, payload, options)\n  };\n\n  // strict mode\n  this.strict = strict;\n\n  var state = this._modules.root.state;\n\n  // init root module.\n  // this also recursively registers all sub-modules\n  // and collects all module getters inside this._wrappedGetters\n  installModule(this, state, [], this._modules.root);\n\n  // initialize the store vm, which is responsible for the reactivity\n  // (also registers _wrappedGetters as computed properties)\n  resetStoreVM(this, state);\n\n  // apply plugins\n  plugins.forEach(function (plugin) { return plugin(this$1); });\n\n  var useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools;\n  if (useDevtools) {\n    devtoolPlugin(this);\n  }\n};\n\nvar prototypeAccessors$1 = { state: { configurable: true } };\n\nprototypeAccessors$1.state.get = function () {\n  return this._vm._data.$$state\n};\n\nprototypeAccessors$1.state.set = function (v) {\n  if ((false)) {}\n};\n\nStore.prototype.commit = function commit (_type, _payload, _options) {\n    var this$1 = this;\n\n  // check object-style commit\n  var ref = unifyObjectStyle(_type, _payload, _options);\n    var type = ref.type;\n    var payload = ref.payload;\n    var options = ref.options;\n\n  var mutation = { type: type, payload: payload };\n  var entry = this._mutations[type];\n  if (!entry) {\n    if ((false)) {}\n    return\n  }\n  this._withCommit(function () {\n    entry.forEach(function commitIterator (handler) {\n      handler(payload);\n    });\n  });\n\n  this._subscribers\n    .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe\n    .forEach(function (sub) { return sub(mutation, this$1.state); });\n\n  if (\n    false\n  ) {}\n};\n\nStore.prototype.dispatch = function dispatch (_type, _payload) {\n    var this$1 = this;\n\n  // check object-style dispatch\n  var ref = unifyObjectStyle(_type, _payload);\n    var type = ref.type;\n    var payload = ref.payload;\n\n  var action = { type: type, payload: payload };\n  var entry = this._actions[type];\n  if (!entry) {\n    if ((false)) {}\n    return\n  }\n\n  try {\n    this._actionSubscribers\n      .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe\n      .filter(function (sub) { return sub.before; })\n      .forEach(function (sub) { return sub.before(action, this$1.state); });\n  } catch (e) {\n    if ((false)) {}\n  }\n\n  var result = entry.length > 1\n    ? Promise.all(entry.map(function (handler) { return handler(payload); }))\n    : entry[0](payload);\n\n  return new Promise(function (resolve, reject) {\n    result.then(function (res) {\n      try {\n        this$1._actionSubscribers\n          .filter(function (sub) { return sub.after; })\n          .forEach(function (sub) { return sub.after(action, this$1.state); });\n      } catch (e) {\n        if ((false)) {}\n      }\n      resolve(res);\n    }, function (error) {\n      try {\n        this$1._actionSubscribers\n          .filter(function (sub) { return sub.error; })\n          .forEach(function (sub) { return sub.error(action, this$1.state, error); });\n      } catch (e) {\n        if ((false)) {}\n      }\n      reject(error);\n    });\n  })\n};\n\nStore.prototype.subscribe = function subscribe (fn, options) {\n  return genericSubscribe(fn, this._subscribers, options)\n};\n\nStore.prototype.subscribeAction = function subscribeAction (fn, options) {\n  var subs = typeof fn === 'function' ? { before: fn } : fn;\n  return genericSubscribe(subs, this._actionSubscribers, options)\n};\n\nStore.prototype.watch = function watch (getter, cb, options) {\n    var this$1 = this;\n\n  if ((false)) {}\n  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)\n};\n\nStore.prototype.replaceState = function replaceState (state) {\n    var this$1 = this;\n\n  this._withCommit(function () {\n    this$1._vm._data.$$state = state;\n  });\n};\n\nStore.prototype.registerModule = function registerModule (path, rawModule, options) {\n    if ( options === void 0 ) options = {};\n\n  if (typeof path === 'string') { path = [path]; }\n\n  if ((false)) {}\n\n  this._modules.register(path, rawModule);\n  installModule(this, this.state, path, this._modules.get(path), options.preserveState);\n  // reset store to update getters...\n  resetStoreVM(this, this.state);\n};\n\nStore.prototype.unregisterModule = function unregisterModule (path) {\n    var this$1 = this;\n\n  if (typeof path === 'string') { path = [path]; }\n\n  if ((false)) {}\n\n  this._modules.unregister(path);\n  this._withCommit(function () {\n    var parentState = getNestedState(this$1.state, path.slice(0, -1));\n    Vue.delete(parentState, path[path.length - 1]);\n  });\n  resetStore(this);\n};\n\nStore.prototype.hasModule = function hasModule (path) {\n  if (typeof path === 'string') { path = [path]; }\n\n  if ((false)) {}\n\n  return this._modules.isRegistered(path)\n};\n\nStore.prototype.hotUpdate = function hotUpdate (newOptions) {\n  this._modules.update(newOptions);\n  resetStore(this, true);\n};\n\nStore.prototype._withCommit = function _withCommit (fn) {\n  var committing = this._committing;\n  this._committing = true;\n  fn();\n  this._committing = committing;\n};\n\nObject.defineProperties( Store.prototype, prototypeAccessors$1 );\n\nfunction genericSubscribe (fn, subs, options) {\n  if (subs.indexOf(fn) < 0) {\n    options && options.prepend\n      ? subs.unshift(fn)\n      : subs.push(fn);\n  }\n  return function () {\n    var i = subs.indexOf(fn);\n    if (i > -1) {\n      subs.splice(i, 1);\n    }\n  }\n}\n\nfunction resetStore (store, hot) {\n  store._actions = Object.create(null);\n  store._mutations = Object.create(null);\n  store._wrappedGetters = Object.create(null);\n  store._modulesNamespaceMap = Object.create(null);\n  var state = store.state;\n  // init all modules\n  installModule(store, state, [], store._modules.root, true);\n  // reset vm\n  resetStoreVM(store, state, hot);\n}\n\nfunction resetStoreVM (store, state, hot) {\n  var oldVm = store._vm;\n\n  // bind store public getters\n  store.getters = {};\n  // reset local getters cache\n  store._makeLocalGettersCache = Object.create(null);\n  var wrappedGetters = store._wrappedGetters;\n  var computed = {};\n  forEachValue(wrappedGetters, function (fn, key) {\n    // use computed to leverage its lazy-caching mechanism\n    // direct inline function use will lead to closure preserving oldVm.\n    // using partial to return function with only arguments preserved in closure environment.\n    computed[key] = partial(fn, store);\n    Object.defineProperty(store.getters, key, {\n      get: function () { return store._vm[key]; },\n      enumerable: true // for local getters\n    });\n  });\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  var silent = Vue.config.silent;\n  Vue.config.silent = true;\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed: computed\n  });\n  Vue.config.silent = silent;\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store);\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // dispatch changes in all subscribed watchers\n      // to force getter re-evaluation for hot reloading.\n      store._withCommit(function () {\n        oldVm._data.$$state = null;\n      });\n    }\n    Vue.nextTick(function () { return oldVm.$destroy(); });\n  }\n}\n\nfunction installModule (store, rootState, path, module, hot) {\n  var isRoot = !path.length;\n  var namespace = store._modules.getNamespace(path);\n\n  // register in namespace map\n  if (module.namespaced) {\n    if (store._modulesNamespaceMap[namespace] && (\"production\" !== 'production')) {\n      console.error((\"[vuex] duplicate namespace \" + namespace + \" for the namespaced module \" + (path.join('/'))));\n    }\n    store._modulesNamespaceMap[namespace] = module;\n  }\n\n  // set state\n  if (!isRoot && !hot) {\n    var parentState = getNestedState(rootState, path.slice(0, -1));\n    var moduleName = path[path.length - 1];\n    store._withCommit(function () {\n      if ((false)) {}\n      Vue.set(parentState, moduleName, module.state);\n    });\n  }\n\n  var local = module.context = makeLocalContext(store, namespace, path);\n\n  module.forEachMutation(function (mutation, key) {\n    var namespacedType = namespace + key;\n    registerMutation(store, namespacedType, mutation, local);\n  });\n\n  module.forEachAction(function (action, key) {\n    var type = action.root ? key : namespace + key;\n    var handler = action.handler || action;\n    registerAction(store, type, handler, local);\n  });\n\n  module.forEachGetter(function (getter, key) {\n    var namespacedType = namespace + key;\n    registerGetter(store, namespacedType, getter, local);\n  });\n\n  module.forEachChild(function (child, key) {\n    installModule(store, rootState, path.concat(key), child, hot);\n  });\n}\n\n/**\n * make localized dispatch, commit, getters and state\n * if there is no namespace, just use root ones\n */\nfunction makeLocalContext (store, namespace, path) {\n  var noNamespace = namespace === '';\n\n  var local = {\n    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (false) {}\n      }\n\n      return store.dispatch(type, payload)\n    },\n\n    commit: noNamespace ? store.commit : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (false) {}\n      }\n\n      store.commit(type, payload, options);\n    }\n  };\n\n  // getters and state object must be gotten lazily\n  // because they will be changed by vm update\n  Object.defineProperties(local, {\n    getters: {\n      get: noNamespace\n        ? function () { return store.getters; }\n        : function () { return makeLocalGetters(store, namespace); }\n    },\n    state: {\n      get: function () { return getNestedState(store.state, path); }\n    }\n  });\n\n  return local\n}\n\nfunction makeLocalGetters (store, namespace) {\n  if (!store._makeLocalGettersCache[namespace]) {\n    var gettersProxy = {};\n    var splitPos = namespace.length;\n    Object.keys(store.getters).forEach(function (type) {\n      // skip if the target getter is not match this namespace\n      if (type.slice(0, splitPos) !== namespace) { return }\n\n      // extract local getter type\n      var localType = type.slice(splitPos);\n\n      // Add a port to the getters proxy.\n      // Define as getter property because\n      // we do not want to evaluate the getters in this time.\n      Object.defineProperty(gettersProxy, localType, {\n        get: function () { return store.getters[type]; },\n        enumerable: true\n      });\n    });\n    store._makeLocalGettersCache[namespace] = gettersProxy;\n  }\n\n  return store._makeLocalGettersCache[namespace]\n}\n\nfunction registerMutation (store, type, handler, local) {\n  var entry = store._mutations[type] || (store._mutations[type] = []);\n  entry.push(function wrappedMutationHandler (payload) {\n    handler.call(store, local.state, payload);\n  });\n}\n\nfunction registerAction (store, type, handler, local) {\n  var entry = store._actions[type] || (store._actions[type] = []);\n  entry.push(function wrappedActionHandler (payload) {\n    var res = handler.call(store, {\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload);\n    if (!isPromise(res)) {\n      res = Promise.resolve(res);\n    }\n    if (store._devtoolHook) {\n      return res.catch(function (err) {\n        store._devtoolHook.emit('vuex:error', err);\n        throw err\n      })\n    } else {\n      return res\n    }\n  });\n}\n\nfunction registerGetter (store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    if ((false)) {}\n    return\n  }\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    return rawGetter(\n      local.state, // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  };\n}\n\nfunction enableStrictMode (store) {\n  store._vm.$watch(function () { return this._data.$$state }, function () {\n    if ((false)) {}\n  }, { deep: true, sync: true });\n}\n\nfunction getNestedState (state, path) {\n  return path.reduce(function (state, key) { return state[key]; }, state)\n}\n\nfunction unifyObjectStyle (type, payload, options) {\n  if (isObject(type) && type.type) {\n    options = payload;\n    payload = type;\n    type = type.type;\n  }\n\n  if ((false)) {}\n\n  return { type: type, payload: payload, options: options }\n}\n\nfunction install (_Vue) {\n  if (Vue && _Vue === Vue) {\n    if ((false)) {}\n    return\n  }\n  Vue = _Vue;\n  applyMixin(Vue);\n}\n\n/**\n * Reduce the code which written in Vue.js for getting the state.\n * @param {String} [namespace] - Module's namespace\n * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.\n * @param {Object}\n */\nvar mapState = normalizeNamespace(function (namespace, states) {\n  var res = {};\n  if (false) {}\n  normalizeMap(states).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedState () {\n      var state = this.$store.state;\n      var getters = this.$store.getters;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapState', namespace);\n        if (!module) {\n          return\n        }\n        state = module.context.state;\n        getters = module.context.getters;\n      }\n      return typeof val === 'function'\n        ? val.call(this, state, getters)\n        : state[val]\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res\n});\n\n/**\n * Reduce the code which written in Vue.js for committing the mutation\n * @param {String} [namespace] - Module's namespace\n * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept another params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.\n * @return {Object}\n */\nvar mapMutations = normalizeNamespace(function (namespace, mutations) {\n  var res = {};\n  if (false) {}\n  normalizeMap(mutations).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedMutation () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      // Get the commit method from store\n      var commit = this.$store.commit;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);\n        if (!module) {\n          return\n        }\n        commit = module.context.commit;\n      }\n      return typeof val === 'function'\n        ? val.apply(this, [commit].concat(args))\n        : commit.apply(this.$store, [val].concat(args))\n    };\n  });\n  return res\n});\n\n/**\n * Reduce the code which written in Vue.js for getting the getters\n * @param {String} [namespace] - Module's namespace\n * @param {Object|Array} getters\n * @return {Object}\n */\nvar mapGetters = normalizeNamespace(function (namespace, getters) {\n  var res = {};\n  if (false) {}\n  normalizeMap(getters).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    // The namespace has been mutated by normalizeNamespace\n    val = namespace + val;\n    res[key] = function mappedGetter () {\n      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {\n        return\n      }\n      if (false) {}\n      return this.$store.getters[val]\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res\n});\n\n/**\n * Reduce the code which written in Vue.js for dispatch the action\n * @param {String} [namespace] - Module's namespace\n * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.\n * @return {Object}\n */\nvar mapActions = normalizeNamespace(function (namespace, actions) {\n  var res = {};\n  if (false) {}\n  normalizeMap(actions).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedAction () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      // get dispatch function from store\n      var dispatch = this.$store.dispatch;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);\n        if (!module) {\n          return\n        }\n        dispatch = module.context.dispatch;\n      }\n      return typeof val === 'function'\n        ? val.apply(this, [dispatch].concat(args))\n        : dispatch.apply(this.$store, [val].concat(args))\n    };\n  });\n  return res\n});\n\n/**\n * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object\n * @param {String} namespace\n * @return {Object}\n */\nvar createNamespacedHelpers = function (namespace) { return ({\n  mapState: mapState.bind(null, namespace),\n  mapGetters: mapGetters.bind(null, namespace),\n  mapMutations: mapMutations.bind(null, namespace),\n  mapActions: mapActions.bind(null, namespace)\n}); };\n\n/**\n * Normalize the map\n * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]\n * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]\n * @param {Array|Object} map\n * @return {Object}\n */\nfunction normalizeMap (map) {\n  if (!isValidMap(map)) {\n    return []\n  }\n  return Array.isArray(map)\n    ? map.map(function (key) { return ({ key: key, val: key }); })\n    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })\n}\n\n/**\n * Validate whether given map is valid or not\n * @param {*} map\n * @return {Boolean}\n */\nfunction isValidMap (map) {\n  return Array.isArray(map) || isObject(map)\n}\n\n/**\n * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.\n * @param {Function} fn\n * @return {Function}\n */\nfunction normalizeNamespace (fn) {\n  return function (namespace, map) {\n    if (typeof namespace !== 'string') {\n      map = namespace;\n      namespace = '';\n    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n      namespace += '/';\n    }\n    return fn(namespace, map)\n  }\n}\n\n/**\n * Search a special module from store by namespace. if module not exist, print error message.\n * @param {Object} store\n * @param {String} helper\n * @param {String} namespace\n * @return {Object}\n */\nfunction getModuleByNamespace (store, helper, namespace) {\n  var module = store._modulesNamespaceMap[namespace];\n  if (false) {}\n  return module\n}\n\n// Credits: borrowed code from fcomb/redux-logger\n\nfunction createLogger (ref) {\n  if ( ref === void 0 ) ref = {};\n  var collapsed = ref.collapsed; if ( collapsed === void 0 ) collapsed = true;\n  var filter = ref.filter; if ( filter === void 0 ) filter = function (mutation, stateBefore, stateAfter) { return true; };\n  var transformer = ref.transformer; if ( transformer === void 0 ) transformer = function (state) { return state; };\n  var mutationTransformer = ref.mutationTransformer; if ( mutationTransformer === void 0 ) mutationTransformer = function (mut) { return mut; };\n  var actionFilter = ref.actionFilter; if ( actionFilter === void 0 ) actionFilter = function (action, state) { return true; };\n  var actionTransformer = ref.actionTransformer; if ( actionTransformer === void 0 ) actionTransformer = function (act) { return act; };\n  var logMutations = ref.logMutations; if ( logMutations === void 0 ) logMutations = true;\n  var logActions = ref.logActions; if ( logActions === void 0 ) logActions = true;\n  var logger = ref.logger; if ( logger === void 0 ) logger = console;\n\n  return function (store) {\n    var prevState = deepCopy(store.state);\n\n    if (typeof logger === 'undefined') {\n      return\n    }\n\n    if (logMutations) {\n      store.subscribe(function (mutation, state) {\n        var nextState = deepCopy(state);\n\n        if (filter(mutation, prevState, nextState)) {\n          var formattedTime = getFormattedTime();\n          var formattedMutation = mutationTransformer(mutation);\n          var message = \"mutation \" + (mutation.type) + formattedTime;\n\n          startMessage(logger, message, collapsed);\n          logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));\n          logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);\n          logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));\n          endMessage(logger);\n        }\n\n        prevState = nextState;\n      });\n    }\n\n    if (logActions) {\n      store.subscribeAction(function (action, state) {\n        if (actionFilter(action, state)) {\n          var formattedTime = getFormattedTime();\n          var formattedAction = actionTransformer(action);\n          var message = \"action \" + (action.type) + formattedTime;\n\n          startMessage(logger, message, collapsed);\n          logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);\n          endMessage(logger);\n        }\n      });\n    }\n  }\n}\n\nfunction startMessage (logger, message, collapsed) {\n  var startMessage = collapsed\n    ? logger.groupCollapsed\n    : logger.group;\n\n  // render\n  try {\n    startMessage.call(logger, message);\n  } catch (e) {\n    logger.log(message);\n  }\n}\n\nfunction endMessage (logger) {\n  try {\n    logger.groupEnd();\n  } catch (e) {\n    logger.log('—— log end ——');\n  }\n}\n\nfunction getFormattedTime () {\n  var time = new Date();\n  return (\" @ \" + (pad(time.getHours(), 2)) + \":\" + (pad(time.getMinutes(), 2)) + \":\" + (pad(time.getSeconds(), 2)) + \".\" + (pad(time.getMilliseconds(), 3)))\n}\n\nfunction repeat (str, times) {\n  return (new Array(times + 1)).join(str)\n}\n\nfunction pad (num, maxLength) {\n  return repeat('0', maxLength - num.toString().length) + num\n}\n\nvar index = {\n  Store: Store,\n  install: install,\n  version: '3.6.2',\n  mapState: mapState,\n  mapMutations: mapMutations,\n  mapGetters: mapGetters,\n  mapActions: mapActions,\n  createNamespacedHelpers: createNamespacedHelpers,\n  createLogger: createLogger\n};\n\n/* harmony default export */ __webpack_exports__[\"ZP\"] = (index);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bGVzL3Z1ZXgvZGlzdC92dWV4LmVzbS5qcz8yZjYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogdnVleCB2My42LjJcbiAqIChjKSAyMDIxIEV2YW4gWW91XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gYXBwbHlNaXhpbiAoVnVlKSB7XG4gIHZhciB2ZXJzaW9uID0gTnVtYmVyKFZ1ZS52ZXJzaW9uLnNwbGl0KCcuJylbMF0pO1xuXG4gIGlmICh2ZXJzaW9uID49IDIpIHtcbiAgICBWdWUubWl4aW4oeyBiZWZvcmVDcmVhdGU6IHZ1ZXhJbml0IH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG92ZXJyaWRlIGluaXQgYW5kIGluamVjdCB2dWV4IGluaXQgcHJvY2VkdXJlXG4gICAgLy8gZm9yIDEueCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICB2YXIgX2luaXQgPSBWdWUucHJvdG90eXBlLl9pbml0O1xuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgICAgIG9wdGlvbnMuaW5pdCA9IG9wdGlvbnMuaW5pdFxuICAgICAgICA/IFt2dWV4SW5pdF0uY29uY2F0KG9wdGlvbnMuaW5pdClcbiAgICAgICAgOiB2dWV4SW5pdDtcbiAgICAgIF9pbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWdWV4IGluaXQgaG9vaywgaW5qZWN0ZWQgaW50byBlYWNoIGluc3RhbmNlcyBpbml0IGhvb2tzIGxpc3QuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHZ1ZXhJbml0ICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgLy8gc3RvcmUgaW5qZWN0aW9uXG4gICAgaWYgKG9wdGlvbnMuc3RvcmUpIHtcbiAgICAgIHRoaXMuJHN0b3JlID0gdHlwZW9mIG9wdGlvbnMuc3RvcmUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBvcHRpb25zLnN0b3JlKClcbiAgICAgICAgOiBvcHRpb25zLnN0b3JlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wYXJlbnQgJiYgb3B0aW9ucy5wYXJlbnQuJHN0b3JlKSB7XG4gICAgICB0aGlzLiRzdG9yZSA9IG9wdGlvbnMucGFyZW50LiRzdG9yZTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHRhcmdldCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gID8gd2luZG93XG4gIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IGdsb2JhbFxuICAgIDoge307XG52YXIgZGV2dG9vbEhvb2sgPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuZnVuY3Rpb24gZGV2dG9vbFBsdWdpbiAoc3RvcmUpIHtcbiAgaWYgKCFkZXZ0b29sSG9vaykgeyByZXR1cm4gfVxuXG4gIHN0b3JlLl9kZXZ0b29sSG9vayA9IGRldnRvb2xIb29rO1xuXG4gIGRldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6aW5pdCcsIHN0b3JlKTtcblxuICBkZXZ0b29sSG9vay5vbigndnVleDp0cmF2ZWwtdG8tc3RhdGUnLCBmdW5jdGlvbiAodGFyZ2V0U3RhdGUpIHtcbiAgICBzdG9yZS5yZXBsYWNlU3RhdGUodGFyZ2V0U3RhdGUpO1xuICB9KTtcblxuICBzdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKG11dGF0aW9uLCBzdGF0ZSkge1xuICAgIGRldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6bXV0YXRpb24nLCBtdXRhdGlvbiwgc3RhdGUpO1xuICB9LCB7IHByZXBlbmQ6IHRydWUgfSk7XG5cbiAgc3RvcmUuc3Vic2NyaWJlQWN0aW9uKGZ1bmN0aW9uIChhY3Rpb24sIHN0YXRlKSB7XG4gICAgZGV2dG9vbEhvb2suZW1pdCgndnVleDphY3Rpb24nLCBhY3Rpb24sIHN0YXRlKTtcbiAgfSwgeyBwcmVwZW5kOiB0cnVlIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZmlyc3QgaXRlbSB0aGF0IHBhc3MgdGhlIHRlc3RcbiAqIGJ5IHNlY29uZCBhcmd1bWVudCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEByZXR1cm4geyp9XG4gKi9cbmZ1bmN0aW9uIGZpbmQgKGxpc3QsIGYpIHtcbiAgcmV0dXJuIGxpc3QuZmlsdGVyKGYpWzBdXG59XG5cbi8qKlxuICogRGVlcCBjb3B5IHRoZSBnaXZlbiBvYmplY3QgY29uc2lkZXJpbmcgY2lyY3VsYXIgc3RydWN0dXJlLlxuICogVGhpcyBmdW5jdGlvbiBjYWNoZXMgYWxsIG5lc3RlZCBvYmplY3RzIGFuZCBpdHMgY29waWVzLlxuICogSWYgaXQgZGV0ZWN0cyBjaXJjdWxhciBzdHJ1Y3R1cmUsIHVzZSBjYWNoZWQgY29weSB0byBhdm9pZCBpbmZpbml0ZSBsb29wLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGNhY2hlXG4gKiBAcmV0dXJuIHsqfVxuICovXG5mdW5jdGlvbiBkZWVwQ29weSAob2JqLCBjYWNoZSkge1xuICBpZiAoIGNhY2hlID09PSB2b2lkIDAgKSBjYWNoZSA9IFtdO1xuXG4gIC8vIGp1c3QgcmV0dXJuIGlmIG9iaiBpcyBpbW11dGFibGUgdmFsdWVcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvYmpcbiAgfVxuXG4gIC8vIGlmIG9iaiBpcyBoaXQsIGl0IGlzIGluIGNpcmN1bGFyIHN0cnVjdHVyZVxuICB2YXIgaGl0ID0gZmluZChjYWNoZSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMub3JpZ2luYWwgPT09IG9iajsgfSk7XG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0LmNvcHlcbiAgfVxuXG4gIHZhciBjb3B5ID0gQXJyYXkuaXNBcnJheShvYmopID8gW10gOiB7fTtcbiAgLy8gcHV0IHRoZSBjb3B5IGludG8gY2FjaGUgYXQgZmlyc3RcbiAgLy8gYmVjYXVzZSB3ZSB3YW50IHRvIHJlZmVyIGl0IGluIHJlY3Vyc2l2ZSBkZWVwQ29weVxuICBjYWNoZS5wdXNoKHtcbiAgICBvcmlnaW5hbDogb2JqLFxuICAgIGNvcHk6IGNvcHlcbiAgfSk7XG5cbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBjb3B5W2tleV0gPSBkZWVwQ29weShvYmpba2V5XSwgY2FjaGUpO1xuICB9KTtcblxuICByZXR1cm4gY29weVxufVxuXG4vKipcbiAqIGZvckVhY2ggZm9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBmb3JFYWNoVmFsdWUgKG9iaiwgZm4pIHtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKG9ialtrZXldLCBrZXkpOyB9KTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtc2cpIHtcbiAgaWYgKCFjb25kaXRpb24pIHsgdGhyb3cgbmV3IEVycm9yKChcIlt2dWV4XSBcIiArIG1zZykpIH1cbn1cblxuZnVuY3Rpb24gcGFydGlhbCAoZm4sIGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbihhcmcpXG4gIH1cbn1cblxuLy8gQmFzZSBkYXRhIHN0cnVjdCBmb3Igc3RvcmUncyBtb2R1bGUsIHBhY2thZ2Ugd2l0aCBzb21lIGF0dHJpYnV0ZSBhbmQgbWV0aG9kXG52YXIgTW9kdWxlID0gZnVuY3Rpb24gTW9kdWxlIChyYXdNb2R1bGUsIHJ1bnRpbWUpIHtcbiAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcbiAgLy8gU3RvcmUgc29tZSBjaGlsZHJlbiBpdGVtXG4gIHRoaXMuX2NoaWxkcmVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gU3RvcmUgdGhlIG9yaWdpbiBtb2R1bGUgb2JqZWN0IHdoaWNoIHBhc3NlZCBieSBwcm9ncmFtbWVyXG4gIHRoaXMuX3Jhd01vZHVsZSA9IHJhd01vZHVsZTtcbiAgdmFyIHJhd1N0YXRlID0gcmF3TW9kdWxlLnN0YXRlO1xuXG4gIC8vIFN0b3JlIHRoZSBvcmlnaW4gbW9kdWxlJ3Mgc3RhdGVcbiAgdGhpcy5zdGF0ZSA9ICh0eXBlb2YgcmF3U3RhdGUgPT09ICdmdW5jdGlvbicgPyByYXdTdGF0ZSgpIDogcmF3U3RhdGUpIHx8IHt9O1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgbmFtZXNwYWNlZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMubmFtZXNwYWNlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIXRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQgKGtleSwgbW9kdWxlKSB7XG4gIHRoaXMuX2NoaWxkcmVuW2tleV0gPSBtb2R1bGU7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKGtleSkge1xuICBkZWxldGUgdGhpcy5fY2hpbGRyZW5ba2V5XTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiBnZXRDaGlsZCAoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9jaGlsZHJlbltrZXldXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmhhc0NoaWxkID0gZnVuY3Rpb24gaGFzQ2hpbGQgKGtleSkge1xuICByZXR1cm4ga2V5IGluIHRoaXMuX2NoaWxkcmVuXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAocmF3TW9kdWxlKSB7XG4gIHRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkID0gcmF3TW9kdWxlLm5hbWVzcGFjZWQ7XG4gIGlmIChyYXdNb2R1bGUuYWN0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zID0gcmF3TW9kdWxlLmFjdGlvbnM7XG4gIH1cbiAgaWYgKHJhd01vZHVsZS5tdXRhdGlvbnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zID0gcmF3TW9kdWxlLm11dGF0aW9ucztcbiAgfVxuICBpZiAocmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycyA9IHJhd01vZHVsZS5nZXR0ZXJzO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIGZvckVhY2hDaGlsZCAoZm4pIHtcbiAgZm9yRWFjaFZhbHVlKHRoaXMuX2NoaWxkcmVuLCBmbik7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hHZXR0ZXIgPSBmdW5jdGlvbiBmb3JFYWNoR2V0dGVyIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMsIGZuKTtcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoQWN0aW9uID0gZnVuY3Rpb24gZm9yRWFjaEFjdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zLCBmbik7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaE11dGF0aW9uID0gZnVuY3Rpb24gZm9yRWFjaE11dGF0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zLCBmbik7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNb2R1bGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIE1vZHVsZUNvbGxlY3Rpb24gPSBmdW5jdGlvbiBNb2R1bGVDb2xsZWN0aW9uIChyYXdSb290TW9kdWxlKSB7XG4gIC8vIHJlZ2lzdGVyIHJvb3QgbW9kdWxlIChWdWV4LlN0b3JlIG9wdGlvbnMpXG4gIHRoaXMucmVnaXN0ZXIoW10sIHJhd1Jvb3RNb2R1bGUsIGZhbHNlKTtcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKG1vZHVsZSwga2V5KSB7XG4gICAgcmV0dXJuIG1vZHVsZS5nZXRDaGlsZChrZXkpXG4gIH0sIHRoaXMucm9vdClcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldE5hbWVzcGFjZSA9IGZ1bmN0aW9uIGdldE5hbWVzcGFjZSAocGF0aCkge1xuICB2YXIgbW9kdWxlID0gdGhpcy5yb290O1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwga2V5KSB7XG4gICAgbW9kdWxlID0gbW9kdWxlLmdldENoaWxkKGtleSk7XG4gICAgcmV0dXJuIG5hbWVzcGFjZSArIChtb2R1bGUubmFtZXNwYWNlZCA/IGtleSArICcvJyA6ICcnKVxuICB9LCAnJylcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSQxIChyYXdSb290TW9kdWxlKSB7XG4gIHVwZGF0ZShbXSwgdGhpcy5yb290LCByYXdSb290TW9kdWxlKTtcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIgKHBhdGgsIHJhd01vZHVsZSwgcnVudGltZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIGlmICggcnVudGltZSA9PT0gdm9pZCAwICkgcnVudGltZSA9IHRydWU7XG5cbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgIGFzc2VydFJhd01vZHVsZShwYXRoLCByYXdNb2R1bGUpO1xuICB9XG5cbiAgdmFyIG5ld01vZHVsZSA9IG5ldyBNb2R1bGUocmF3TW9kdWxlLCBydW50aW1lKTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5yb290ID0gbmV3TW9kdWxlO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgcGFyZW50LmFkZENoaWxkKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgbmV3TW9kdWxlKTtcbiAgfVxuXG4gIC8vIHJlZ2lzdGVyIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvckVhY2hWYWx1ZShyYXdNb2R1bGUubW9kdWxlcywgZnVuY3Rpb24gKHJhd0NoaWxkTW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMS5yZWdpc3RlcihwYXRoLmNvbmNhdChrZXkpLCByYXdDaGlsZE1vZHVsZSwgcnVudGltZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyIChwYXRoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIHZhciBjaGlsZCA9IHBhcmVudC5nZXRDaGlsZChrZXkpO1xuXG4gIGlmICghY2hpbGQpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiW3Z1ZXhdIHRyeWluZyB0byB1bnJlZ2lzdGVyIG1vZHVsZSAnXCIgKyBrZXkgKyBcIicsIHdoaWNoIGlzIFwiICtcbiAgICAgICAgXCJub3QgcmVnaXN0ZXJlZFwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICghY2hpbGQucnVudGltZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgcGFyZW50LnJlbW92ZUNoaWxkKGtleSk7XG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5pc1JlZ2lzdGVyZWQgPSBmdW5jdGlvbiBpc1JlZ2lzdGVyZWQgKHBhdGgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0KHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgdmFyIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcblxuICBpZiAocGFyZW50KSB7XG4gICAgcmV0dXJuIHBhcmVudC5oYXNDaGlsZChrZXkpXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZSAocGF0aCwgdGFyZ2V0TW9kdWxlLCBuZXdNb2R1bGUpIHtcbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgIGFzc2VydFJhd01vZHVsZShwYXRoLCBuZXdNb2R1bGUpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHRhcmdldCBtb2R1bGVcbiAgdGFyZ2V0TW9kdWxlLnVwZGF0ZShuZXdNb2R1bGUpO1xuXG4gIC8vIHVwZGF0ZSBuZXN0ZWQgbW9kdWxlc1xuICBpZiAobmV3TW9kdWxlLm1vZHVsZXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmV3TW9kdWxlLm1vZHVsZXMpIHtcbiAgICAgIGlmICghdGFyZ2V0TW9kdWxlLmdldENoaWxkKGtleSkpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiW3Z1ZXhdIHRyeWluZyB0byBhZGQgYSBuZXcgbW9kdWxlICdcIiArIGtleSArIFwiJyBvbiBob3QgcmVsb2FkaW5nLCBcIiArXG4gICAgICAgICAgICAnbWFudWFsIHJlbG9hZCBpcyBuZWVkZWQnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShcbiAgICAgICAgcGF0aC5jb25jYXQoa2V5KSxcbiAgICAgICAgdGFyZ2V0TW9kdWxlLmdldENoaWxkKGtleSksXG4gICAgICAgIG5ld01vZHVsZS5tb2R1bGVzW2tleV1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBmdW5jdGlvbkFzc2VydCA9IHtcbiAgYXNzZXJ0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJzsgfSxcbiAgZXhwZWN0ZWQ6ICdmdW5jdGlvbidcbn07XG5cbnZhciBvYmplY3RBc3NlcnQgPSB7XG4gIGFzc2VydDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUuaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyk7IH0sXG4gIGV4cGVjdGVkOiAnZnVuY3Rpb24gb3Igb2JqZWN0IHdpdGggXCJoYW5kbGVyXCIgZnVuY3Rpb24nXG59O1xuXG52YXIgYXNzZXJ0VHlwZXMgPSB7XG4gIGdldHRlcnM6IGZ1bmN0aW9uQXNzZXJ0LFxuICBtdXRhdGlvbnM6IGZ1bmN0aW9uQXNzZXJ0LFxuICBhY3Rpb25zOiBvYmplY3RBc3NlcnRcbn07XG5cbmZ1bmN0aW9uIGFzc2VydFJhd01vZHVsZSAocGF0aCwgcmF3TW9kdWxlKSB7XG4gIE9iamVjdC5rZXlzKGFzc2VydFR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIXJhd01vZHVsZVtrZXldKSB7IHJldHVybiB9XG5cbiAgICB2YXIgYXNzZXJ0T3B0aW9ucyA9IGFzc2VydFR5cGVzW2tleV07XG5cbiAgICBmb3JFYWNoVmFsdWUocmF3TW9kdWxlW2tleV0sIGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBhc3NlcnRPcHRpb25zLmFzc2VydCh2YWx1ZSksXG4gICAgICAgIG1ha2VBc3NlcnRpb25NZXNzYWdlKHBhdGgsIGtleSwgdHlwZSwgdmFsdWUsIGFzc2VydE9wdGlvbnMuZXhwZWN0ZWQpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbWFrZUFzc2VydGlvbk1lc3NhZ2UgKHBhdGgsIGtleSwgdHlwZSwgdmFsdWUsIGV4cGVjdGVkKSB7XG4gIHZhciBidWYgPSBrZXkgKyBcIiBzaG91bGQgYmUgXCIgKyBleHBlY3RlZCArIFwiIGJ1dCBcXFwiXCIgKyBrZXkgKyBcIi5cIiArIHR5cGUgKyBcIlxcXCJcIjtcbiAgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgIGJ1ZiArPSBcIiBpbiBtb2R1bGUgXFxcIlwiICsgKHBhdGguam9pbignLicpKSArIFwiXFxcIlwiO1xuICB9XG4gIGJ1ZiArPSBcIiBpcyBcIiArIChKU09OLnN0cmluZ2lmeSh2YWx1ZSkpICsgXCIuXCI7XG4gIHJldHVybiBidWZcbn1cblxudmFyIFZ1ZTsgLy8gYmluZCBvbiBpbnN0YWxsXG5cbnZhciBTdG9yZSA9IGZ1bmN0aW9uIFN0b3JlIChvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAvLyBBdXRvIGluc3RhbGwgaWYgaXQgaXMgbm90IGRvbmUgeWV0IGFuZCBgd2luZG93YCBoYXMgYFZ1ZWAuXG4gIC8vIFRvIGFsbG93IHVzZXJzIHRvIGF2b2lkIGF1dG8taW5zdGFsbGF0aW9uIGluIHNvbWUgY2FzZXMsXG4gIC8vIHRoaXMgY29kZSBzaG91bGQgYmUgcGxhY2VkIGhlcmUuIFNlZSAjNzMxXG4gIGlmICghVnVlICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgICBpbnN0YWxsKHdpbmRvdy5WdWUpO1xuICB9XG5cbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgIGFzc2VydChWdWUsIFwibXVzdCBjYWxsIFZ1ZS51c2UoVnVleCkgYmVmb3JlIGNyZWF0aW5nIGEgc3RvcmUgaW5zdGFuY2UuXCIpO1xuICAgIGFzc2VydCh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcsIFwidnVleCByZXF1aXJlcyBhIFByb21pc2UgcG9seWZpbGwgaW4gdGhpcyBicm93c2VyLlwiKTtcbiAgICBhc3NlcnQodGhpcyBpbnN0YW5jZW9mIFN0b3JlLCBcInN0b3JlIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvci5cIik7XG4gIH1cblxuICB2YXIgcGx1Z2lucyA9IG9wdGlvbnMucGx1Z2luczsgaWYgKCBwbHVnaW5zID09PSB2b2lkIDAgKSBwbHVnaW5zID0gW107XG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDsgaWYgKCBzdHJpY3QgPT09IHZvaWQgMCApIHN0cmljdCA9IGZhbHNlO1xuXG4gIC8vIHN0b3JlIGludGVybmFsIHN0YXRlXG4gIHRoaXMuX2NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgdGhpcy5fYWN0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX2FjdGlvblN1YnNjcmliZXJzID0gW107XG4gIHRoaXMuX211dGF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX3dyYXBwZWRHZXR0ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fbW9kdWxlcyA9IG5ldyBNb2R1bGVDb2xsZWN0aW9uKG9wdGlvbnMpO1xuICB0aGlzLl9tb2R1bGVzTmFtZXNwYWNlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcbiAgdGhpcy5fd2F0Y2hlclZNID0gbmV3IFZ1ZSgpO1xuICB0aGlzLl9tYWtlTG9jYWxHZXR0ZXJzQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIGJpbmQgY29tbWl0IGFuZCBkaXNwYXRjaCB0byBzZWxmXG4gIHZhciBzdG9yZSA9IHRoaXM7XG4gIHZhciByZWYgPSB0aGlzO1xuICB2YXIgZGlzcGF0Y2ggPSByZWYuZGlzcGF0Y2g7XG4gIHZhciBjb21taXQgPSByZWYuY29tbWl0O1xuICB0aGlzLmRpc3BhdGNoID0gZnVuY3Rpb24gYm91bmREaXNwYXRjaCAodHlwZSwgcGF5bG9hZCkge1xuICAgIHJldHVybiBkaXNwYXRjaC5jYWxsKHN0b3JlLCB0eXBlLCBwYXlsb2FkKVxuICB9O1xuICB0aGlzLmNvbW1pdCA9IGZ1bmN0aW9uIGJvdW5kQ29tbWl0ICh0eXBlLCBwYXlsb2FkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNvbW1pdC5jYWxsKHN0b3JlLCB0eXBlLCBwYXlsb2FkLCBvcHRpb25zKVxuICB9O1xuXG4gIC8vIHN0cmljdCBtb2RlXG4gIHRoaXMuc3RyaWN0ID0gc3RyaWN0O1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX21vZHVsZXMucm9vdC5zdGF0ZTtcblxuICAvLyBpbml0IHJvb3QgbW9kdWxlLlxuICAvLyB0aGlzIGFsc28gcmVjdXJzaXZlbHkgcmVnaXN0ZXJzIGFsbCBzdWItbW9kdWxlc1xuICAvLyBhbmQgY29sbGVjdHMgYWxsIG1vZHVsZSBnZXR0ZXJzIGluc2lkZSB0aGlzLl93cmFwcGVkR2V0dGVyc1xuICBpbnN0YWxsTW9kdWxlKHRoaXMsIHN0YXRlLCBbXSwgdGhpcy5fbW9kdWxlcy5yb290KTtcblxuICAvLyBpbml0aWFsaXplIHRoZSBzdG9yZSB2bSwgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIHRoZSByZWFjdGl2aXR5XG4gIC8vIChhbHNvIHJlZ2lzdGVycyBfd3JhcHBlZEdldHRlcnMgYXMgY29tcHV0ZWQgcHJvcGVydGllcylcbiAgcmVzZXRTdG9yZVZNKHRoaXMsIHN0YXRlKTtcblxuICAvLyBhcHBseSBwbHVnaW5zXG4gIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7IHJldHVybiBwbHVnaW4odGhpcyQxKTsgfSk7XG5cbiAgdmFyIHVzZURldnRvb2xzID0gb3B0aW9ucy5kZXZ0b29scyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXZ0b29scyA6IFZ1ZS5jb25maWcuZGV2dG9vbHM7XG4gIGlmICh1c2VEZXZ0b29scykge1xuICAgIGRldnRvb2xQbHVnaW4odGhpcyk7XG4gIH1cbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgc3RhdGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEuc3RhdGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fdm0uX2RhdGEuJCRzdGF0ZVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEuc3RhdGUuc2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgIGFzc2VydChmYWxzZSwgXCJ1c2Ugc3RvcmUucmVwbGFjZVN0YXRlKCkgdG8gZXhwbGljaXQgcmVwbGFjZSBzdG9yZSBzdGF0ZS5cIik7XG4gIH1cbn07XG5cblN0b3JlLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiBjb21taXQgKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyBjaGVjayBvYmplY3Qtc3R5bGUgY29tbWl0XG4gIHZhciByZWYgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcbiAgICB2YXIgb3B0aW9ucyA9IHJlZi5vcHRpb25zO1xuXG4gIHZhciBtdXRhdGlvbiA9IHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCB9O1xuICB2YXIgZW50cnkgPSB0aGlzLl9tdXRhdGlvbnNbdHlwZV07XG4gIGlmICghZW50cnkpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIG11dGF0aW9uIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICBlbnRyeS5mb3JFYWNoKGZ1bmN0aW9uIGNvbW1pdEl0ZXJhdG9yIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKHBheWxvYWQpO1xuICAgIH0pO1xuICB9KTtcblxuICB0aGlzLl9zdWJzY3JpYmVyc1xuICAgIC5zbGljZSgpIC8vIHNoYWxsb3cgY29weSB0byBwcmV2ZW50IGl0ZXJhdG9yIGludmFsaWRhdGlvbiBpZiBzdWJzY3JpYmVyIHN5bmNocm9ub3VzbHkgY2FsbHMgdW5zdWJzY3JpYmVcbiAgICAuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIobXV0YXRpb24sIHRoaXMkMS5zdGF0ZSk7IH0pO1xuXG4gIGlmIChcbiAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICBvcHRpb25zICYmIG9wdGlvbnMuc2lsZW50XG4gICkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiW3Z1ZXhdIG11dGF0aW9uIHR5cGU6IFwiICsgdHlwZSArIFwiLiBTaWxlbnQgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQuIFwiICtcbiAgICAgICdVc2UgdGhlIGZpbHRlciBmdW5jdGlvbmFsaXR5IGluIHRoZSB2dWUtZGV2dG9vbHMnXG4gICAgKTtcbiAgfVxufTtcblxuU3RvcmUucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2ggKF90eXBlLCBfcGF5bG9hZCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIC8vIGNoZWNrIG9iamVjdC1zdHlsZSBkaXNwYXRjaFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcblxuICB2YXIgYWN0aW9uID0geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBwYXlsb2FkIH07XG4gIHZhciBlbnRyeSA9IHRoaXMuX2FjdGlvbnNbdHlwZV07XG4gIGlmICghZW50cnkpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGFjdGlvbiB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMuX2FjdGlvblN1YnNjcmliZXJzXG4gICAgICAuc2xpY2UoKSAvLyBzaGFsbG93IGNvcHkgdG8gcHJldmVudCBpdGVyYXRvciBpbnZhbGlkYXRpb24gaWYgc3Vic2NyaWJlciBzeW5jaHJvbm91c2x5IGNhbGxzIHVuc3Vic2NyaWJlXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Yi5iZWZvcmU7IH0pXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIuYmVmb3JlKGFjdGlvbiwgdGhpcyQxLnN0YXRlKTsgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbdnVleF0gZXJyb3IgaW4gYmVmb3JlIGFjdGlvbiBzdWJzY3JpYmVyczogXCIpO1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gZW50cnkubGVuZ3RoID4gMVxuICAgID8gUHJvbWlzZS5hbGwoZW50cnkubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyKHBheWxvYWQpOyB9KSlcbiAgICA6IGVudHJ5WzBdKHBheWxvYWQpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcyQxLl9hY3Rpb25TdWJzY3JpYmVyc1xuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gc3ViLmFmdGVyOyB9KVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Yi5hZnRlcihhY3Rpb24sIHRoaXMkMS5zdGF0ZSk7IH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiW3Z1ZXhdIGVycm9yIGluIGFmdGVyIGFjdGlvbiBzdWJzY3JpYmVyczogXCIpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzKTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMkMS5fYWN0aW9uU3Vic2NyaWJlcnNcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Yi5lcnJvcjsgfSlcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIuZXJyb3IoYWN0aW9uLCB0aGlzJDEuc3RhdGUsIGVycm9yKTsgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJbdnVleF0gZXJyb3IgaW4gZXJyb3IgYWN0aW9uIHN1YnNjcmliZXJzOiBcIik7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgfSlcbn07XG5cblN0b3JlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiBzdWJzY3JpYmUgKGZuLCBvcHRpb25zKSB7XG4gIHJldHVybiBnZW5lcmljU3Vic2NyaWJlKGZuLCB0aGlzLl9zdWJzY3JpYmVycywgb3B0aW9ucylcbn07XG5cblN0b3JlLnByb3RvdHlwZS5zdWJzY3JpYmVBY3Rpb24gPSBmdW5jdGlvbiBzdWJzY3JpYmVBY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gIHZhciBzdWJzID0gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8geyBiZWZvcmU6IGZuIH0gOiBmbjtcbiAgcmV0dXJuIGdlbmVyaWNTdWJzY3JpYmUoc3VicywgdGhpcy5fYWN0aW9uU3Vic2NyaWJlcnMsIG9wdGlvbnMpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiB3YXRjaCAoZ2V0dGVyLCBjYiwgb3B0aW9ucykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBhc3NlcnQodHlwZW9mIGdldHRlciA9PT0gJ2Z1bmN0aW9uJywgXCJzdG9yZS53YXRjaCBvbmx5IGFjY2VwdHMgYSBmdW5jdGlvbi5cIik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX3dhdGNoZXJWTS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0dGVyKHRoaXMkMS5zdGF0ZSwgdGhpcyQxLmdldHRlcnMpOyB9LCBjYiwgb3B0aW9ucylcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiByZXBsYWNlU3RhdGUgKHN0YXRlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLl92bS5fZGF0YS4kJHN0YXRlID0gc3RhdGU7XG4gIH0pO1xufTtcblxuU3RvcmUucHJvdG90eXBlLnJlZ2lzdGVyTW9kdWxlID0gZnVuY3Rpb24gcmVnaXN0ZXJNb2R1bGUgKHBhdGgsIHJhd01vZHVsZSwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuXG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShwYXRoKSwgXCJtb2R1bGUgcGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIEFycmF5LlwiKTtcbiAgICBhc3NlcnQocGF0aC5sZW5ndGggPiAwLCAnY2Fubm90IHJlZ2lzdGVyIHRoZSByb290IG1vZHVsZSBieSB1c2luZyByZWdpc3Rlck1vZHVsZS4nKTtcbiAgfVxuXG4gIHRoaXMuX21vZHVsZXMucmVnaXN0ZXIocGF0aCwgcmF3TW9kdWxlKTtcbiAgaW5zdGFsbE1vZHVsZSh0aGlzLCB0aGlzLnN0YXRlLCBwYXRoLCB0aGlzLl9tb2R1bGVzLmdldChwYXRoKSwgb3B0aW9ucy5wcmVzZXJ2ZVN0YXRlKTtcbiAgLy8gcmVzZXQgc3RvcmUgdG8gdXBkYXRlIGdldHRlcnMuLi5cbiAgcmVzZXRTdG9yZVZNKHRoaXMsIHRoaXMuc3RhdGUpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLnVucmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTW9kdWxlIChwYXRoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgeyBwYXRoID0gW3BhdGhdOyB9XG5cbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgdGhpcy5fbW9kdWxlcy51bnJlZ2lzdGVyKHBhdGgpO1xuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50U3RhdGUgPSBnZXROZXN0ZWRTdGF0ZSh0aGlzJDEuc3RhdGUsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICBWdWUuZGVsZXRlKHBhcmVudFN0YXRlLCBwYXRoW3BhdGgubGVuZ3RoIC0gMV0pO1xuICB9KTtcbiAgcmVzZXRTdG9yZSh0aGlzKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5oYXNNb2R1bGUgPSBmdW5jdGlvbiBoYXNNb2R1bGUgKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgeyBwYXRoID0gW3BhdGhdOyB9XG5cbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX21vZHVsZXMuaXNSZWdpc3RlcmVkKHBhdGgpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUuaG90VXBkYXRlID0gZnVuY3Rpb24gaG90VXBkYXRlIChuZXdPcHRpb25zKSB7XG4gIHRoaXMuX21vZHVsZXMudXBkYXRlKG5ld09wdGlvbnMpO1xuICByZXNldFN0b3JlKHRoaXMsIHRydWUpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLl93aXRoQ29tbWl0ID0gZnVuY3Rpb24gX3dpdGhDb21taXQgKGZuKSB7XG4gIHZhciBjb21taXR0aW5nID0gdGhpcy5fY29tbWl0dGluZztcbiAgdGhpcy5fY29tbWl0dGluZyA9IHRydWU7XG4gIGZuKCk7XG4gIHRoaXMuX2NvbW1pdHRpbmcgPSBjb21taXR0aW5nO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFN0b3JlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDEgKTtcblxuZnVuY3Rpb24gZ2VuZXJpY1N1YnNjcmliZSAoZm4sIHN1YnMsIG9wdGlvbnMpIHtcbiAgaWYgKHN1YnMuaW5kZXhPZihmbikgPCAwKSB7XG4gICAgb3B0aW9ucyAmJiBvcHRpb25zLnByZXBlbmRcbiAgICAgID8gc3Vicy51bnNoaWZ0KGZuKVxuICAgICAgOiBzdWJzLnB1c2goZm4pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSBzdWJzLmluZGV4T2YoZm4pO1xuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIHN1YnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldFN0b3JlIChzdG9yZSwgaG90KSB7XG4gIHN0b3JlLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX211dGF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIHN0YXRlID0gc3RvcmUuc3RhdGU7XG4gIC8vIGluaXQgYWxsIG1vZHVsZXNcbiAgaW5zdGFsbE1vZHVsZShzdG9yZSwgc3RhdGUsIFtdLCBzdG9yZS5fbW9kdWxlcy5yb290LCB0cnVlKTtcbiAgLy8gcmVzZXQgdm1cbiAgcmVzZXRTdG9yZVZNKHN0b3JlLCBzdGF0ZSwgaG90KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRTdG9yZVZNIChzdG9yZSwgc3RhdGUsIGhvdCkge1xuICB2YXIgb2xkVm0gPSBzdG9yZS5fdm07XG5cbiAgLy8gYmluZCBzdG9yZSBwdWJsaWMgZ2V0dGVyc1xuICBzdG9yZS5nZXR0ZXJzID0ge307XG4gIC8vIHJlc2V0IGxvY2FsIGdldHRlcnMgY2FjaGVcbiAgc3RvcmUuX21ha2VMb2NhbEdldHRlcnNDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciB3cmFwcGVkR2V0dGVycyA9IHN0b3JlLl93cmFwcGVkR2V0dGVycztcbiAgdmFyIGNvbXB1dGVkID0ge307XG4gIGZvckVhY2hWYWx1ZSh3cmFwcGVkR2V0dGVycywgZnVuY3Rpb24gKGZuLCBrZXkpIHtcbiAgICAvLyB1c2UgY29tcHV0ZWQgdG8gbGV2ZXJhZ2UgaXRzIGxhenktY2FjaGluZyBtZWNoYW5pc21cbiAgICAvLyBkaXJlY3QgaW5saW5lIGZ1bmN0aW9uIHVzZSB3aWxsIGxlYWQgdG8gY2xvc3VyZSBwcmVzZXJ2aW5nIG9sZFZtLlxuICAgIC8vIHVzaW5nIHBhcnRpYWwgdG8gcmV0dXJuIGZ1bmN0aW9uIHdpdGggb25seSBhcmd1bWVudHMgcHJlc2VydmVkIGluIGNsb3N1cmUgZW52aXJvbm1lbnQuXG4gICAgY29tcHV0ZWRba2V5XSA9IHBhcnRpYWwoZm4sIHN0b3JlKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RvcmUuZ2V0dGVycywga2V5LCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLl92bVtrZXldOyB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSAvLyBmb3IgbG9jYWwgZ2V0dGVyc1xuICAgIH0pO1xuICB9KTtcblxuICAvLyB1c2UgYSBWdWUgaW5zdGFuY2UgdG8gc3RvcmUgdGhlIHN0YXRlIHRyZWVcbiAgLy8gc3VwcHJlc3Mgd2FybmluZ3MganVzdCBpbiBjYXNlIHRoZSB1c2VyIGhhcyBhZGRlZFxuICAvLyBzb21lIGZ1bmt5IGdsb2JhbCBtaXhpbnNcbiAgdmFyIHNpbGVudCA9IFZ1ZS5jb25maWcuc2lsZW50O1xuICBWdWUuY29uZmlnLnNpbGVudCA9IHRydWU7XG4gIHN0b3JlLl92bSA9IG5ldyBWdWUoe1xuICAgIGRhdGE6IHtcbiAgICAgICQkc3RhdGU6IHN0YXRlXG4gICAgfSxcbiAgICBjb21wdXRlZDogY29tcHV0ZWRcbiAgfSk7XG4gIFZ1ZS5jb25maWcuc2lsZW50ID0gc2lsZW50O1xuXG4gIC8vIGVuYWJsZSBzdHJpY3QgbW9kZSBmb3IgbmV3IHZtXG4gIGlmIChzdG9yZS5zdHJpY3QpIHtcbiAgICBlbmFibGVTdHJpY3RNb2RlKHN0b3JlKTtcbiAgfVxuXG4gIGlmIChvbGRWbSkge1xuICAgIGlmIChob3QpIHtcbiAgICAgIC8vIGRpc3BhdGNoIGNoYW5nZXMgaW4gYWxsIHN1YnNjcmliZWQgd2F0Y2hlcnNcbiAgICAgIC8vIHRvIGZvcmNlIGdldHRlciByZS1ldmFsdWF0aW9uIGZvciBob3QgcmVsb2FkaW5nLlxuICAgICAgc3RvcmUuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBvbGRWbS5fZGF0YS4kJHN0YXRlID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBWdWUubmV4dFRpY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gb2xkVm0uJGRlc3Ryb3koKTsgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zdGFsbE1vZHVsZSAoc3RvcmUsIHJvb3RTdGF0ZSwgcGF0aCwgbW9kdWxlLCBob3QpIHtcbiAgdmFyIGlzUm9vdCA9ICFwYXRoLmxlbmd0aDtcbiAgdmFyIG5hbWVzcGFjZSA9IHN0b3JlLl9tb2R1bGVzLmdldE5hbWVzcGFjZShwYXRoKTtcblxuICAvLyByZWdpc3RlciBpbiBuYW1lc3BhY2UgbWFwXG4gIGlmIChtb2R1bGUubmFtZXNwYWNlZCkge1xuICAgIGlmIChzdG9yZS5fbW9kdWxlc05hbWVzcGFjZU1hcFtuYW1lc3BhY2VdICYmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gZHVwbGljYXRlIG5hbWVzcGFjZSBcIiArIG5hbWVzcGFjZSArIFwiIGZvciB0aGUgbmFtZXNwYWNlZCBtb2R1bGUgXCIgKyAocGF0aC5qb2luKCcvJykpKSk7XG4gICAgfVxuICAgIHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV0gPSBtb2R1bGU7XG4gIH1cblxuICAvLyBzZXQgc3RhdGVcbiAgaWYgKCFpc1Jvb3QgJiYgIWhvdCkge1xuICAgIHZhciBwYXJlbnRTdGF0ZSA9IGdldE5lc3RlZFN0YXRlKHJvb3RTdGF0ZSwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIHZhciBtb2R1bGVOYW1lID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHN0b3JlLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgaWYgKG1vZHVsZU5hbWUgaW4gcGFyZW50U3RhdGUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAoXCJbdnVleF0gc3RhdGUgZmllbGQgXFxcIlwiICsgbW9kdWxlTmFtZSArIFwiXFxcIiB3YXMgb3ZlcnJpZGRlbiBieSBhIG1vZHVsZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXQgXFxcIlwiICsgKHBhdGguam9pbignLicpKSArIFwiXFxcIlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFZ1ZS5zZXQocGFyZW50U3RhdGUsIG1vZHVsZU5hbWUsIG1vZHVsZS5zdGF0ZSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgbG9jYWwgPSBtb2R1bGUuY29udGV4dCA9IG1ha2VMb2NhbENvbnRleHQoc3RvcmUsIG5hbWVzcGFjZSwgcGF0aCk7XG5cbiAgbW9kdWxlLmZvckVhY2hNdXRhdGlvbihmdW5jdGlvbiAobXV0YXRpb24sIGtleSkge1xuICAgIHZhciBuYW1lc3BhY2VkVHlwZSA9IG5hbWVzcGFjZSArIGtleTtcbiAgICByZWdpc3Rlck11dGF0aW9uKHN0b3JlLCBuYW1lc3BhY2VkVHlwZSwgbXV0YXRpb24sIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hBY3Rpb24oZnVuY3Rpb24gKGFjdGlvbiwga2V5KSB7XG4gICAgdmFyIHR5cGUgPSBhY3Rpb24ucm9vdCA/IGtleSA6IG5hbWVzcGFjZSArIGtleTtcbiAgICB2YXIgaGFuZGxlciA9IGFjdGlvbi5oYW5kbGVyIHx8IGFjdGlvbjtcbiAgICByZWdpc3RlckFjdGlvbihzdG9yZSwgdHlwZSwgaGFuZGxlciwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaEdldHRlcihmdW5jdGlvbiAoZ2V0dGVyLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXk7XG4gICAgcmVnaXN0ZXJHZXR0ZXIoc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBnZXR0ZXIsIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQsIGtleSkge1xuICAgIGluc3RhbGxNb2R1bGUoc3RvcmUsIHJvb3RTdGF0ZSwgcGF0aC5jb25jYXQoa2V5KSwgY2hpbGQsIGhvdCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIG1ha2UgbG9jYWxpemVkIGRpc3BhdGNoLCBjb21taXQsIGdldHRlcnMgYW5kIHN0YXRlXG4gKiBpZiB0aGVyZSBpcyBubyBuYW1lc3BhY2UsIGp1c3QgdXNlIHJvb3Qgb25lc1xuICovXG5mdW5jdGlvbiBtYWtlTG9jYWxDb250ZXh0IChzdG9yZSwgbmFtZXNwYWNlLCBwYXRoKSB7XG4gIHZhciBub05hbWVzcGFjZSA9IG5hbWVzcGFjZSA9PT0gJyc7XG5cbiAgdmFyIGxvY2FsID0ge1xuICAgIGRpc3BhdGNoOiBub05hbWVzcGFjZSA/IHN0b3JlLmRpc3BhdGNoIDogZnVuY3Rpb24gKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICAgIHZhciBwYXlsb2FkID0gYXJncy5wYXlsb2FkO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmdzLm9wdGlvbnM7XG4gICAgICB2YXIgdHlwZSA9IGFyZ3MudHlwZTtcblxuICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnJvb3QpIHtcbiAgICAgICAgdHlwZSA9IG5hbWVzcGFjZSArIHR5cGU7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXN0b3JlLl9hY3Rpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBhY3Rpb24gdHlwZTogXCIgKyAoYXJncy50eXBlKSArIFwiLCBnbG9iYWwgdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKHR5cGUsIHBheWxvYWQpXG4gICAgfSxcblxuICAgIGNvbW1pdDogbm9OYW1lc3BhY2UgPyBzdG9yZS5jb21taXQgOiBmdW5jdGlvbiAoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgICAgdmFyIHBheWxvYWQgPSBhcmdzLnBheWxvYWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucm9vdCkge1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlICsgdHlwZTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhc3RvcmUuX211dGF0aW9uc1t0eXBlXSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIHVua25vd24gbG9jYWwgbXV0YXRpb24gdHlwZTogXCIgKyAoYXJncy50eXBlKSArIFwiLCBnbG9iYWwgdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RvcmUuY29tbWl0KHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICAvLyBnZXR0ZXJzIGFuZCBzdGF0ZSBvYmplY3QgbXVzdCBiZSBnb3R0ZW4gbGF6aWx5XG4gIC8vIGJlY2F1c2UgdGhleSB3aWxsIGJlIGNoYW5nZWQgYnkgdm0gdXBkYXRlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxvY2FsLCB7XG4gICAgZ2V0dGVyczoge1xuICAgICAgZ2V0OiBub05hbWVzcGFjZVxuICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLmdldHRlcnM7IH1cbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYWtlTG9jYWxHZXR0ZXJzKHN0b3JlLCBuYW1lc3BhY2UpOyB9XG4gICAgfSxcbiAgICBzdGF0ZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXROZXN0ZWRTdGF0ZShzdG9yZS5zdGF0ZSwgcGF0aCk7IH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBsb2NhbFxufVxuXG5mdW5jdGlvbiBtYWtlTG9jYWxHZXR0ZXJzIChzdG9yZSwgbmFtZXNwYWNlKSB7XG4gIGlmICghc3RvcmUuX21ha2VMb2NhbEdldHRlcnNDYWNoZVtuYW1lc3BhY2VdKSB7XG4gICAgdmFyIGdldHRlcnNQcm94eSA9IHt9O1xuICAgIHZhciBzcGxpdFBvcyA9IG5hbWVzcGFjZS5sZW5ndGg7XG4gICAgT2JqZWN0LmtleXMoc3RvcmUuZ2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgLy8gc2tpcCBpZiB0aGUgdGFyZ2V0IGdldHRlciBpcyBub3QgbWF0Y2ggdGhpcyBuYW1lc3BhY2VcbiAgICAgIGlmICh0eXBlLnNsaWNlKDAsIHNwbGl0UG9zKSAhPT0gbmFtZXNwYWNlKSB7IHJldHVybiB9XG5cbiAgICAgIC8vIGV4dHJhY3QgbG9jYWwgZ2V0dGVyIHR5cGVcbiAgICAgIHZhciBsb2NhbFR5cGUgPSB0eXBlLnNsaWNlKHNwbGl0UG9zKTtcblxuICAgICAgLy8gQWRkIGEgcG9ydCB0byB0aGUgZ2V0dGVycyBwcm94eS5cbiAgICAgIC8vIERlZmluZSBhcyBnZXR0ZXIgcHJvcGVydHkgYmVjYXVzZVxuICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXZhbHVhdGUgdGhlIGdldHRlcnMgaW4gdGhpcyB0aW1lLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldHRlcnNQcm94eSwgbG9jYWxUeXBlLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0dGVyc1t0eXBlXTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgc3RvcmUuX21ha2VMb2NhbEdldHRlcnNDYWNoZVtuYW1lc3BhY2VdID0gZ2V0dGVyc1Byb3h5O1xuICB9XG5cbiAgcmV0dXJuIHN0b3JlLl9tYWtlTG9jYWxHZXR0ZXJzQ2FjaGVbbmFtZXNwYWNlXVxufVxuXG5mdW5jdGlvbiByZWdpc3Rlck11dGF0aW9uIChzdG9yZSwgdHlwZSwgaGFuZGxlciwgbG9jYWwpIHtcbiAgdmFyIGVudHJ5ID0gc3RvcmUuX211dGF0aW9uc1t0eXBlXSB8fCAoc3RvcmUuX211dGF0aW9uc1t0eXBlXSA9IFtdKTtcbiAgZW50cnkucHVzaChmdW5jdGlvbiB3cmFwcGVkTXV0YXRpb25IYW5kbGVyIChwYXlsb2FkKSB7XG4gICAgaGFuZGxlci5jYWxsKHN0b3JlLCBsb2NhbC5zdGF0ZSwgcGF5bG9hZCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckFjdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9hY3Rpb25zW3R5cGVdIHx8IChzdG9yZS5fYWN0aW9uc1t0eXBlXSA9IFtdKTtcbiAgZW50cnkucHVzaChmdW5jdGlvbiB3cmFwcGVkQWN0aW9uSGFuZGxlciAocGF5bG9hZCkge1xuICAgIHZhciByZXMgPSBoYW5kbGVyLmNhbGwoc3RvcmUsIHtcbiAgICAgIGRpc3BhdGNoOiBsb2NhbC5kaXNwYXRjaCxcbiAgICAgIGNvbW1pdDogbG9jYWwuY29tbWl0LFxuICAgICAgZ2V0dGVyczogbG9jYWwuZ2V0dGVycyxcbiAgICAgIHN0YXRlOiBsb2NhbC5zdGF0ZSxcbiAgICAgIHJvb3RHZXR0ZXJzOiBzdG9yZS5nZXR0ZXJzLFxuICAgICAgcm9vdFN0YXRlOiBzdG9yZS5zdGF0ZVxuICAgIH0sIHBheWxvYWQpO1xuICAgIGlmICghaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcyA9IFByb21pc2UucmVzb2x2ZShyZXMpO1xuICAgIH1cbiAgICBpZiAoc3RvcmUuX2RldnRvb2xIb29rKSB7XG4gICAgICByZXR1cm4gcmVzLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc3RvcmUuX2RldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6ZXJyb3InLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckdldHRlciAoc3RvcmUsIHR5cGUsIHJhd0dldHRlciwgbG9jYWwpIHtcbiAgaWYgKHN0b3JlLl93cmFwcGVkR2V0dGVyc1t0eXBlXSkge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIGR1cGxpY2F0ZSBnZXR0ZXIga2V5OiBcIiArIHR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgc3RvcmUuX3dyYXBwZWRHZXR0ZXJzW3R5cGVdID0gZnVuY3Rpb24gd3JhcHBlZEdldHRlciAoc3RvcmUpIHtcbiAgICByZXR1cm4gcmF3R2V0dGVyKFxuICAgICAgbG9jYWwuc3RhdGUsIC8vIGxvY2FsIHN0YXRlXG4gICAgICBsb2NhbC5nZXR0ZXJzLCAvLyBsb2NhbCBnZXR0ZXJzXG4gICAgICBzdG9yZS5zdGF0ZSwgLy8gcm9vdCBzdGF0ZVxuICAgICAgc3RvcmUuZ2V0dGVycyAvLyByb290IGdldHRlcnNcbiAgICApXG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuYWJsZVN0cmljdE1vZGUgKHN0b3JlKSB7XG4gIHN0b3JlLl92bS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YS4kJHN0YXRlIH0sIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICBhc3NlcnQoc3RvcmUuX2NvbW1pdHRpbmcsIFwiZG8gbm90IG11dGF0ZSB2dWV4IHN0b3JlIHN0YXRlIG91dHNpZGUgbXV0YXRpb24gaGFuZGxlcnMuXCIpO1xuICAgIH1cbiAgfSwgeyBkZWVwOiB0cnVlLCBzeW5jOiB0cnVlIH0pO1xufVxuXG5mdW5jdGlvbiBnZXROZXN0ZWRTdGF0ZSAoc3RhdGUsIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChzdGF0ZSwga2V5KSB7IHJldHVybiBzdGF0ZVtrZXldOyB9LCBzdGF0ZSlcbn1cblxuZnVuY3Rpb24gdW5pZnlPYmplY3RTdHlsZSAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICBpZiAoaXNPYmplY3QodHlwZSkgJiYgdHlwZS50eXBlKSB7XG4gICAgb3B0aW9ucyA9IHBheWxvYWQ7XG4gICAgcGF5bG9hZCA9IHR5cGU7XG4gICAgdHlwZSA9IHR5cGUudHlwZTtcbiAgfVxuXG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBhc3NlcnQodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnLCAoXCJleHBlY3RzIHN0cmluZyBhcyB0aGUgdHlwZSwgYnV0IGZvdW5kIFwiICsgKHR5cGVvZiB0eXBlKSArIFwiLlwiKSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBwYXlsb2FkLCBvcHRpb25zOiBvcHRpb25zIH1cbn1cblxuZnVuY3Rpb24gaW5zdGFsbCAoX1Z1ZSkge1xuICBpZiAoVnVlICYmIF9WdWUgPT09IFZ1ZSkge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdbdnVleF0gYWxyZWFkeSBpbnN0YWxsZWQuIFZ1ZS51c2UoVnVleCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgVnVlID0gX1Z1ZTtcbiAgYXBwbHlNaXhpbihWdWUpO1xufVxuXG4vKipcbiAqIFJlZHVjZSB0aGUgY29kZSB3aGljaCB3cml0dGVuIGluIFZ1ZS5qcyBmb3IgZ2V0dGluZyB0aGUgc3RhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVzcGFjZV0gLSBNb2R1bGUncyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBzdGF0ZXMgIyBPYmplY3QncyBpdGVtIGNhbiBiZSBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdCBzdGF0ZSBhbmQgZ2V0dGVycyBmb3IgcGFyYW0sIHlvdSBjYW4gZG8gc29tZXRoaW5nIGZvciBzdGF0ZSBhbmQgZ2V0dGVycyBpbiBpdC5cbiAqIEBwYXJhbSB7T2JqZWN0fVxuICovXG52YXIgbWFwU3RhdGUgPSBub3JtYWxpemVOYW1lc3BhY2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwgc3RhdGVzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNWYWxpZE1hcChzdGF0ZXMpKSB7XG4gICAgY29uc29sZS5lcnJvcignW3Z1ZXhdIG1hcFN0YXRlOiBtYXBwZXIgcGFyYW1ldGVyIG11c3QgYmUgZWl0aGVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCcpO1xuICB9XG4gIG5vcm1hbGl6ZU1hcChzdGF0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRTdGF0ZSAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLiRzdG9yZS5zdGF0ZTtcbiAgICAgIHZhciBnZXR0ZXJzID0gdGhpcy4kc3RvcmUuZ2V0dGVycztcbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgdmFyIG1vZHVsZSA9IGdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwU3RhdGUnLCBuYW1lc3BhY2UpO1xuICAgICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHN0YXRlID0gbW9kdWxlLmNvbnRleHQuc3RhdGU7XG4gICAgICAgIGdldHRlcnMgPSBtb2R1bGUuY29udGV4dC5nZXR0ZXJzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB2YWwuY2FsbCh0aGlzLCBzdGF0ZSwgZ2V0dGVycylcbiAgICAgICAgOiBzdGF0ZVt2YWxdXG4gICAgfTtcbiAgICAvLyBtYXJrIHZ1ZXggZ2V0dGVyIGZvciBkZXZ0b29sc1xuICAgIHJlc1trZXldLnZ1ZXggPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8qKlxuICogUmVkdWNlIHRoZSBjb2RlIHdoaWNoIHdyaXR0ZW4gaW4gVnVlLmpzIGZvciBjb21taXR0aW5nIHRoZSBtdXRhdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lc3BhY2VdIC0gTW9kdWxlJ3MgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gbXV0YXRpb25zICMgT2JqZWN0J3MgaXRlbSBjYW4gYmUgYSBmdW5jdGlvbiB3aGljaCBhY2NlcHQgYGNvbW1pdGAgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IHBhcmFtLCBpdCBjYW4gYWNjZXB0IGFub3RoZXIgcGFyYW1zLiBZb3UgY2FuIGNvbW1pdCBtdXRhdGlvbiBhbmQgZG8gYW55IG90aGVyIHRoaW5ncyBpbiB0aGlzIGZ1bmN0aW9uLiBzcGVjaWFsbHksIFlvdSBuZWVkIHRvIHBhc3MgYW50aG9yIHBhcmFtcyBmcm9tIHRoZSBtYXBwZWQgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBtYXBNdXRhdGlvbnMgPSBub3JtYWxpemVOYW1lc3BhY2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwgbXV0YXRpb25zKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNWYWxpZE1hcChtdXRhdGlvbnMpKSB7XG4gICAgY29uc29sZS5lcnJvcignW3Z1ZXhdIG1hcE11dGF0aW9uczogbWFwcGVyIHBhcmFtZXRlciBtdXN0IGJlIGVpdGhlciBhbiBBcnJheSBvciBhbiBPYmplY3QnKTtcbiAgfVxuICBub3JtYWxpemVNYXAobXV0YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkTXV0YXRpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIC8vIEdldCB0aGUgY29tbWl0IG1ldGhvZCBmcm9tIHN0b3JlXG4gICAgICB2YXIgY29tbWl0ID0gdGhpcy4kc3RvcmUuY29tbWl0O1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgbW9kdWxlID0gZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBNdXRhdGlvbnMnLCBuYW1lc3BhY2UpO1xuICAgICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNvbW1pdCA9IG1vZHVsZS5jb250ZXh0LmNvbW1pdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdmFsLmFwcGx5KHRoaXMsIFtjb21taXRdLmNvbmNhdChhcmdzKSlcbiAgICAgICAgOiBjb21taXQuYXBwbHkodGhpcy4kc3RvcmUsIFt2YWxdLmNvbmNhdChhcmdzKSlcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8qKlxuICogUmVkdWNlIHRoZSBjb2RlIHdoaWNoIHdyaXR0ZW4gaW4gVnVlLmpzIGZvciBnZXR0aW5nIHRoZSBnZXR0ZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVzcGFjZV0gLSBNb2R1bGUncyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBnZXR0ZXJzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBtYXBHZXR0ZXJzID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGdldHRlcnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1ZhbGlkTWFwKGdldHRlcnMpKSB7XG4gICAgY29uc29sZS5lcnJvcignW3Z1ZXhdIG1hcEdldHRlcnM6IG1hcHBlciBwYXJhbWV0ZXIgbXVzdCBiZSBlaXRoZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0Jyk7XG4gIH1cbiAgbm9ybWFsaXplTWFwKGdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgLy8gVGhlIG5hbWVzcGFjZSBoYXMgYmVlbiBtdXRhdGVkIGJ5IG5vcm1hbGl6ZU5hbWVzcGFjZVxuICAgIHZhbCA9IG5hbWVzcGFjZSArIHZhbDtcbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZEdldHRlciAoKSB7XG4gICAgICBpZiAobmFtZXNwYWNlICYmICFnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcEdldHRlcnMnLCBuYW1lc3BhY2UpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhKHZhbCBpbiB0aGlzLiRzdG9yZS5nZXR0ZXJzKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGdldHRlcjogXCIgKyB2YWwpKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVyc1t2YWxdXG4gICAgfTtcbiAgICAvLyBtYXJrIHZ1ZXggZ2V0dGVyIGZvciBkZXZ0b29sc1xuICAgIHJlc1trZXldLnZ1ZXggPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8qKlxuICogUmVkdWNlIHRoZSBjb2RlIHdoaWNoIHdyaXR0ZW4gaW4gVnVlLmpzIGZvciBkaXNwYXRjaCB0aGUgYWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVzcGFjZV0gLSBNb2R1bGUncyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBhY3Rpb25zICMgT2JqZWN0J3MgaXRlbSBjYW4gYmUgYSBmdW5jdGlvbiB3aGljaCBhY2NlcHQgYGRpc3BhdGNoYCBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgcGFyYW0sIGl0IGNhbiBhY2NlcHQgYW50aG9yIHBhcmFtcy4gWW91IGNhbiBkaXNwYXRjaCBhY3Rpb24gYW5kIGRvIGFueSBvdGhlciB0aGluZ3MgaW4gdGhpcyBmdW5jdGlvbi4gc3BlY2lhbGx5LCBZb3UgbmVlZCB0byBwYXNzIGFudGhvciBwYXJhbXMgZnJvbSB0aGUgbWFwcGVkIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgbWFwQWN0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBhY3Rpb25zKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNWYWxpZE1hcChhY3Rpb25zKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1t2dWV4XSBtYXBBY3Rpb25zOiBtYXBwZXIgcGFyYW1ldGVyIG11c3QgYmUgZWl0aGVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCcpO1xuICB9XG4gIG5vcm1hbGl6ZU1hcChhY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkQWN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAvLyBnZXQgZGlzcGF0Y2ggZnVuY3Rpb24gZnJvbSBzdG9yZVxuICAgICAgdmFyIGRpc3BhdGNoID0gdGhpcy4kc3RvcmUuZGlzcGF0Y2g7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcEFjdGlvbnMnLCBuYW1lc3BhY2UpO1xuICAgICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoID0gbW9kdWxlLmNvbnRleHQuZGlzcGF0Y2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5hcHBseSh0aGlzLCBbZGlzcGF0Y2hdLmNvbmNhdChhcmdzKSlcbiAgICAgICAgOiBkaXNwYXRjaC5hcHBseSh0aGlzLiRzdG9yZSwgW3ZhbF0uY29uY2F0KGFyZ3MpKVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLyoqXG4gKiBSZWJpbmRpbmcgbmFtZXNwYWNlIHBhcmFtIGZvciBtYXBYWFggZnVuY3Rpb24gaW4gc3BlY2lhbCBzY29wZWQsIGFuZCByZXR1cm4gdGhlbSBieSBzaW1wbGUgb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBjcmVhdGVOYW1lc3BhY2VkSGVscGVycyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UpIHsgcmV0dXJuICh7XG4gIG1hcFN0YXRlOiBtYXBTdGF0ZS5iaW5kKG51bGwsIG5hbWVzcGFjZSksXG4gIG1hcEdldHRlcnM6IG1hcEdldHRlcnMuYmluZChudWxsLCBuYW1lc3BhY2UpLFxuICBtYXBNdXRhdGlvbnM6IG1hcE11dGF0aW9ucy5iaW5kKG51bGwsIG5hbWVzcGFjZSksXG4gIG1hcEFjdGlvbnM6IG1hcEFjdGlvbnMuYmluZChudWxsLCBuYW1lc3BhY2UpXG59KTsgfTtcblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIG1hcFxuICogbm9ybWFsaXplTWFwKFsxLCAyLCAzXSkgPT4gWyB7IGtleTogMSwgdmFsOiAxIH0sIHsga2V5OiAyLCB2YWw6IDIgfSwgeyBrZXk6IDMsIHZhbDogMyB9IF1cbiAqIG5vcm1hbGl6ZU1hcCh7YTogMSwgYjogMiwgYzogM30pID0+IFsgeyBrZXk6ICdhJywgdmFsOiAxIH0sIHsga2V5OiAnYicsIHZhbDogMiB9LCB7IGtleTogJ2MnLCB2YWw6IDMgfSBdXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gbWFwXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1hcCAobWFwKSB7XG4gIGlmICghaXNWYWxpZE1hcChtYXApKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobWFwKVxuICAgID8gbWFwLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoeyBrZXk6IGtleSwgdmFsOiBrZXkgfSk7IH0pXG4gICAgOiBPYmplY3Qua2V5cyhtYXApLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoeyBrZXk6IGtleSwgdmFsOiBtYXBba2V5XSB9KTsgfSlcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSB3aGV0aGVyIGdpdmVuIG1hcCBpcyB2YWxpZCBvciBub3RcbiAqIEBwYXJhbSB7Kn0gbWFwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkTWFwIChtYXApIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobWFwKSB8fCBpc09iamVjdChtYXApXG59XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gZXhwZWN0IHR3byBwYXJhbSBjb250YWlucyBuYW1lc3BhY2UgYW5kIG1hcC4gaXQgd2lsbCBub3JtYWxpemUgdGhlIG5hbWVzcGFjZSBhbmQgdGhlbiB0aGUgcGFyYW0ncyBmdW5jdGlvbiB3aWxsIGhhbmRsZSB0aGUgbmV3IG5hbWVzcGFjZSBhbmQgdGhlIG1hcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplTmFtZXNwYWNlIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWFwKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICBtYXAgPSBuYW1lc3BhY2U7XG4gICAgICBuYW1lc3BhY2UgPSAnJztcbiAgICB9IGVsc2UgaWYgKG5hbWVzcGFjZS5jaGFyQXQobmFtZXNwYWNlLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgIG5hbWVzcGFjZSArPSAnLyc7XG4gICAgfVxuICAgIHJldHVybiBmbihuYW1lc3BhY2UsIG1hcClcbiAgfVxufVxuXG4vKipcbiAqIFNlYXJjaCBhIHNwZWNpYWwgbW9kdWxlIGZyb20gc3RvcmUgYnkgbmFtZXNwYWNlLiBpZiBtb2R1bGUgbm90IGV4aXN0LCBwcmludCBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IHN0b3JlXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVscGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE1vZHVsZUJ5TmFtZXNwYWNlIChzdG9yZSwgaGVscGVyLCBuYW1lc3BhY2UpIHtcbiAgdmFyIG1vZHVsZSA9IHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV07XG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIW1vZHVsZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIG1vZHVsZSBuYW1lc3BhY2Ugbm90IGZvdW5kIGluIFwiICsgaGVscGVyICsgXCIoKTogXCIgKyBuYW1lc3BhY2UpKTtcbiAgfVxuICByZXR1cm4gbW9kdWxlXG59XG5cbi8vIENyZWRpdHM6IGJvcnJvd2VkIGNvZGUgZnJvbSBmY29tYi9yZWR1eC1sb2dnZXJcblxuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyIChyZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICB2YXIgY29sbGFwc2VkID0gcmVmLmNvbGxhcHNlZDsgaWYgKCBjb2xsYXBzZWQgPT09IHZvaWQgMCApIGNvbGxhcHNlZCA9IHRydWU7XG4gIHZhciBmaWx0ZXIgPSByZWYuZmlsdGVyOyBpZiAoIGZpbHRlciA9PT0gdm9pZCAwICkgZmlsdGVyID0gZnVuY3Rpb24gKG11dGF0aW9uLCBzdGF0ZUJlZm9yZSwgc3RhdGVBZnRlcikgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgdmFyIHRyYW5zZm9ybWVyID0gcmVmLnRyYW5zZm9ybWVyOyBpZiAoIHRyYW5zZm9ybWVyID09PSB2b2lkIDAgKSB0cmFuc2Zvcm1lciA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGU7IH07XG4gIHZhciBtdXRhdGlvblRyYW5zZm9ybWVyID0gcmVmLm11dGF0aW9uVHJhbnNmb3JtZXI7IGlmICggbXV0YXRpb25UcmFuc2Zvcm1lciA9PT0gdm9pZCAwICkgbXV0YXRpb25UcmFuc2Zvcm1lciA9IGZ1bmN0aW9uIChtdXQpIHsgcmV0dXJuIG11dDsgfTtcbiAgdmFyIGFjdGlvbkZpbHRlciA9IHJlZi5hY3Rpb25GaWx0ZXI7IGlmICggYWN0aW9uRmlsdGVyID09PSB2b2lkIDAgKSBhY3Rpb25GaWx0ZXIgPSBmdW5jdGlvbiAoYWN0aW9uLCBzdGF0ZSkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgdmFyIGFjdGlvblRyYW5zZm9ybWVyID0gcmVmLmFjdGlvblRyYW5zZm9ybWVyOyBpZiAoIGFjdGlvblRyYW5zZm9ybWVyID09PSB2b2lkIDAgKSBhY3Rpb25UcmFuc2Zvcm1lciA9IGZ1bmN0aW9uIChhY3QpIHsgcmV0dXJuIGFjdDsgfTtcbiAgdmFyIGxvZ011dGF0aW9ucyA9IHJlZi5sb2dNdXRhdGlvbnM7IGlmICggbG9nTXV0YXRpb25zID09PSB2b2lkIDAgKSBsb2dNdXRhdGlvbnMgPSB0cnVlO1xuICB2YXIgbG9nQWN0aW9ucyA9IHJlZi5sb2dBY3Rpb25zOyBpZiAoIGxvZ0FjdGlvbnMgPT09IHZvaWQgMCApIGxvZ0FjdGlvbnMgPSB0cnVlO1xuICB2YXIgbG9nZ2VyID0gcmVmLmxvZ2dlcjsgaWYgKCBsb2dnZXIgPT09IHZvaWQgMCApIGxvZ2dlciA9IGNvbnNvbGU7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZSkge1xuICAgIHZhciBwcmV2U3RhdGUgPSBkZWVwQ29weShzdG9yZS5zdGF0ZSk7XG5cbiAgICBpZiAodHlwZW9mIGxvZ2dlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChsb2dNdXRhdGlvbnMpIHtcbiAgICAgIHN0b3JlLnN1YnNjcmliZShmdW5jdGlvbiAobXV0YXRpb24sIHN0YXRlKSB7XG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSBkZWVwQ29weShzdGF0ZSk7XG5cbiAgICAgICAgaWYgKGZpbHRlcihtdXRhdGlvbiwgcHJldlN0YXRlLCBuZXh0U3RhdGUpKSB7XG4gICAgICAgICAgdmFyIGZvcm1hdHRlZFRpbWUgPSBnZXRGb3JtYXR0ZWRUaW1lKCk7XG4gICAgICAgICAgdmFyIGZvcm1hdHRlZE11dGF0aW9uID0gbXV0YXRpb25UcmFuc2Zvcm1lcihtdXRhdGlvbik7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIm11dGF0aW9uIFwiICsgKG11dGF0aW9uLnR5cGUpICsgZm9ybWF0dGVkVGltZTtcblxuICAgICAgICAgIHN0YXJ0TWVzc2FnZShsb2dnZXIsIG1lc3NhZ2UsIGNvbGxhcHNlZCk7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnJWMgcHJldiBzdGF0ZScsICdjb2xvcjogIzlFOUU5RTsgZm9udC13ZWlnaHQ6IGJvbGQnLCB0cmFuc2Zvcm1lcihwcmV2U3RhdGUpKTtcbiAgICAgICAgICBsb2dnZXIubG9nKCclYyBtdXRhdGlvbicsICdjb2xvcjogIzAzQTlGNDsgZm9udC13ZWlnaHQ6IGJvbGQnLCBmb3JtYXR0ZWRNdXRhdGlvbik7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnJWMgbmV4dCBzdGF0ZScsICdjb2xvcjogIzRDQUY1MDsgZm9udC13ZWlnaHQ6IGJvbGQnLCB0cmFuc2Zvcm1lcihuZXh0U3RhdGUpKTtcbiAgICAgICAgICBlbmRNZXNzYWdlKGxvZ2dlcik7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2U3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobG9nQWN0aW9ucykge1xuICAgICAgc3RvcmUuc3Vic2NyaWJlQWN0aW9uKGZ1bmN0aW9uIChhY3Rpb24sIHN0YXRlKSB7XG4gICAgICAgIGlmIChhY3Rpb25GaWx0ZXIoYWN0aW9uLCBzdGF0ZSkpIHtcbiAgICAgICAgICB2YXIgZm9ybWF0dGVkVGltZSA9IGdldEZvcm1hdHRlZFRpbWUoKTtcbiAgICAgICAgICB2YXIgZm9ybWF0dGVkQWN0aW9uID0gYWN0aW9uVHJhbnNmb3JtZXIoYWN0aW9uKTtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiYWN0aW9uIFwiICsgKGFjdGlvbi50eXBlKSArIGZvcm1hdHRlZFRpbWU7XG5cbiAgICAgICAgICBzdGFydE1lc3NhZ2UobG9nZ2VyLCBtZXNzYWdlLCBjb2xsYXBzZWQpO1xuICAgICAgICAgIGxvZ2dlci5sb2coJyVjIGFjdGlvbicsICdjb2xvcjogIzAzQTlGNDsgZm9udC13ZWlnaHQ6IGJvbGQnLCBmb3JtYXR0ZWRBY3Rpb24pO1xuICAgICAgICAgIGVuZE1lc3NhZ2UobG9nZ2VyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0TWVzc2FnZSAobG9nZ2VyLCBtZXNzYWdlLCBjb2xsYXBzZWQpIHtcbiAgdmFyIHN0YXJ0TWVzc2FnZSA9IGNvbGxhcHNlZFxuICAgID8gbG9nZ2VyLmdyb3VwQ29sbGFwc2VkXG4gICAgOiBsb2dnZXIuZ3JvdXA7XG5cbiAgLy8gcmVuZGVyXG4gIHRyeSB7XG4gICAgc3RhcnRNZXNzYWdlLmNhbGwobG9nZ2VyLCBtZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ2dlci5sb2cobWVzc2FnZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kTWVzc2FnZSAobG9nZ2VyKSB7XG4gIHRyeSB7XG4gICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXIubG9nKCfigJTigJQgbG9nIGVuZCDigJTigJQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRGb3JtYXR0ZWRUaW1lICgpIHtcbiAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpO1xuICByZXR1cm4gKFwiIEAgXCIgKyAocGFkKHRpbWUuZ2V0SG91cnMoKSwgMikpICsgXCI6XCIgKyAocGFkKHRpbWUuZ2V0TWludXRlcygpLCAyKSkgKyBcIjpcIiArIChwYWQodGltZS5nZXRTZWNvbmRzKCksIDIpKSArIFwiLlwiICsgKHBhZCh0aW1lLmdldE1pbGxpc2Vjb25kcygpLCAzKSkpXG59XG5cbmZ1bmN0aW9uIHJlcGVhdCAoc3RyLCB0aW1lcykge1xuICByZXR1cm4gKG5ldyBBcnJheSh0aW1lcyArIDEpKS5qb2luKHN0cilcbn1cblxuZnVuY3Rpb24gcGFkIChudW0sIG1heExlbmd0aCkge1xuICByZXR1cm4gcmVwZWF0KCcwJywgbWF4TGVuZ3RoIC0gbnVtLnRvU3RyaW5nKCkubGVuZ3RoKSArIG51bVxufVxuXG52YXIgaW5kZXggPSB7XG4gIFN0b3JlOiBTdG9yZSxcbiAgaW5zdGFsbDogaW5zdGFsbCxcbiAgdmVyc2lvbjogJzMuNi4yJyxcbiAgbWFwU3RhdGU6IG1hcFN0YXRlLFxuICBtYXBNdXRhdGlvbnM6IG1hcE11dGF0aW9ucyxcbiAgbWFwR2V0dGVyczogbWFwR2V0dGVycyxcbiAgbWFwQWN0aW9uczogbWFwQWN0aW9ucyxcbiAgY3JlYXRlTmFtZXNwYWNlZEhlbHBlcnM6IGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzLFxuICBjcmVhdGVMb2dnZXI6IGNyZWF0ZUxvZ2dlclxufTtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG5leHBvcnQgeyBTdG9yZSwgY3JlYXRlTG9nZ2VyLCBjcmVhdGVOYW1lc3BhY2VkSGVscGVycywgaW5zdGFsbCwgbWFwQWN0aW9ucywgbWFwR2V0dGVycywgbWFwTXV0YXRpb25zLCBtYXBTdGF0ZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///629\n")}}]);